<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
</style>
<body>

  <script>

// ***Console***

// Log number
console.log(100);

// Log string
console.log('Hello World');

// Log multiple values
console.log(20, 'Hello', true);

// Log a variable
const x = 100;
console.log(x);

// Console error & warning
console.error('Alert');
console.warn('Warning');

// Log object as table
console.table({ name: 'Brad', email: 'brad@gmail.com' });

// Group console commands
console.group('simple');
console.log(x);
console.error('Alert');
console.warn('Warning');
console.groupEnd();

// Add CSS to logs
const styles = 'padding: 10px; background-color: white; color: green';
console.log('%cHello World', styles);


// ***Comments & Shortcuts***

// This is a single line of code

/*
Multi-line comment
console.log(100);

console.log('Hello World');

console.log(20, 'Hello', true);
*/


// ***Variables***

// Ways to declare a variable
// `var`, `let`, & `const`

let firstName = 'Osman'
const lastName = 'Ijaz'
let age = '40'

console.log(age)

// Naming Conventions
// - Only letters, numbers, underscores and dollar signs
// - Can't start with a number

// Multi-Word Formatting

// firstName = camelCase
// first_name = underscore
// FirstName = PascalCase
// firstname = lowercase


// We can re-assign `let` variables. If you change `age` to use `const`, you will get an error
age = 33;
console.log(age);

// With let, we can declare a value without assigning a value
let score;
score = 1;
console.log(score);


// We can not re-assign a const variable
// x = 200 // Will result in an error


// We can still manipulate arrays and objects using const

const arr = [1, 2, 3, 4];
arr.push(5)
console.log(arr) // [1, 2, 3, 4, 5]


const person = {
  name: 'Brad',
  }

  person.name = 'John'
  person.email = 'brad@gmail.com'
  console.log(person)

// Declare multiple values at once
let a, b, c

const d = 10,
  e = 20,
  f = 30;

console.log(d);
console.log(a); //undefined 


// ***Data Types***

// Primitive 

// String
const firstName1 = 'Sophia';

const output = firstName1

console.log(firstName1, typeof firstName1)

// Number
const newAge = 30;
const temp = 98.9;

const output1 = newAge

console.log(output1, typeof output1)

// Boolean
const hasKids = true 

// Null (intentionally purposly defined empty)
// (Null output represented as an Object) 
const aptNumber = null;

// Undefined (not yet assigned or defined)
// let score;
const scoreNumber = undefined;

// Symbol ES6 
const id = Symbol('id');

// BigInt (Number type can't handle large numbers so use BigInt)
const n = 9007199254740991n;


// Reference Types (Objects): Non-Primitive when assigned to variable it is given a reference to that value...

// Objects, Arrays and Functions are all reference types

const numbers = [1, 2, 3, 4]

const person2 = {
  name: 'Brad' 
}

function saySalaam(){
console.log('Salaam Alaikum')
}

const output2 = saySalaam;
console.log(output2, typeof output2);

// More info on why typeof null == object
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null

//  More info on the "function object" type
// https://262.ecma-international.org/5.1/#sec-11.4.3


// ***Stack vs Heap*** 

// stack 
// stack primitive type stored directly in the stack where it is accssed from...
// e.g. String, Boolean, Number, Null, Undefined, Symbol, BigInt

// heap 
// reference Type (stored in the heap accessed by reference)
// e.g. Arrays, Functions, Objects  


// Value is stored in the stack primitive
const name = 'Osman'
const age = 30


// Reference values is stored in the heap
const person = { //stack
name:'Brad', //heap
age: 40 //heap
}

let newName = name;   
newName = 'Muhammad' 

let newPerson = person; //stack
newPerson.name = 'Sumra' //heap

console.log(name, newName)
console.log(person, newPerson)


// ***Type Conversion*** (explicity convert types) 


let amount = '100'
console.log(amount, typeof amount)
// 100 string

// convert string to a number 

// amount = parseInt(amount positive negative number)
// amount = +amount 
// amount = Number(amount)


// *convert number to string* 

// let amount = 100 //number primitive type not an object

// toString() // methods are properties on objects e.g. toString()

// amount should be a primitive doesn't have methods
// .toString() javascript creates a temporary wrapper of the appropriate object type
// amount doesn't intrinsically have any methods on it because it is not an object but if we add toString() on it js creates temporary wrapper of the associated type

amount = amount.toString()
amount = String(amount)
console.log(amount, typeof amount)

// *convert string to decimal* 

let amountDecimal = '99.5'
amountDecimal = parseFloat(amountDecimal)

console.log(amountDecimal, typeof amountDecimal)

// *convert number to boolean*

let amountBoolean = 0
amountBoolean = Boolean(amountBoolean)  
console.log(amountBoolean, typeof
  amountBoolean)

// Ways to get NaN
// property of global window object
// non writable property 

let amountNaN = 'hello'
amountNaN = parseInt(amountNaN)
console.log(amountNaN, typeof amountNaN)

// NaN 'number'

// *5 different types of operations that can return NaN*

// 1
// parseInt() //when number cant be passed
// let amount = 'hello';
// amount = parseInt(amount)
// console.log(amount, typeof amount)

// 2
// console.log(Math.sqrt(-1));

// 3
// console.log(1 + NaN);

// 4
// console.log(undefined + undefined);

// 5
// console.log('foo' / 3);



// ***Operators***

// 1. Arithmetic Operators

let x;

x = 5 + 5;
x = 5 - 5;
x = 5 * 5;
x = 5 / 5;
x = 7 % 5;


// Concatenation 
x = 'Hello' + ' ' + 'World'
console.log(x);


// Exponent (Double Asterisk)
//  to get the result of first operant to the power of the second
x = 2 ** 3;


// Increment
x = 1;
// x = x + 1;
x++;


// Decrement
// x = x - 1;
x--;

// 2. Assignment Operators

x = 10;

x += 5;
x -= 5;
x *= 5;
x /= 5;
x %= 5;
x **= 5;

// 3. Comparison Operators

// Equal to (Just the value, not the type)
x = 2 == '2'; //true

// Equal to (Type and value)
x = 2 === '2'; //false

// Not equal to (Just the value, not the type)
x = 2 != '2'; //false (2 is = 2)

// Not equal to (Type and value)
x = 2 !== '2'; //true (that it is not = when checking type and value)
x = 2 !== 2; //false (remove quotes as 2 is = 2)

// Greater than and less than
x = 10 > 5;
x = 10 < 5;
x = 10 <= 5;
x = 10 >= 5;

console.log(x);


// ***Type Coercion***

let x;

// Coerced to a string (+ concatenates but with */- it will give the answer)
x = 5 + '5'; //55 String

x = 5 + Number('5'); //10 Number

// Coerced to a number
x = 5 * '5'; //25 Number

// null is coerced to 0 as it is a `falsy` value
x = 5 + null; // 5 Number

x = Number(null); //0 Number

x = Number(true); //1 Number
x = Number(false); //0 Number

// true is coerced to a 1
x = 5 + true; //6 

// false is coerced to 0 (falsy)
x = 5 + false; //5

// Undefined is coerced to 0 (falsy)
x = 5 + undefined; //NaN Number

console.log(x, typeof x);



// ***Working With Strings***

let x;

const name = 'John';
const age = 30;

// Concatenation

x = 'Hello, my name is ' + name + ' and I am ' + age + ' years old';


// Template Literals

x = `Hello, my name is ${name} and I am ${age} years old`;


// String Properties and Methods

// Creating a "string object" (JS does this automatically when using a propery or method on a primitive string)

const s = 'Hello World' //string 

// x = s.length 
//dont add () as it is built in js property...methods use () methods are functions...properties are more like attributes  


// strings are literal but can add properties and methods as a wrapper 

const s = 'Hello World' //string 

const s = new String('Hello World'); //object


x = typeof s;


x = s.length;

// Access value by key
x = s[0];


const s = new String('Hello World'); 

// Shows the prototype of the string object. Shows the properties and methods
// .__proto__; // shows prototype where methods are stored

x = s.__proto__;
// console.log(s);

// Change case
x = s.toUpperCase();
x = s.toLowerCase();


// charAt() - returns the character at the specified index
x = s.charAt(0);

// indexOf - returns the index of the first occurrence of a specified value in a string
x = s.indexOf('d');

// substring() - search a string for a specified value
x = s.substring(2, 5); // (start, end) 
x = s.substring(7); //starts at 7 and gets rest of the remaining string 

// slice() - extracts a part of a string and returns a new string
x = s.slice(-11, -6); //can also start at end 

// trim() - remove whitespace from beginning and end of string
x = '         Hello World';
x = x.trim();

// replace() - replace all instances of a string
x = s.replace('World', 'Osman');

// includes() - returns true if the string is found
x = s.includes('Hello'); //true 
x = s.includes('yellow'); //false 

// valueOf() - returns the primitive value of a variable
x = s.valueOf();

// split() - returns an array of strings
x = s.split(' '); // ['Hello', 'World']
x = s.split(''); //  ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']

console.log(x);


// ***Capitalize Challenge***

const myString = 'developer';

let myNewString;

// Solution 1:
myNewString = myString.charAt(0).toUpperCase() + myString.substring(1)

// Solution 2:
myNewString = myString[0].toUpperCase() + myString.substring(1)

// Solution 3:
myNewString =  `${myString[0].toUpperCase()}${myString.substring(1)}`

// Solution 4:
myNewString =  `${myString[0].toUpperCase()}${myString.slice(1)}`

console.log(myNewString);


// ***Working With Numbers***

const num = 5; 
console.log(typeof num) //number


// we can also have number object usine the number constructor

const num = new Number(5); 
console.log(typeof num) //object


let x

const num = new Number(5); 

x = num.toString() // 5 as a string

// no length property for numbers e.g. 

x = num.length //undefined 

// just add toString() to get length
x = num.toString().length  // 1

// number of decimals (rounds up down)  
x = num.toFixed(2)
// console.log(typeof x) //string

x = num.toPrecision(2) //total digits e.g. 5.5 (rounds up and down)

x = num.toExponential(2); //e.g. 5.00e+0

x = num.toLocaleString('en-UK')

// console.log(num) //prototype list 

x= num.valueOf() //5

x = Number.MAX_VALUE
x = Number.MIN_VALUE

console.log(x)


// ***Math Object***


console.log(Math)

let x;

// // Square root
x = Math.sqrt(9);

// // Absolute value
x = Math.abs(-5);

// // Round
x = Math.round(4.2);

// // Round up
x = Math.ceil(4.2);

// // Round down
x = Math.floor(4.9);

// // Exponent
x = Math.pow(2, 3);

// // Minimum number
x = Math.min(4, 5, 3);

// // Maximum number
x = Math.max(4, 5, 3);

// // Get a random number/decimal between 0 and 1
x = Math.random();

// // Get a random number/decimal between 1 and 10
x = Math.random() * 10 + 1;

// // Get a random number between 1 and 100
x = Math.floor(Math.random() * 100 + 1);

console.log(x);

// ***Number Challenge***

var x = Math.floor(Math.random() * 100 + 1)
var y = Math.floor(Math.random() * 50 + 1)

// Get the sum
var sum = x + y;
var sumAnswer = `${x} + ${y} = ${sum}`
console.log(sumAnswer)

// Get the minus
var minus = x - y;
var minusAnswer = `${x} - ${y} = ${minus}`
console.log(minusAnswer)

// Get the multiply
var multiply = x * y;
var multiplyAns = `${x} * ${y} = ${multiply}`
console.log(multiplyAns)

// Get the divide
var divide = x / y; 
var divideAns = `${x} / ${y} = ${divide}`
console.log(divideAns)

// Get the modulus remainder

var modulus = x % y;
var modulusAns = `${x} % ${y} = ${modulus}`
console.log(modulusAns)



// ***Dates & Times***

var d;

// Get today's date and time
d = new Date()

// // Set to a string
d = d.toString(); // convert to string

// Get a specific date
d = new Date(2021, 1, 10, 12, 45, 10) 
// date 2021, 1, 10 // Wed Feb 10 2021 
// Important: the month is 0-based, so 0 is January and 11 is December
// time 12, 45, 10 // 12:45:10

// Pass in a string
d = new Date ('2021-07-10T12:30:00')
d = new Date ('07/10/2021 12:45:00')
// issue if use year first and hyphen can be a day off due to time zone 
d = new Date('2022-07-12')
d = new Date('07-10-2022')

// https://stackoverflow.com/questions/7556591/is-the-javascript-date-object-always-one-day-off

// Get current timestamp

//  integer that represents number of seconds that's elapsed passed since the date Jan 1st 1970 an arbitary date the timestamp is expressed in javascript in milliseconds

// Get current timestamp
d = Date.now()

// Get the timestamp of a specific date

d = new Date ('07-10-2022 12:30:45')
// d = new Date () // right now date output keeps changes as time moves
d = d.getTime()

d = d.valueOf()

 // Create a date from a timestamp
 d = new Date(1681296017413) 


 // Convert from milliseconds to seconds
 d = Math.floor(Date.now() / 1000)

console.log(d)
console.log(typeof d) // object


// ***Date Object Methods***

let x;

let d = new Date()
// let d = new Date('2020/10/12')
// let d = new Date('1/2/2020')


x = d.toDateString()

// Get the timestamp 
// right now date output keeps changes as time moves
x = d.getTime() 
x = d.valueOf() // timestamp getTime()

x= d.getFullYear()

x = d.getMonth() + 1 //zero-0 based

x = d.getDate()

x = d.getDay()

x = d.getHours()

x = d.getMinutes()

x = d.getSeconds()

x = d.getMilliseconds()


x = `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`


// API Intl.DateTimeFormat in locale sensitive way:

x = Intl.DateTimeFormat('en-US').format(d)
x = Intl.DateTimeFormat('en-GB').format(d)
x = Intl.DateTimeFormat('default').format(d)

x = Intl.DateTimeFormat('default', {month: 'long'}).format(d)


x = d.toLocaleString('default', {month: 'short'})

x = d.toLocaleString('default', {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric',
  timeZone: 'America/New_York',
});

console.log(x)


// ***Array Basics***

let x;

// Array Literal
const numbers = [12, 45, 33, 29, 39, 102]
const mixed = [12, 'Hello', true, null]
// console.log(numbers)

// Array Constructor
const fruits = new Array('apple', 'grape', 'orange')
//must be uppercase A for Array 
//console.log(fruits)

// Get value by index
x = numbers[0]

x = numbers[0] + numbers[3]

x = `My favorite fruit is an ${fruits[2]}`


x = numbers.length 

fruits[2] = 'pear'

// length is not read-only
// fruits.length = 2;

fruits[3] = 'strawberry'

// Using the length as the index will always add on the the end
// length always +1 to the last index 
fruits[fruits.length] = 'blueberry'
fruits[fruits.length] = 'peach'

x = fruits

console.log(x)

// ***Array Methods***


let x;

const arr = [34, 55, 95, 20, 15]
// console.log(arr)

// push() - Push a value on to the end of the array
arr.push(100)

// pop() - Take the last value off
arr.pop()

// unshift() - Add a value to the beginning of the array
arr.unshift(99)

// shift() - Remove first value
arr.shift()

// reverse() - Reverse an array
arr.reverse()
console.log(arr)

// includes() - Check to see if something is in the array //true or false value

x = arr.includes(20) //true
x = arr.includes(200) //false

// indexOf() - Return the index of the first match
x = arr.indexOf(15) //4
x = arr.indexOf(34) //0
x = arr.indexOf(340) //-1
//-1 shows negative -1 when not in array

// Return array as a string
x = arr.toString();
x = arr.join();

// slice() returns selected elements in an array, as a new array. Slice takes in the index of the first element and the index of the last element to be included in the new array.

x = arr.slice(1) //[55, 95, 20, 15]
x = arr.slice(1, 4) //[55, 95, 20]
// console.log(x, arr)

// splice() works like slice() except it takes the index of the first element and the number of elements after that as a second argument. it also mutates the original array where slice() does not

// [34, 55, 95, 20, 15]

x = arr.splice(1, 4); //[34]

// Remove a single element/value - The following will mutate the original array by taking out the element with the index of 4. x will be equal to a new array with that plucked out value.
// x = arr.splice(4, 1)

// [34, 55, 95, 20, 15]

x = arr.splice(3, 1)

// [20] //x
// [34, 55, 95, 15] //arr
console.log(x, arr);

// Chaining methods - Some methods can be chained depending on the return value.

x = arr.slice(1, 4) //[55, 95, 20]

x = arr.splice(1, 4) //[55, 95, 20, 15]

x = arr.splice(1, 4).reverse().toString() 
// 15,20,95,55

x = arr.splice(1, 4).reverse().toString().charAt(0) //1

console.log(x);



// ***Array Nesting Concat & Spread***

let x; 

const fruits = ['apple', 'pear', 'orange']
const berries = ['strawberry', 'blueberry', 'rasberry']

// Nesting arrays
// Nesting berries inside of fruits
fruits.push(berries)
console.log(fruits)

// Now we can access 'blueberry' with the following
x = fruits[3][1]

// Create a new variable and nest both arrays
const allFruits = [fruits, berries];

x = allFruits[1][2]
x = allFruits[1][0]

// concat() - Concatenate arrays
x = fruits.concat(berries)

// Spread Operator (...) Concatenate with
x = [...fruits, ...berries]

// flat() - Flatten an array
const arr = [1, 2, [3, 4], 5, [6, 7], 8];
x = arr.flat();

// static Methods on Array Objects
// isArray() - Check is is an array
x = Array.isArray(fruits) //true
x = Array.isArray('Hello') //false

// from() - Create an array from an array like value
x = Array.from('12345')

// of() - Create an array from a set of values
const a = 1;
const b = 2;
const c = 3;

x = Array.of(a, b, c)

console.log(x)



// ***Array Challenge***

// Challenge 1

const arr = [1, 2, 3, 4, 5];

// arr.reverse();
// arr.push(0);
// arr.unshift(6);

// Same result as above
arr.push(6);
arr.unshift(0);
arr.reverse();

console.log(arr);

// Challenge 2

const arr1 = [1, 2, 3, 4, 5];
const arr2 = [5, 6, 7, 8, 9, 10];

// Solution 1
const arr3 = arr1.slice(0, 4).concat(arr2);

// Solution 2
const arr4 = [...arr1, ...arr2];
arr4.splice(4, 1);

console.log(arr4);


// ***Object Literals***

let x;

// Creating an object
const person = {
  name: 'John Doe',
  age: 30,
  isAdmin: true,

  address:{street:'123 Main Street', city:'London', county: 'Hampshire',
  },

  hobbies: ['music', 'sports']
};

// console.log(person)
  
// Accessing object properties
x = person.name; // Dot notation
x = person['age'] // Bracket notation
x = person.hobbies;
x = person.hobbies[0]; // music


// Updating properties
person.name = 'Jane Doe'
person['isAdmin'] = false

// Deleting properties
delete person.age;  

// Create new properties
person.hasChildren = true;

// Add functions
person.greet = function(){
console.log(`Hello my name is ${this.name}`)
}

person.greet();

// Keys with multiple words
const person2 = {
'first name': 'Brad',
'last name': 'Travesy' 
};

x = person2['first name']

console.log(x)

// ***Object Spread Operator & Methods***

let x;

// Create object using the object constructor
// const todo = {}; //written option 1
const todo = new Object(); //written option 2

todo.id = 1;
todo.name = 'Buy Milk';
todo.completed = false;

x = todo;


// Object Nesting
const person = {
  address: {
    coords: {
      lat: 42.938,
      lng: -71.3232,
    },
  },
};

x = person.address.coords.lat;

const obj1 = {a: 1, b: 2};
const obj2 = {c: 3, d: 4};

// Spread operator
const obj3 = {...obj1, ...obj2}

// Same as using ...
const obj4 = Object.assign({}, obj1, obj2);


// x = obj3
x = obj4

// Array of objects
const todos = [
{id: 1, name: 'Buy Milk'},
{id: 2, name: 'Pickup kids from school'},
{id: 3, name: 'Take out trash'},
];

x = todos[0].name; 

// Get array of object keys
x = Object.keys(todo); 

// Get length of an object
x = Object.keys(todo).length; 

// Get array of object values
x = Object.values(todo)

// Get array of object key/value pairs
x = Object.entries(todo)

// Check if object has a property
x = todo.hasOwnProperty('name') //true
x = todo.hasOwnProperty('age') //false

console.log(x);




// ***Destructuring & Naming***


const firstName = 'Osman'
const lastName = 'Ijaz'
const age = 30

// const person = {
// firstName: firstName,
// lastName: lastName,
// age: age,

// }

// // Setting object properties with the same name as a variable
const person = {
  firstName,
  lastName,
  age,
  
  }

console.log(person.age)


// Destructuring object properties

const todo = {
id:1,
title: 'Take out trash',

user:{
name: 'Sophie'
}
};

// const id = todo.id;

const {
  id: todoID,  //re-naming
  title, 
  user: {name} // destructuring
} = todo;

// console.log(user)
// console.log(name) // user: {name} 
console.log(todoID) 



// Destructuring arrays & using the rest/spread operator
const numbers = [23, 67, 33, 49, 52]

const [first, second, ...rest] = numbers;
console.log(first, second, rest);


// ...rest
// ...anyName
// const [first, second, ...anyName] = numbers;
// console.log(first, second, anyName);
  

// ***JSON Intro***


const post = {
  id: 1,
  title: 'Post One',
  body: 'This is the body',
};

// console.log(post)

// Convert to JSON string

const str = JSON.stringify(post)
// console.log(str)

// Parse JSON

const obj = JSON.parse(str)
// console.log(obj)

// console.log(obj.id) //need to parse first

// JSON & arrays

const posts = [
  {
    id: 1,
    title: 'Post One',
    body: 'This is the body',
  },
  {
    id: 2,
    title: 'Post Two',
    body: 'This is the body',
  },
]

const str2 = JSON.stringify(posts)
console.log(str2)



// ***Object Challenge***

// Step 1
const library = [
{
  title: 'The Road Ahead',
  author: 'Bill Gates',
  status: {
    own: true,
    reading: false, 
    read: false,
  }
},
{
  title: 'Steve Jobs',
  author: 'Walter Isaacson',
  status: {
    own: true,
    reading: false, 
    read: false,
  }
},
{
  title: 'Mocking Jay',
  author: 'Suzanne Collins',
  status: {
    own: true,
    reading: false, 
    read: false,
  }
},
]; 

// Step 2

library[0].status.read = true 
library[1].status.read = true 
library[2].status.read = true 


// console.log(library)

// Step 3

const {title: firstBook} = library[0] 
// console.log(firstBook)

// Step 4

const libraryJSON = JSON.stringify(library)   
console.log(libraryJSON)


// ***Function Basics***

// Define a function
function sayHello(){
console.log('Hello World')
}

// Invoke, execute or call a function
sayHello() 


// Define a function with parameters
function add(num1, num2){ //parameters
console.log(num1 + num2)  //defining declaring a function

}

// Invoke function with arguments
add(5, 10) //arguments


// Parameters vs. Arguments
// Parameters are the names of the variables that are used to pass data into a function.
// Arguments are the values that are passed into the function


// Returning a value
function subtract(num1, num2){

return num1 - num2;

console.log('...after the return!') //no output here as it was after the return

}

// Assign the returned value to a variable
const result = subtract(10, 2) 

// console.log(result) //8
console.log(result, subtract(20, 5)) //15


// ***More on Params & Arguments***


// Default Params

// ---option 1---

function registerUser(user){

return user + ' is registered';
}

console.log(registerUser('Osman')) 
//Osman is registered


// ---option 2--- 

// Old way - before using = `` 

function registerUser(user){

if(!user){ //if not assigned to a user then user ='Bot'
user ='Bot' //therefore...Bot is registered
}

return user + ' is registered';
}
console.log(registerUser()) 
// Bot is registered


// ---option 3---

function registerUser(user = 'Sumra'){

return user + ' is registered'; //Sumra is registered
}

console.log(registerUser()) 




// Rest Params

// ---example 1---

function sum(...numbers){

return numbers
}

console.log(sum(1,2,3)) // gives an array [1, 2, 3]

// ---example 2---

function sum(...numbers){

let total = 0;

for (const num of numbers){

  total += num;
}
return total; 
}

console.log(sum(1,2,3,4,5,6,100)) //121


// Objects as params
function loginUser(user){

return `The user ${user.name} with the id of ${user.id} is logged in`

}

const user = {
id: 1,
name: 'John',
};

// ---option 1--- 
// when using return use console.log() for output
console.log(loginUser(user));
// The user John with the id of 1 is logged in

// ---option 2--- 
console.log(
loginUser({
id: 2,
name: 'Carla',
})
);
// The user Carla with the id of 2 is logged in


// Arrays as params

// ---option 1--- 

function getRandom(arr){

const randomIndex = Math.floor(Math.random() * arr.length)

const item = arr[randomIndex]
console.log(item)
}

// random number generator
getRandom([1,2,3,4,5,6,7,8,9,10]) //with brackets


// ---option 2--- 
// with 3 dots ... using without array brackets 

function getRandom(...arr){ //...

const randomIndex = Math.floor(Math.random() * arr.length)

const item = arr[randomIndex]
console.log(item)
}

// random number generator
getRandom(1,2,3,4,5,6,7,8,9,10) //without brackets



// ***Global & Function Scope***

// 'window' is globally scoped

// window.alert('Hello');
// alert('Hello');

// console.log(window.innerWidth);
// console.log(innerWidth);


// Global scope variable
const x = 100 //global access inside any function
console.log(x, '...global')


function run(){
// Access global vars in functions
console.log(window.innerHeight)

console.log(x, '...function')
}

run()

// Access global vars in blocks
if(true){

console.log(x, '...block')

}


function add(){
  // Overwriting global x (variable shadowing)
  const x = 1; //overides globally scoped x value from above of const x = 100 this is called variable shadowing
  const y = 50; //function scoped defined inside function
  
  console.log(x + y) //150 

}


// Can not access a function scoped variable in global scope e.g.

// console.log(y) //error

//will not work here as looking it is in the global scope therefore it will not go into  function add() and search or pull out local variables it will also not allow access to search e.g. const y = 50; 

add()


// ***Block Scope***

// var is not block level scope 


const x = 100; //global can access from anywhere

// An If statement is a block
if(true){
// conditional is a block 

// console.log(x) //global can access from anywhere

const y = 200;
console.log(x + y); //will work here

}

// console.log(y); // ReferenceError: y is not defined

// console.log(x + y); will NOT work here as y has not been defined in the globla scope only defined in the block

// A loop is a block
for (let i = 0; i <= 10; i++){
console.log(i)
}

// console.log(i) // ReferenceError: i is not defined globally
 
// Using var
if(true) {
  const a = 500;
  let b = 600;
  var c = 700;

}

// console.log(a) // ReferenceError: a is not defined

// console.log(b) // ReferenceError: b is not defined

// var is not block scope. It is accessable outside the block. This is not good because you want your variables to be blocked scope that's how best practices in programming languages work.
// console.log(c) //700

// swapping the let for var in loop
for (var i = 0; i <= 10; i++){
  console.log(i)
  }
  
  console.log(i) // globally now works and gives answer of 11 however this is not good for your block code and can create errors in output so best to avoid using it


// var IS function scoped
function run(){
var d = 100;
console.log(d)
}

run() //globally and will run work 

// console.log(d) // ReferenceError: d is not defined. This is because var is function scoped. You can not access a var variable that is inside of a function outside of that function but you can with other blocks like loops and if statements.
  

// var defined globally get's added to the window object
var bar = 2; // Puts on the window object
//type window in console to get window object to see bar:2; You idelly do not want your variables to be on the window object.

const foo = 1; // const does not get added to the window object


// ***Nested Scope*** (Nested Functions & Nested Blocks)


// Nested Functions (related to closures) 

function first(){
const x = 100; //parent

function second(){

const y = 200; //child can access parent scope
console.log(x + y);

}

// console.log(y) //ReferenceError: y is not defined becuase cannot access child variabes as they are two seperate scopes
  

second()

}

first()
// 300


// Nested Blocks 


if(true){
const x = 100;

if(x === 100){
  const y = 200;
  console.log(x + y) //access the parents scope variable
}

// console.log(y) // ReferenceError: y is not defined as it is a seperate scope but can access the parent within the child.

}


// ***Function Declaration vs Expression***

// Function Declaration

// console.log(addDollarSign(100)) //$100  
// When using declarations, you can invoke the function before the declaration. With expressions it will NOT work. 

//It works above because of hoisting a seperate step before your code is executed. This only works for Function Declaration which is available on top before the code is executed. It will not for Function Expression only for Function Declaration.

//* 
console.log(addDollarSign(100)) //$100 // invoking the function


// declaration
function addDollarSign(value){
  return '$' + value
}

// Moved to the top //*
// console.log(addDollarSign(100)) //$100

// Function Expression
// With expressions it will NOT work. You can not invoke the function before the declaration. Will only work by writing it below this way. 

const addPlusSign = function(value){

return '+' + value; 

}; //add semi colon for Function Expression

console.log(addPlusSign(200))


// ***Arrow Functions*** (2015 ES6 Update)


// normal function declaration
function add(a, b){
return a + b;
}

console.log(1 + 2) //3


// Arrow Function
// They are more compact, with implicit return and has lexical scope

// normal function declaration
// const add = function () {} 

// Arrow Function Syntax
const add = (a, b) => {
  return a + b;
};

console.log(1 + 2) //3


// Implicit Return 
const substract = (a, b) => a - b;
console.log(substract(10, 5)); //5

const double = (a) => a * 2;
console.log(double(10)) //20

// Can leave off () with a single param
const double = a => a * 2; //can remove brackets if have a single parameter e.g. a will not work if have more than one parameter
console.log(double(2)) //4


// Returning an object
const createObj = () => ({
name: 'Brad',
})
console.log(createObj())


const numbers = [1,2,3,4,5]

numbers.forEach(function (n) {

console.log(n)

});


// Arrow function in a callback

const numbers = [1,2,3,4,5]

numbers.forEach((n) => console.log(n))


// ***IIFE (Immediately Invoked Function Expressions)***


// With functions we usually define, declare them and then invoke them when we need to run them.

// IFFE Syntax (Has it's own scope and runs right away)

// There is a way to create, declare a function and invoke it at the same time using an Immediately Invoked Function Expressions IFFE. This is to avoid Global scope polution.

// e.g. In another file otherScript.js
// const user = 'Brad';
// console.log(user); //Brad

// My seperate file script.js 
// const user = 'John' // Identifier 'user' has already been declared. 
// This is because user was already declared in the global scope of otherScript.js and now you are trying to declare it again aswell in my personal seperate file script.js 

// To avoid Global scope polution.
// IFFE Syntax (Has it's own scope and runs right away)


// IFFE Syntax (now not in global scope in the scope of the IFFE)
(function () { 

const user = 'John'
console.log(user)

// can create a function within the block 
const hello = () => console.log('Hello from the IFFE')

hello(); //Hello from the IFFE

})(); //() to invoke the block 

// hello() //ReferenceError: hello is not defined because hello() is scoped inside of the IFFE 

// Adding Parameters

// IFFE Syntax
//  ()()
//  (function (){})()

(function (name){

console.log('Hello ' + name);

})('Osman');


// Named IIFE (Can only be called recursively, recursion is when a function calls itself until someone stops it. If no one stops it then it'll recurse (call itself) forever.)
(function yellow(){
console.log('Yellow')

// yellow() //It will create an infinite loop.

})()

// yellow(); ReferenceError: yellow is not defined because you can NOT call yellow() function outside of the IFFE scope. You can call it inside the IFFE scope this will be called a recursion.


// ***Function Challenges***

// Challenge 1

// formulas and information on code is available from https://stackoverflow.com/ or GitHub Copilot Extension.


function getCelsius(f){ //argument 
const celsius = ((f - 32) * 5) / 9;

return celsius;

}

console.log(getCelsius(32)) //0
console.log(getCelsius(40)) //4.444
console.log(getCelsius(50)) //10

// Arrow Function

const getCelsius = (f) => ((f - 32) * 5) / 9
console.log(getCelsius(65)) //18.333

console.log(`The temp is ${getCelsius(50)}\xB0C`) // celsius symbol \xB0C e.g. 10°C 


// Challenge 2

function minMax(arr) {

  // const min = Math.min(); 
  // Math.min() does not take in an array takes in just a bunch of numbers Math.min(1,2,3). If we want to take just the values in the array use the spread operator
  const min = Math.min(...arr); //spread operator to get just the values of that array
  console.log(min)

  const max = Math.max(...arr);
  console.log(max)

}

minMax([1,2,3,4,5]) //1 Math.min()
minMax([1,2,3,4,5]) //5 Math.max()

function minMax(arr) {
  const min = Math.min(...arr); 
  console.log(min)

  const max = Math.max(...arr);
  console.log(max)

  // create object
  
  return {
    min, // min:min,
    max, // max:max,  
  };
}

console.log(minMax([1,2,3,4,5]))
// {min: 1, max: 5}


// Challenge 3

//  IFFE 

((length, width)=>{
const area = length * width; 

// tempalate literal ` `
const output = `The area of a rectangle with a length of ${length} and a width of ${width} is ${area}.`
  
console.log(output)
})(10, 5);



// ***Execution Context***


// The execution context is a special environment that is created by the Javascript engine in the browser. If using NodeJS it will be the V8 engine. It contains the currently running code and everything that aids its execution.

// There is a global execution as well as a function execution context for every function invoked for the span of that function.

// Execution Context e.g. 2 Sides:

// Side 1
// Memory (variable environment)
// This is the variable environment that stores all of your variable and functions as key:value pairs in memory

// name:'John'
// x:100
// y:200
// fn:{...}

// Side 2
// Execution (Code) (thread of execution)
// This is the thread of execution. Each line of code is executed line by line.

// Javascript is a single threaded language. A thread like a process and your code is executed line by line on that thread or on that process.

// JavaScript language is synchronous. Synchronous means the code runs in a particular sequence of instructions given in the program. Each instruction waits for the previous instruction to complete its execution.

// When Execution Context created there are 2 Phases:

// Side 1
// Memory Creation Phase
// One swoop through before your code is actually run (memory creation phase does not execute your code) it:

// 1. creates the global object (either in the browser = window, or node.js = global)

//2. creates the 'this' object and binds it to the global object

//3. setup memory heap for storing variables and function references 

//4. it stores functions and variables in global execution context but will set to 'undefined' e.g.

// variables set to undefined. Do not get filled with values until actually executed in the execution phase.  
// name:'John'
// x:100
// y:200
// fn:{...}

// Side 2
// Execution Phase

// 1. executes code line by line

// 2. if it hits a function invocation will create a new execution context for each function call.




// ***Execution Context In Action***

// Let's take the following code and see exactly what happens when it runs:

//line 1: var x = 100;
//line 2: var y = 50; 
//line 3: function getSum(n1, n2){
//line 4: var sum = n1 + n2;
//line 5: return sum;
//line 6: }
//line 7: var sum1 = getSum(x, y);
//line 8: var sum2 = getSum(10, 5);



// **** 1. Global execution context is created

// Global object is created and assigned to `this`



// **** 2. Memory creation phase (global execution context) sometimes just called the **creation phase** allocates the memory for all of the variables and functions. Goes over all the code and puts the variables and functions into memory. This happens before any code is executed.

// - *Line 1:** `x` variable is allocated memory and stores `undefined`
// - *Line 2:** `y` variable is allocated memory and stores `undefined`
// - *Line 3:** `getSum()` (function allocated to memory but are NOT stored as undefined)...
//               (However, functions are directly stored in memory with all of the code inside of them, it does not get executed)
//               functions are allocated memory and stores all the code in the function put in memory for now...
// - *Line 7:** `sum1` variable is allocated memory and stores `undefined`
// - *Line 8:** `sum2` variable is allocated memory and stores `undefined`



// **** 3. Execution phase (global execution context). Where the code is executed line by line. This happens after the memory creation phase.

// - *Line 1:** places the `100` into the `x` variable
// - *Line 2:** places the `50` into the `y` variable
// - *Line 3:** skips the function because there is nothing to execute. It is a declaration
// - *Line 7:** Invokes the `getSum()` function and creates a NEW **function execution context**                
//              with a 2 phase new nested memory creation phase **variable environment** and **execution thread**.    
//              It will also run the **memory phase* and the **execution phase**.


// **** 4. Memory creation phase (function execution context)

// - *Line 3:** parameters of the function assign `n1` & `n2` variable and allocated to memory and stores `undefined`
// - *Line 4:** `sum` variable is allocated memory and stores `undefined`


// **** 5. Execution phase (function execution context)

// - *Line 3:** `n1` & `n2` are assigned `100` and `50` as passing x = 100 and y = 50
// - *Line 4:** The calculation is done and the result (150) is put into `sum` variable
// - *Line 5:** return tells the ****function execution context**** to return to the   
//               ****global execution context**** with this value of `sum` (150) (line7 sum1)
// - *Line 7:** The returned sum value is put into the `sum1` variable in the **global execution context**. 
//              The execution context of that function is then **deleted**.
// - *Line 8:** We repeat the same process and create a new **function execution context**, 
//              just with different parameters being passed in.

// In JavaScript functions are "first-class citizens", which means that they can be treated like any other value, such as a number or a string (you can assign a function to a variable, you can console.log() a function, etc.).

// Think of scopes as "new worlds". Every new world has to be first created (creation phase) and then executed.

// In case of the functions, in the creation phase, JavaScript only allocates memory for the function, the same that it only allocates memory for x and y.

// When the function is invoked, to enter a "new word", the world must be created first. So you have the creation phase (when it allocates memory to n1, n2 and sum) and the execution phase (when are assigned values to n1 and n2, calculation is done and put into the sum variable).



// ***Execution Context within the Browser***

//  Go to 'sources' tab and add a breakpoint at the first line and step through to see the execution phase in action


// ***Call Stack***

// As mentioned there is an `execution context` with a ***global execution*** context and a ***function execution*** context. 

// Well every function that was invoked it opens up a new `execution context` it also gets added to something called the `call stack`. Also referred to as the `execution stack` (Call Stack).

// This keeps track of the functions that are currently being executed. A manager for your functions or a manager for your executuion context. You think of it as an execution context manager.

// A `stack` is a data structure in Javascript. It's a **LIFO (last in, first out)** data structure. The last thing to come ON is the first thing to come OFF. 

// The bottom of the stack you always have the ***Global Execution Context*** 

// First Example

function first() {
console.log('first...');
}

function second() {
console.log('second...');
}

function third() {
console.log('third...');
}

first();
second();
third();

// Here we have three functions that are all being run in the global scope. When I say global scope I just mean not in a function. So this is how the call stack would work in this case.

// First of all, the global execution context is always at the very bottom of the call stack. Then the function named first will get put on to the stack because that is the first function run in our code. The technical terminology is `PUSH` when something is placed on the stack and `POP` when something is taken off. So first() will be PUSHED ON and executed and POPPED OFF. Next, second() will be PUSHED ON and executed, then POPPED OFF and finally, third(). Since they're all in the global scope, they don't ever get stacked on top of each other. It's just one after the other.

// Now let's look at a different example.

// Second Example

function first() {
  console.log('first...');
  second();
}

function second() {
  console.log('second...');
  third();
}

function third() {
  console.log('third...');
}

first();


// Here, the only function being invoked in the global scope is first(). Then in the first() function, the second() is being invoked, now we are still in the process of executing first(), so that stays on the stack and second() is pushed on top of it. Then in second(), were executing third(), so first() and second() are still on the stack and third() gets added as well. Once the final console log is done, third() is done and taken off in `last in first out` fashion, then second() is done that gets popped off then first(). Then it's done and the `global execution context` is deleted.


// ***If Statements***

// If Statement Syntax
if (true) {
console.log('This is true');
}

if (false) {
console.log('This is NOT true');
}

// Evaluation expressions
const x = 10;
const y = 5;

if (x >= y) {
console.log(`${x} is greater than or equal to ${y}`);
}

if (x === y) {
console.log(`${x} is equal to ${y}`);
} else {
console.log(`${x} is NOT equal to ${y}`);
}

// Block scope
if (x !== y) {
const z = 20;
console.log(`${z} is 20`);
}

// console.log(z); // Throw error 

// Shorthand If/Else (...not recommended)
if (x >= y) console.log(`${x} is greater than or equal to ${y}`),
console.log('This is true');
else console.log('This is false');


// ***Else-If & Nesting***

// const d = new Date(); //current hour
const d = new Date(10, 30, 2022, 21, 0, 0);
const hour = d.getHours();

console.log(hour)


if (hour < 12) {
  console.log('Good Morning');
} else if (hour < 18) {
  console.log('Good Afternoon');
} else {
  console.log('Good Night');
}

// Nested If
if (hour < 12) {
  console.log('Good Morning');

  if (hour === 6) { //nested If
    console.log('Wake Up!');
  }

} else if (hour < 18) {
  console.log('Good Afternoon');

} else {
  console.log('Good Night');

  if (hour >= 20) { //nested If
    console.log('zzzzzzzz');
  }
}

if (hour >= 7 && hour < 15) {
  console.log('It is work time!');
}

if (hour === 6 || hour === 20) {
  console.log('Brush your teeth!');
}


// ***Switches***

const d = new Date(2022, 1, 10, 18, 0, 0);
const month = d.getMonth();
const hour = d.getHours();

// console.log(month) //1 January

// Immediate value evaluation
switch (month) {
  case 1:
    console.log('It is January');
    break;
  case 2:
    console.log('It is February');
    break;
  case 3:
    console.log('It is March');
    break;
  default:
    console.log('It is not Jan, Feb or March');
}

// Range evaluation
switch (true) {
  case hour < 12:
    console.log('Good Morning');
    break;
  case hour < 18:
    console.log('Good Afternoon');
    break;
  default:
    console.log('Good Night');
}

// ***Calculator Challenge***

function calculator(num1, num2, operator) {
  let result;

  switch (operator) {
    case '+':
      result = num1 + num2;
      break;
    case '-':
      result = num1 - num2;
      break;
    case '*':
      result = num1 * num2;
      break;
    case '/':
      result = num1 / num2;
      break;
    default:
      result = 'Invalid Operator';
  }

  console.log(result);
  return result;
}

calculator(5, 2, '&'); //Invalid Operator
calculator(5, 2, '+'); //7
calculator(5, 2, '-'); //3
calculator(5, 2, '*'); //10
calculator(5, 2, '/'); //2.5




// ***Truthy & Falsy Values***

const email = 'test@test.com'; 
//truthy value in a string 

if (email) { //coerced into a boolean 
  console.log('You passed in an email');
} else {
  console.log('Please enter email');
}

// We can test truthy and falsy values by converting them to a boolean using the `Boolean` function.

console.log(Boolean(email)) //true

//You passed in an email

// We can also use the **!!** (double bang) to convert to a boolean.

console.log(!!email); // true

// This will return true because when you put something in an if statement, it is coerced into a boolean. A string with something in it is what we call a **truthy** value.

// Falsy Values:
// - false (obviously)
// - 0 (also -0 and BigInt 0n)
// - "" or '' (Empty string)
// - null
// - undefined
// - NaN

// If we test any of these in an if statement, it will evaluate to `false`.

// const x = false 
// const x = 0 //false
// const x = '' //false (NO spaces in string)
// const x = null //false 
// const x = undefined //false 
// const x = NaN //false 

// Truthy Values:

// Everything that is not falsy will evaluate to `true`, however, Some of these may surprise you.

// - Everything else that is not falsy
// - true (obviously)
// - '0' (string with 0)
// - 'false' (string with false)
// - ' ' (space in a string)
// - [] (empty array)
// - {} (empty object)
// - function() {} (empty function)

// If we test any of these in an if statement, it will evaluate to `true`.

// const x = true 
// const x = '0' //true (zero in a string)  
// const x = ' ' //true (space in a string)  
// const x = 'false' //true (false in a string)  
// const x = [] //true (empty array)  
// const x = {} //true (empty object)  
// function() {} //true (empty function)

if (x) {
console.log('This is truthy')
} else {
  console.log('This is falsy')
}

console.log(Boolean(x))



// Truthy and Falsy Caveats


const children = 0; //false
// Please enter number of children

if(children){
console.log(`You have ${children} children`)
}else{
console.log('Please enter number of children')
}


// We want 0 to be a valid value for children. 

const children = 0; //true
// You have 0 children

// To get 0 can check to see if the variable is not `undefined` or `null`.
// children !== undefined

if(children !== undefined){
  console.log(`You have ${children} children`)
  }else{
  console.log('Please enter number of children')
  }
  
  // You probably want the value to be a number. So you could check if the value is NaN (Not a Number) with the `isNaN()` function.

  const children = 3;

  if (!isNaN(children)) {
    console.log(`You have ${children} children`);
  } else {
    console.log('Please enter the number of children you have');
  }



  // Checking For Empty Arrays and Objects

  const posts = ['Post One', 'Post Two']; //true List Post
  const posts = []; //true List Post (empty array)
  const posts = [1]; //true //1  
  
  // console.log(posts.length) 
  
  const posts = ['Post One']; //true List Post
  
  
  // As empty arrays and objects are truthy, we can not simply check for the variable that holds them. 
  // To check for an empty array e.g. (posts.length > 0)
  if(posts.length > 0){
  console.log('List Posts')
  }else{
  console.log('No Posts to List')
  }


  // Check for an empty objects

  const user = {
    name: 'Brad', //True List User
  }

  // const user = {} //True List User

  // We can't use length directly on an object console.log(user.length) //undefined

  if(user){
  console.log('List User')
  }else{
    console.log('No User')
  }

  // Check for an empty object. 

  if(Object.keys(user).length > 0){
    console.log('List User')
    }else{
      console.log('No User')
    }

    // Loose Equality Comparison

    // Use `===` unless there is a specific reason to use `==`.
  
   // `false`, zero and empty strings are equivalent (when using ==)
   console.log(false == 0) //true
   console.log('' == 0) //true
   console.log(null == undefined) //true
   
   console.log(false === 0) //false
   console.log('' === 0) //false
   console.log(null === undefined) //false


  //  ***Logical Operators***

  

console.log(10 < 20 && 30 > 15 && 40 > 30) //true

console.log(10 > 20 || 30 < 15) //false


// && Will return first falsy value or the last value

let a;

a = 10 && 20 //20
a = 10 && 30 //30
a = 10 && 0 && 30 //0
a = 10 && '' && 0 && 30 //''

console.log(a)

const posts = ['Post One', 'Post Two']
console.log(posts[0]) // Post One

// const posts = []
// posts.length > 0 && console.log(posts[0]) // It will show as an empty array and it is less than 0


// const posts = ['Post One']
// posts.length > 0 && console.log(posts[0]) 
//Post One

// || - Will return the first truthy value or the last value

let b;

b = 10 || 20; //10
b = 0 || 20; //20
b = 0 || null || '' //'' (empty string)
b = 0 || null || '' || undefined //undefined

console.log(b)

// ?? - Returns the right side operand when the left is null or undefined.

// The `??` operator will return the right side operand when its left side is either `null` or `undefined`. It is similar to `||` operator except, it doesn't look at all falsey values, only `null` and `undefined`.

let c;

c = 10 ?? 20 //10
c = null ?? 20 //20
c = undefined ?? 30 //30

// It is not falsy on the left. It doesn't look at all falsey values, only `null` and `undefined`. 
c = 0 ?? 30 //0
c = '' ?? 30 //'' (empty string)

console.log(c)



// ***Logical Assignment***


// Logical Assignment Operators

// ||= (OR Logical Assignment) 
// &&= (AND Logical Assignment)
// ??= (Nullish Coalescing Assignment)

// OR Logical Assignment

// || - Will return the first truthy value or the last value

// ||= assigns the right side value only if the left is a falsy value.

let a = false;

if(!a){
a = 10;
}

console.log(a) //10


a = a || 10;

console.log(a) //10

// ||= assigns the right side value only if the left is a falsy value.

// let b = false; //10
// let b = null; //10
// let b = 0; //10
// let b = 20; //20 (not a falsy value)

b ||= 10; 

console.log(b) 



// AND Logical Assignment

// && Will return first falsy value or the last value

// &&= assigns the right side value only if the left is a truthy value.


let c = 10; //true

if (c) { //true

c = 20;

}

console.log(c)


c = c && 20
console.log(c) //20

// &&= assigns the right side value only if the left is a truthy value.

c &&= 20
console.log(c) //20



// Nullish Coalescing Operator

// ?? - Returns the right side operand when the left is null or undefined.

// ??= assigns the right side value only if the left is null or undefined.


let d = null; //20
// let d = undefined; //20
// let d = false; //false

if (d === null || d === undefined) {

d = 20;

}

console.log(d)

d = d ?? 20

d ??= 20


// ***Ternary Operator***
// condition ? true : false;

const age = 18;

// Using an if statement

if(age >= 18){

  console.log('You can vote')
  
}else{

  console.log('You can NOT vote')
} 


// Using a ternary operator

// 3 parts 

// 1. condition (evaluate)
      // First to be evaluated as a boolean.
      // age >=18

// 2. ternary operator (expression we want if true) 
      // ? console.log('You can vote')
      
// 3. ternary operator (else expression we want if false) 
      // : console.log('You can NOT vote')

      age >=18 ? console.log('You can vote') : console.log('You can NOT vote')
      

// Assigning a conditional value to a variable using the ternary operator.

// const age = 18;

const canVote = age >= 18 ? true  : false
const canVote2 = age >= 18 ? 'You can vote!' : 'You can NOT vote';

console.log(canVote)
console.log(canVote2)


// Multiple statements


const auth = true;

let redirect;

if (auth) {

  alert('Welcome to the dashboard');
  redirect = '/dashboard';

}else {

  alert('Access Denied');
  redirect = '/login'

}

console.log(redirect)

// In most cases, you will just have a single expression in the true/false part of the ternary operator, however you can have Multiple statements by using a comma.

const auth = true;

const redirect = auth ? (alert('Welcome to the dashboard'), '/dashboard') : (alert('Access Denied'), '/login')

console.log(redirect)


// Multiple Ternary Operators

// We can also have multiple ternary operators and conditions. Much like an else-if.

const canDrink =
  age >= 21
    ? 'You can drink!'
    : age >= 18
    ? 'You can have 1 beer'
    : 'You can not drink';

console.log(canDrink);

// Using `&&` as a shorthand

// If your else(semi-colon) in a ternary is going to be null or you don't need an else, you can use the `&&` operator instead. Here is an example

const auth = true;

auth ? console.log('Welcome to the dashboard') : null;

// We could just do.

// Shorthand no need to put null in else 
// (using the && AND Operator)

const auth = true;

auth && console.log('Welcome to the dashboard')

// Using the `&&` operator as a shorthand is a popular thing to do in React templates. Many times, you will see something like:

// Which is saying if done loading, then load the JSX fragment.

{!loading && (
  <Fragment>Some UI</Fragment>
)}



// ***For Loop***


// for ([initialExpression]; [conditionExpression]; [incrementExpression])
// statement;

// INITITAL EXPRESSION - Initializes a variable/counter
// CONDITION EXPRESSION - Condition that the loop will continue to run as long as it is met or until the condition is false
// INCREMENT EXPRESSION - Expression that will be executed after each iteration of the loop. Usually increments the variable
// STATEMENT - Code that will be executed each time the loop is run. To execute a `block` of code, use the `{}` syntax


// For Loop

// const //Uncaught TypeError: Assignment to constant variable
// e.g. Initializing i to 0 however it is going to get changed in every iteration so can not have it as a const.

// let //will give an output within the block and is best to use as it is less likely to give an output error;

for (let i = 0; i <= 10; i++) {
  if (i === 7) {
    console.log('7 is my lucky number');
  } else {
    console.log('Number ' + i);
  }
}
// var //this console.log('Number ' + i) can be outside of the block;

// Nested Loops
for (let i = 1; i <= 10; i++) {
  console.log('Number ' + i);

  for (let j = 1; j <= 12; j++) {
    console.log(`${i} * ${j} = ${i * j}`);
  }
}

// Loop through an array
const names = ['Brad', 'Sam', 'Sara', 'John', 'Tim'];

for (let i = 0; i < names.length; i++) {
  if (names[i] === 'Brad') {
    console.log(names[i] + ' is the best');
  } else {
    console.log(names[i]);
  }
}


// ***Break & Continue***

 // Break

 for (let i = 0; i<=20; i++){
//  console.log(i) //0 to 20 
    if(i === 15){
     console.log('---Breaking---')  
     break;
  }
  console.log(i)
 }


// Continue

for(let i = 0; i <= 20; i++){

  if(i === 13){
    console.log('---skipping 13---')
    continue
  }
console.log(i)
}




// ***While & Do While Loop***
// Do While Loop - Always runs once.


// Syntax for a while loop

// while ([conditionExpression]) {
//   statement
// }

// In a `while` loop, the variable is initialized before the loop runs and it is initialized outside of the loop.

// Simple example and print Number 1-20

let i = 0;

while (i <= 20) {
console.log('Number ' + i);
i++;
}

// Use a `for` loop when you know the number of times you want to run the loop and use a `while` loop when the number of times the loop will run is unknown. Not a mandatory convention, but something that a lot of people do.


// Looping Over Arrays
// Can loop over arrays with `while` loops

const arr = [10, 20, 30, 40, 50];

while (i < arr.length) {

  console.log(arr[i])
  i++

}


// Nested While Loops

let i = 1;

while (i <= 5) {

console.log('Number ' + 'i=', i);

let j = 1

while (j <= 5) {
  console.log('j=',`${i} * ${j} = ${i * j}`);
  // console.log(i + ' * ' + j + ' = ' + i * j);
j++
} 
i++
}


// Do While Loop - Always runs once.

// The `do while` loop will always run at least once, even if the condition is false.

// So "when would I want to use a `do while` loop?" is when you **always** want to run the block of code at least once.

// The syntax for a `do while` loop is:

// do{
// statement
// } while ([conditionExpression]);

let i = 21;

do{
console.log('Number ' + i) //will run once even if - while(i <= 20) - is false // let i = 21 // Number 21

i++

} while(i <= 20) // 1 to 20 // false


// ***FizzBuzz Challenge***

// For Loop

for (let i = 1; i <= 100; i++) {
  if (i % 15 === 0) {
    console.log('FizzBuzz');
  } else if (i % 3 === 0) {
    console.log('Fizz');
  } else if (i % 5 === 0) {
    console.log('Buzz');
  } else {
    console.log(i);
  }
}

// While Loop

let j = 1;

while (j <= 100) {
  if (j % 15 === 0) {
    console.log('FizzBuzz');
  } else if (j % 3 === 0) {
    console.log('Fizz');
  } else if (j % 5 === 0) {
    console.log('Buzz');
  } else {
    console.log(j);
  }

  j++;
}


// ***For Of Loop***
// for of //using for of because going through an array

// For Loop (original way)

const items = ['book', 'table', 'chair', 'kite']
for (let i = 0; i < items.length; i++){
console.log(items[i]);
}


// The `for of` loop is used to loop through iterable objects, such as arrays and strings as well as maps and sets. They can replace `for` loops in many cases.


// For Of Syntax

for (variable of iterable) {
// do something
}

// Let's look at a simple example that loops over an array.

// Loop through arrays

// example 1
const items = ['book', 'table', 'chair', 'kite']

for (const item of items){
  console.log(item);
}

// example 2
const arr = [1, 2, 3, 4, 5];

for (const number of arr) {
  console.log(number);
}

// 1 2 3 4 5


// Array with Objects 
const users = [
  {name: 'Brad'}, 
  {name: 'Kate'}, 
  {name: 'Caroline'}
];

for(const user of users){
  console.log(user)
  console.log(user.name) //access property name
  }


  // This is cleaner than a `for` loop because we simply give the value for each iteration a name and then we can use that name to access the value, rather than creating a condition expression using the array length and then using `i` as the index.
  

// Loop over strings
// If you needed to loop over every letter in a string, you could.

const str = 'Hello World'

for (const letter of str){
console.log(letter)
}
//H E L L O W O R L D


// Loop over Maps
const map = new Map();
map.set('name', 'Sophie');
map.set('age', '30');

for (const [key, value] of map){
console.log(key, value)
}


// ***For In Loop***

// The `for in` loop is used to loop through the properties of an object and arrays.

// For In Syntax

for (let key in object) {
  // do something
}

// Let's look at the object below. It is a set of key/value pairs for colors.

// Loop through objects

const colorObj = {
  color1: 'red',
  color2: 'blue',
  color3: 'orange',
  color4: 'green',
};


for (const key in colorObj){
  console.log(key)
  
  // color1
  // color2
  // color3
  // color4

  // value 
  console.log(key, colorObj[key])
  // color1 red
  // color2 blue
  // color3 orange
  // color4 green
}


// Using For In With Arrays

// There are a few ways to loop through arrays. We could use a regular for or while loop as well as an array method called `forEach()`, but we can also use a `for in` loop.

const colorArr = ['red', 'green', 'blue', 'yellow'];

for (const color in colorArr){

  //keys
  console.log(color) 
  // 0
  // 1
  // 2
  // 3
}

for (const key in colorArr){
  // values
  console.log(colorArr[key])
  // red
  // green
  // blue
  // yellow
 }


//  ***ForEach***
//  High Order Array Methods use on arrays that take another function as an argument. These functions that we pass in are called `callback functions`. 

// The callback will run once for every element in the array. This gives us access to each element.

// If we create an array and then look at the `prototype chain`, we can see all of the available methods.


const socials = ['Twitter', 'Facebook', 'LinkedIn', 'Instagram'];

console.log(socials.__proto__); 
// .__proto__ //double underscore
//shows methods or properties on the array 

// The forEach method is simply a method to loop through an array. It does not return anything, we can just loop through and do whatever we want on each iteration. Let's log all of the social network names.

const socials = ['Twitter', 'Facebook', 'LinkedIn', 'Instagram'];

// console.log(socials.__proto__)

// syntax 1 forEach Function
socials.forEach(function(item){ //callback function 
  console.log(item)
}) 


// syntax 2 forEach Function (remove the word function anonymous arrow function)
socials.forEach((item)=>{
console.log(item)
})


// Browser Debugger 
// Sources use it to see each time the callback is run. Place a breakpoint on the same line as the forEach. Hit `esc` to bring up the console window so you can see the output. Then hit the step through arrow. You will see it execute and log each item one at a time.

// We don't need to set anything here to be returned, we are just logging each item. The function we pass in will run for every item in the array. The callback function takes in an argument which represents the current item. I called it `item`, but I could have called it anything. I could have called it `social`. It is common to use the singular version of the array name. Then I just logged `item`.

// syntax 3 forEach Function (can remove {} curly brackets if it is only a one line expression)

socials.forEach((item) => console.log(item));

// In addition to the item passed into the callback, we can also pass in and get access to the current index (starts at 0) and the entire array itself.

socials.forEach((item, index, array) => console.log(`${index} - ${item}`, array));

// 0 - Twitter
// 1 - Facebook
// 2 - LinkedIn
// 3 - Instagram


// Let's say we want to also console log something if we are on the last iteration of the loop, or the last element in the array.

socials.forEach((item, index, arr) => {
  if (index === arr.length - 1) {
    console.log('The End');
  }
});

// You can also use a separate named function as your callback rather than pass in an anonymous one.

function logSocials(social){
console.log(social)

}

socials.forEach(logSocials) // no parentheses logSocials() as it is a callback so write logSocials only.

// Of course, we can use `forEach` on an array of objects. In reality, most of your arrays will probably use objects as items.

const socialObjs = [
{name:'Twitter', url:'https://twitter.com'},
{name:'Facebook', url:'https://facebook.com'},
{name:'Linkedin', url:'https://linkedin.com'},
{name:'Instagram', url:'https://instagram.com'},
];

socialObjs.forEach((item) => console.log(item))
socialObjs.forEach((item) => console.log(item.url))


// ***Filter***
// filter() filters an array it returns a value a modified array. 
// returns new array based on a function that is true or false e.g. anything that is true would be put into that array.


const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const evenNumbers = numbers.filter(function(number){

  return number % 2 === 0; // [2, 4, 6, 8, 10]
})

console.log(evenNumbers)

// We get back an array of all the even numbers in the original array because the `filter()` method returns all the values that pass the truth test of `number % 2 === 0`.

// Short version

const evenNumbers = numbers.filter((number) => number % 2 === 0)

console.log(evenNumbers)

//Same thing with forEach
// We can get the same result with a longer block of code using a `forEach`

let evenNumbers = [];

numbers.forEach(number => {

  if(number % 2 === 0){

    evenNumbers.push(number) //{} using .push(number)
  }
})

console.log(evenNumbers)


// Let's use an array of companies to work with.

const companies = [
  { name: 'Company One', category: 'Finance', start: 1981, end: 2004 },
  { name: 'Company Two', category: 'Retail', start: 1992, end: 2008 },
  { name: 'Company Three', category: 'Auto', start: 1999, end: 2007 },
  { name: 'Company Four', category: 'Retail', start: 1989, end: 2010 },
  { name: 'Company Five', category: 'Technology', start: 2009, end: 2014 },
  { name: 'Company Six', category: 'Finance', start: 1987, end: 2010 },
  { name: 'Company Seven', category: 'Auto', start: 1986, end: 1996 },
  { name: 'Company Eight', category: 'Technology', start: 2011, end: 2016 },
  { name: 'Company Nine', category: 'Retail', start: 1981, end: 1989 },
];


// Get only the companies that are in the Retail category.

const retailCompanies = companies.filter((company) => company.category === 'Retail');

console.log(retailCompanies)

// Get companies that started in or after 1980 ended in or before 2005.

const earlyCompanies = companies.filter((company) => company.start >= 1980 && company.end <= 2005);

console.log(earlyCompanies)

 // Get companies that lasted 10 years or more

 const longCompanies = companies.filter((company) => company.end - company.start >= 10);
 
 console.log(longCompanies)


//  ***map() Method***

// Creates a new array from a provided given function checking every element in the array, the function that we pass in can return anything that we want to put into a new array.


const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];


// const doubledNumbers = numbers.map((number) => number * 2)

const doubledNumbers = numbers.map((number) => 'Number ' + number)

console.log(doubledNumbers) 


 // Same with forEach

 const doubledNumbers2 = [];

 numbers.forEach((number) => {
  doubledNumbers2.push(number * 2);
  });

  console.log(doubledNumbers2)


  const companies = [
  { name: 'Company One', category: 'Finance', start: 1981, end: 2004 },
  { name: 'Company Two', category: 'Retail', start: 1992, end: 2008 },
  { name: 'Company Three', category: 'Auto', start: 1999, end: 2007 },
  { name: 'Company Four', category: 'Retail', start: 1989, end: 2010 },
  { name: 'Company Five', category: 'Technology', start: 2009, end: 2014 },
  { name: 'Company Six', category: 'Finance', start: 1987, end: 2010 },
  { name: 'Company Seven', category: 'Auto', start: 1986, end: 1996 },
  { name: 'Company Eight', category: 'Technology', start: 2011, end: 2016 },
  { name: 'Company Nine', category: 'Retail', start: 1981, end: 1989 },
];


// Create an array of company names

const companyNames = companies.map((company) => company.name)

console.log(companyNames)


 // Create an array with just company and category

 const companyInfo = companies.map((company) => { //code block return an object

  return{
  name: company.name,
  category: company.category 
  }
 });

 console.log(companyInfo)

 // Create an array of objects with the name and the length of each company in years

 const companyYears = companies.map((company) => {

  return{
    name: company.name,
    length: company.end - company.start + ' years',
  }
 })

 console.log(companyYears)

 // Chain map methods

 const squareAndDouble = numbers
 .map((number)=> Math.sqrt(number)) //Math.sqrt(number) output is stored into map((sqrt)
 .map((sqrt) => sqrt * 2)

 console.log(squareAndDouble)


 // Long version code for Chain Map methods

 const squareAndDouble2 = numbers
 .map(function(number){
  return Math.sqrt(number)
 })
 .map(function(sqrt){
  return sqrt * 2;
 })
 .map(function (sqrtAgainTimes3) {
  return sqrtAgainTimes3 * 3;
 });

 console.log(squareAndDouble2)



// Chaining different methods

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const evenDouble = numbers
.filter((number) => number % 2 === 0)
.map((number) => number * 2);

console.log(evenDouble)

// ***Reduce***

// reduce()

// It takes an array and reduces it to a single value. A common use case is to get a total of all the values in an array. This would be useful in a shopping cart application.

// reduce() Syntax

reduce(
  // function (accumulator, currentValue, currentIndex) 
  function (previousValue, currentValue, currentIndex) {
    /* … */
  },
  [initialValue] //normally set to 0
);

// The callback function that is passed into the `reduce()` method takes three arguments:

// - `previousValue` or `accumulator` - The value returned from the last time the callback function was called. This is sometimes called the "accumulator".

// - `currentValue` - The value of the current element being processed in the array that we are on.

// - `currentIndex` - The index of the current element being processed in the array.

// You can also pass in an `initialValue` (normally set to 0) after the callback function. This is the value to use as the first argument to the first call of the callback function. If no initial value is supplied, the first element in the array will be used.


const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Add all numbers together

// previousValue or also called accumulator
const sum = numbers.reduce(function(accumulator, currentValue){

  return accumulator + currentValue

}, 0);

// 0 is the initialValue (normally set to 0) after the callback function. This is the value to use as the first argument to the first call of the callback function. If no initial value is supplied, the first element in the array will be used.

console.log(sum) //55

// To get 55 it started at 0 initialValue. It ran a function (function(accumulator, currentValue) for each element [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. It took the previous value stored in as accumulator e.g. if 2 it took 1 in accumulator then added + the currentValue e.g. 2. Then the function ran again and took the next element e.g. 3 it took 2 in accumulator then added + the currentValue e.g. 2. It will continue through each element until done with the array.


// Shorter Code

const sum2 = numbers.reduce((acc, cur) => acc + cur, 0);

console.log(sum2) //55


const sum3 = numbers.reduce((acc, cur) => acc + cur, 10);

console.log(sum3) //65 //Starting at 10


// Using a for loop 

// const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const sum4 = () =>{ //function expression

let acc = 0;

// for of //using for of instead of for loop because for of better for going through an array
for(const cur of numbers){
// acc = acc + cur 
acc += cur; 

}
return acc;
}

console.log(sum4()) // sum4() add parenthesis because it is a function 


 // Shopping cart example (objects)

const cart = [
  { id: 1, name: 'Product 1', price: 130 },
  { id: 2, name: 'Product 2', price: 150 },
  { id: 3, name: 'Product 3', price: 200 },
];

const total = cart.reduce(function (acc, product){

return acc + product.price //object properties not the number itself like above in arrays so you have to write product.price to get from the object

}, 0); //initialValue normally set to 0 

console.log(total)



// ***Array Method Challenges***

// Challenge 1

const people = [
  {
    firstName: 'John',
    lastName: 'Doe',
    email: 'john@gmail.com',
    phone: '111-111-1111',
    age: 30,
  },
  {
    firstName: 'Jane',
    lastName: 'Poe',
    email: 'jane@gmail.com',
    phone: '222-222-2222',
    age: 25,
  },
  {
    firstName: 'Bob',
    lastName: 'Foe',
    email: 'bob@gmail.com',
    phone: '333-333-3333',
    age: 45,
  },
  {
    firstName: 'Sara',
    lastName: 'Soe',
    email: 'Sara@gmail.com',
    phone: '444-444-4444',
    age: 19,
  },
  {
    firstName: 'Jose',
    lastName: 'Koe',
    email: 'jose@gmail.com',
    phone: '555-555-5555',
    age: 23,
  },
];

// syntax 1
//return the object

// const youngPeople = people
//   .filter((person) => person.age <= 25)
//   .map((person) => ({
  
//   return //return the object
//   });


// syntax 2
//({}) returning a straight object can just add parenthesis and use curly braces ({})

const youngPeople = people
  .filter((person) => person.age <= 25)
  .map((person) => ({ //({}) returning a straight object can just add parenthesis and use curly braces ({})
  }));


const youngPeople = people
  .filter((person) => person.age <= 25)
  .map((person) => ({
    name: person.firstName + ' ' + person.lastName,
    email: person.email,
  }));

console.log(youngPeople);


// Challenge 2
const numbers = [2, -30, 50, 20, -12, -9, 7];

const positiveSum = numbers
  .filter((number) => number > 0)
  .reduce((acc, cur) => acc + cur, 0);

console.log(positiveSum);


// Challenge 3
const words = ['coder', 'programmer', 'developer'];

const cWords = words.map((word) => {
  return word[0].toUpperCase() + word.slice(1, word.length);
});

console.log(cWords);


// ***Document Object Model*** (DOM)

// ***Intro To The DOM***

// Working in the actual browser body (not just in the console). A programming interface for web HTML documents. DOM is the structure of the web page that we can interact with using JavaScript. It includes all of the HTML tags, attributes and the text between the tags called "text nodes". 

// The DOM is usually represented as a tree structure.

// We have the `html` element which you can access through the document object. The HTML tag holds two children the `head` and `body` elements. 

// The `head` element holds the title element, which has a text node inside of it. In this case that would be the text, 'Website'. The `meta` element includes an attribute of `charset` which is set to `utf-8`. So any attributes are going to be accessible in the DOM as well. 

// The `body` element holds the `h1` element, which has a text node inside of it with the text, 'Hello World' and an atribute of class. There is also an `id` attribute. Then we have the `p` element with a text node inside of it.

// So this is how your HTML document full of tags, attributes and text nodes looks in the DOM.

// -The Window Object-

// In console can type in window will show the window global objects in the browser including the document object. 

// The `window` object is the top level object in the browser. It is the root of the browser's object hierarchy. It has properties and methods that are available to all of the JavaScript code in the browser. To see the window object's API (methods and properties), you can type `window` in the console or in your code.

console.log(window);

// -The Document Object-

// On that `window` object, we have a property object called `document`. 

// This is an object that represents the HTML document that we are currently viewing. It has all types of properties and methods that we can use to interact with the HTML document.

console.log(window.document);

// Since `window` is the top-level object in the browser, we do not need to prefix it with *window*

console.log(document);

// Sometimes console.log() will show the properties and methods, but sometimes it will show the element/tag itself. To see all the methods and properties, you can use `console.dir`

console.dir(document);

// Global window object

console.log(window)
console.log(window.document)

console.log(document)

// - console.dir() -

// The document object is part of the window object

console.dir(window.document)

console.dir(document)

// We can access DOM elements directly with properties such as the `body`
console.log(document.body)

console.log(document.body.innerHTML)

console.log(document.body.innerText)

document.body.innerHTML ='<h1>Hello World</h1>';

// We can also access elements such as links and images. Let's add a link to the HTML

// HTML
// <a href="https://traversymedia.com">Traversy Media</a>

// We can get all of the links with:
console.log(document.links)

// This returns something called an `HTMLCollection`, which is similar to an array. We can access by index

console.log(document.links[0])


// -Document methods-

// The document object has a ton of methods. 
// One is: 
document.write() 
//Which will write something to the document
document.write('Hello from JS');


// -Document Selection Methods-
// Getting elements using direct properties is not usually the way you want to do this.
// There are special methods available that allow us to directly select elements easily.

// Let's look at document.getElementById(). It allows us to basically grab an element from the HTML document by it's id. 

// Then we could do whatever we want to that specific element including changing the style, removing it, adding an event listener to it and so on. The term `DOM manipulation` just refers to changing the DOM using JavaScript, which again can be me adding, removing, changing elements, etc. A lot of the time we change the CSS through JavaScript to make something hide or show based on some user interaction.

// Just to give you a very simple example of selecting something from the DOM, let's open an html page and create a new div element with the ID of `main` and just add some text to it.

// html
// <div id="main">
// <h1>The DOM</h1>
// <a href="https://traversymedia.com">Traversy Media</a>
// </div>

// Now in our JavaScript file, we can use the `document.getElementById()` method to grab the element with the ID of `main`.

console.log(document.getElementById('main'))
const main = document.getElementById('main');

// Now let's say we want to add some text into the div element. We can easily do that using the `innerHTML` property.

main.innerHTML = '<h1>Hello from main</h1>'

// This will replace everything in the main element. 

// We also have methods to select elements more directly

document.getElementById('main').innerHTML = '<h1>Hello from main</h1>';

document.querySelector('#main h1').innerText = 'Hello';

// There are other methods that let us just append or add elements. The DOM gives us a lot of power to interact with the HTML document.

// The code we just wrote is written in JavaScript, but uses the DOM and it's API to access the document and its elements. Even when you start using a front-end framework like React, this is the stuff that it is doing under the hood.

// Python DOM Example:
import xml.dom.minidom as m
doc = m.parse(r"C:\Projects\Py\chap1.xml")
doc.nodeName //DOM property of document object
p_list = doc.getElementsByTagName("para")


// ***Document Element Properties***
// Properties available on the `document` object including properties that allowed us to select elements from the DOM in the form of HTMLCollections.

let output;

output = document.all //HTMLAllCollection() like an array (but not actully an array) gives all of the parts of the page DOM e.g. [html, head, meta, title, body, div, header, img, h1] etc. 

console.log(output)

// Access by Index 
output = document.all[8] //body
output = document.all[10] //header
output = document.all.length //36

// Get everything in the HTML
output = document.documentElement;

// Access just the head
output = document.head

// Access the children collection in the head 
output = document.head.children

// Access just the body
output = document.body

// Access the children collection in the body 
output = document.body.children

// Random properties
output = document.doctype; //<!DOCTYPE html>
output = document.domain;
output = document.URL;
output = document.characterSet; //UTF-8
output = document.contentType; //text/html

// Get all forms
// Lengths Forms (works like an array but not actually an array as it is a HTMLCollection)
output = document.forms //HTMLCollection length:1
output = document.forms[0] //form #item-form
output = document.forms[0].id //item-form
output = document.forms[0].method //get
output = document.forms[0].action //page http 

// Change a form id
document.forms[0].id = 'new-id' 
//It has been changed from within Javascript. Click from the console in elements and check it has been changed from <form id="item-form"></form> to <form id="new-id"></form>

// Get all links from HTML // <a href="https://google.com">Google</a>

output = document.links
output = document.links[0]
output = document.links[0].href
output = document.links[0].href ='https://facebook.com'
output = document.links[0].id = 'google-link'
output = document.links[0].className = 'google-class'
output = document.links[0].classList //DOMTokenList ['google-class', value: 'google-class'] //any classes on that element will be in the list

// Get all images

output = document.images //HTMLCollection [img]
output = document.images[0]
output = document.images[0].src

document.forms.forEach((form) => console.log(form)) 
// Uncaught TypeError: document.forms.forEach is not a function as it is a HTML Collection which is not actually an array. You can not use forEach() on a HTMLCollection. HTMLCollection items can be accessed by their name, id, or index number. An HTMLCollection is always a live collection. 

Array.from() //This method needs to be used to convert HTMLCollection into an array.

// Also just to note querySelector gives us a NodeList which is a collection of document nodes (element nodes, attribute nodes, and text nodes). NodeList items can only be accessed by their index number. You can use forEach() on a NodeList  
 
// Turn an HTMLCollection into an array 

Array.from()
// This method to convert turn a HTMLCollection into an array if you do want to use forEach()

const forms = Array.from(document.forms);
forms.forEach((form) => console.log(form)) //<div class="form-control">…</div>

console.log(output)


// ***DOM Selectors - Single Elements*** 
// getElementById() 
// querySelector()


// document.getElementById()

console.log(document.getElementById('app-title')); // <h1 id="app-title">Shopping List</h1>



// -Get attributes-

// .id 
console.log(document.getElementById('app-title').id); //app-title

// .class //undefined (not a property)
// console.log(document.getElementById('app-title').class); //undefined //Does not work for every single attribute .class is not a property.

// There is a .className
console.log(document.getElementById('app-title').className); //not always be the case so use .getAttribute('')

// .getAttribute('')
console.log(document.getElementById('app-title').getAttribute('id')) //app-title



// -Set attributes-
document.getElementById('app-title').id = 'new-id' // <h1 id="new-id">Shopping List</h1>

document.getElementById('app-title').title = 'Shopping List' 

document.getElementById('app-title').setAttribute('class', 'title'); 
//<h1 id="app-title" class="title">Shopping List</h1>

const title = document.getElementById('app-title')

console.log(title)
// <h1 id="app-title" class="title">Shopping List</h1>



// Get/Change Content
console.log(title.textContent)

title.textContent = 'Hello World';
// <h1 id="app-title" class="title">Hello World</h1>

title.innerText = 'Hello Again'
// <h1 id="app-title" class="title">Hello Again</h1>

title.innerHTML = '<strong>Shopping List</strong>' //bold strong Shopping List title


// Change Title
title.style.color = 'red'
title.style.backgroundColor = 'black'
title.style.padding = '10px'
title.style.borderRadius = '10px'


// -document.querySelector()-

console.log(document.querySelector('h1'))
// <h1 id="new-id">Shopping List</h1> //it will select the first one even if multiple on the page


console.log(document.querySelector('#app-title'))
console.log(document.querySelector('.container')) //div.container
console.log(document.querySelector('input[type="text"]')) // <input type="text" class="form-input" id="item-input" name="item" placeholder="Enter Item">
console.log(document.querySelector('li:nth-child(2)').innerText) //Orange Juice


const secondItem = document.querySelector('li:nth-child(2)');

secondItem.innerText = 'Apple Juice'; // set the element 
secondItem.style.color = 'red'

// Use these methods on other elements
const list = document.querySelector('ul');
console.log(list);

//using querySelector() it will select the first one even if multiple on the page
const firstItem = list.querySelector('li'); 
firstItem.style.color = 'blue'


// ***DOM Selectors - Multiple Elements***

// querySelectorAll()
// Returns a NodeList


// querySelectorAll()

const listItems = document,querySelectorAll('li') 
//If you add other li in other parts of the programme there is a risk that they could also be selected.
//You could add a tag, id, class, etc.

const listItem = document.querySelectorAll('.item');
console.log(listItem)
// NodeList(4) [li.item, li.item, li.item, li.item]

// querySelectorAll() this method takes a string as an argument and returns a NodeList of all the elements that match the selector. If no elements are found, it returns an empty NodeList.

// NodeList // querySelectorAll()
// It is similar to an HTMLCollection. NodeList is a list of elements that is formatted like an array. The main difference is that a NodeList is not a live collection. This means that if we add or remove elements from the DOM, the NodeList will not update. Another difference is that we can use high order array methods on a NodeList like `forEach()`, but not on an HTMLCollection with HTMLCollection you would first need to convert it into an array.

const listItems = document.querySelectorAll('.item');
console.log(listItems) // NodeList(4) [li.item, li.item, li.item, li.item]
console.log(listItems[1]) //<li class="item">…</li>
console.log(listItems[1].innerText) //Orange Juice

// listItems.style.color = 'red'; // Uncaught TypeError: Cannot set properties of undefined (setting 'color') //Cannot access style on a NodeList as style is for a specific element.

// Color Change for One Element access on a NodeList
listItems[1].style.color = 'red'; //color changed to red

// Color Change for All Elements access on a NodeList
listItems.forEach((item, index)=>{
item.style.color = 'red'

if(index === 1){
  item.remove()
}

if(index === 0){
// item.innerText = 'Oranges' //The delete button is also removed and everything else that is within the li class of .item in the HTML.

// Template Strings (one way to re-add the delete button) 
item.innerHTML = `Oranges
<button class="remove-item btn-link text-red">
  <i class="fa-solid fa-xmark"></i>
</button>`; 
}
});

getElementsByClassName() //Returns an HTMLCollection

const listItems2 = document.getElementsByClassName('item');

console.log(listItems2) //HTMLCollection(3) [li.item, li.item, li.item]
console.log(listItems2[2].innerText) //Milk


// forEach() // Will not work with getElementsByClassName() as it returns a HTMLCollection()

// listItems2.forEach((item) => {
//   console.log(item.innerText) // Uncaught ReferenceError: getElementsByClassName is not defined.
// })

// To use forEach() need to convert HTMLCollection getElementsByClassName() into an array with Array.from()

// Array.from()

const listItems2 = document.getElementsByClassName('item');

const listItemsArray = Array.from(listItems2)

listItemsArray.forEach((item) => {
  console.log(item.innerText) 
})
// Oranges
// Oreos
// Milk


getElementsByTagName()

const listItems3 = document.getElementsByTagName('li');
console.log(listItems3[0].innerText);




// ***Traversing The DOM*** 
// Tranversing DOM Element Relationships (Parent-Child) Elements Nodes
// `Elements` or `Element Nodes`

// We need to select elements within elements or a sibling of an element, so it is important to know how relationships work so that we can traverse or move up and down the DOM.

// There are different types of `nodes` in the DOM. Mostly we use Elements. Any HTML tag on the page is an element. There are specific properties for working with elements and there are properties that will allow us to work with other types of nodes, such as `Text` and `Comment` nodes. This time we will strictly be working with `Elements` or `Element Nodes`


// -Element Relationships-

// HTML

// <div class="parent">
//   <--- Children --->
//   <div class="child">Child 1</div>
//   <div class="child">Child 2</div>
//   <div class="child">Child 3</div>
// </div



// Get child elements from a parent

const parent = document.querySelector('.parent')
console.log(parent) //<div class="parent">…</div>


let output;


const parent = document.querySelector('.parent')
output = parent.children //Output of all the HTMLCollection an array like structure of all the child DIV's. Also .children is a property attribute it is not a method. Do not need to put parenthesis(). Also .children() is not a method it will give an error of: Uncaught TypeError: parent.children is not a function. It is a property which will give a HTMLCollection. HTMLCollection an array like structure of all the child DIV's.
 

// console.log(output) 

// HTMLCollection(3)[div.child, div.child, div.child]
// 0:div.child
// 1:div.child
// 2:div.child
// length:3
// [[Prototype]]:HTMLCollection

// As it is a HTMLCollection array like structure can access each individual element with an index.

output = parent.children[1];
console.log(output) //<div class="child">Child 2</div>

console.dir(output) //It will show all the properties and methods that can use on it. 

output = parent.children[1].innerText;
console.log(output) //Child 2

output = parent.children[1].className;
console.log(output) //Child (it has a class of child)

output = parent.children[1].nodeName;
console.log(output) //DIV

parent.children[1].innerText = 'Child Two' 
parent.children[1].style.color = 'red' 
 

// In addition to the children HTMLCollection there are two other properties that can be used on the parent 


parent.firstElementChild.innerText = 'Child One'; //Element Nodes property (not a method). It changed Child 1 to an output of Child One.

parent.lastElementChild.innerText = 'Child Three'; //Element Nodes property (not a method). It changed Child 3 to an output of Child Three.


// Get parent elements from a child 

const child = document.querySelector('.child')

output = child.parentElement; //output the parent by using the child using .parentElement property on the child.

console.log(output) //<div class="parent">…</div>

child.parentElement.style.border = '1px solid #ccc';
child.parentElement.style.padding = '10px';


// Sibling Elements 

const secondItem = document.querySelector('.child:nth-child(2)');

output = secondItem;
// output = secondItem.nextSibling; //Do not want this one here as it will get the next node no matter what it is which in this case #text which we do not want.

output = secondItem.nextElementSibling; //Will get the next element sibling which we do want 
//<div class="child">Child Three</div>


// Selected the secondItem directly using querySelector('.child:nth-child(2)'). Then used the nextElementSibling property to get the next sibling which is child three and then styled it green.

// nextElementSibling
output = secondItem.nextElementSibling.style.color = 'green';

// previousElementSibling
output = secondItem.previousElementSibling.style.color = 'orange';


console.log(output) 



// ***Traversing The DOM - All Nodes***
// Transversing DOM Node Relationships (Parent-Child Outside of Elements) All Nodes

// There are other types of nodes other than elements.
// The DOM has more than just element nodes. In fact, there are 12 different types of nodes (see image document for full list)

// HTML
//   <div class = "parent">
//   <!-- Children --> //comment is also looked at as a specific type of node
//   <div class="child">Child 1</div>
//   <div class="child">Child 2</div>
//   <div class="child">Child 3</div>
// </div>


// Child Nodes

// option1
const parent = document.querySelector('.parent');
console.log(parent.childNodes);

// This method, does exactly what it says, it gets all of the child nodes of an element. This includes `text nodes` and `comment nodes`.

// option 2
let output;

const parent = document.querySelector('.parent');

output = parent.childNodes;

console.log(output) // We get a NodeList of 9 items. 

// NodeList(9) [text, comment, text, div.child, text, div.child, text, div.child, text]
// 0:text //whitespace counts as text 
// 1:comment
// 2:text
// 3:div.child
// 4:text
// 5:div.child
// 6:text
// 7:div.child
// 8:text
// length:9
// [[Prototype]]:NodeList


// HTML
//   <div class = "parent">           // 0 text node whitespace
//   <!--- Children --->              // 1 comment node and 2 text node whitespace
//   <div class="child">Child 1</div> // 3 div.child element node (div class .child) and 4 text node whitespace
//   <div class="child">Child 2</div> // 5 div.child element node (div class .child) and 6 text node whitespace
//   <div class="child">Child 3</div> // 7 div.child element node (div class .child) and 8 text node whitespace
// </div>

// - 0: White space is a `text node`. Since the first line of HTML within the parent `div` (the comment) is on the next line, that line break is considered a `text node`. If I search in settings format and go to format on save and remove unsave uncheck the box and I were to move the comment section on to the same line as the parent `div`, then the `text node` would be removed because the whitespace would be removed. This will also reduce the nodes length down to 8 instead of from 9.

// - 1: The `comment` node. Comments are considered nodes as well.

// - 2: Another `text node`. This is the line break between the comment and the first child `div`.

// - 3: The first child `div`.

// - 4: Another `text node`. This is the line break between the first child `div` and the second child `div`.

// - 5: The second child `div`.

// - 6: Another `text node`. This is the line break between the second child `div` and the third child `div`.

// - 7: The third child `div`.

// - 8: Another `text node`. This is the line break between the third child `div` and the closing `div` tag.


let output;

const parent = document.querySelector('.parent');

output = parent.childNodes;
output = parent.childNodes[0] //#text node
output = parent.childNodes[0].textContent //empty
output = parent.childNodes[0].nodeName //#text 


output = parent.childNodes[3].nodeName //DIV
output = parent.childNodes[3].textContent //Child 1
output = parent.childNodes[3].innerHTML //Child 1
output = parent.childNodes[3].outerHTML //<div class="child">Child 1</div>


output = parent.childNodes[3].innerText = 'child One';

output = parent.childNodes[5].style.color ='red'

output = parent.firstChild //#text 
output = parent.lastChild //#text 

// Can replace the last child #text whitespace (empty space) with written .textContent Hello 
output = parent.lastChild.textContent = 'Hello'


// Get access parent node from the child 
// Normally one parent node with children nodes there are normally multiples.

const child = document.querySelector('.child')

output = child.parentNode; //<div class="parent">…</div>

child.parentNode.style.backgroundColor = '#ccc'
child.parentNode.style.padding = '10px'


// Get sibling nodes

const secondItem = document.querySelector('.child:nth-child(2)')

output = secondItem // <div class="child" style="color: red;">Child 2</div>

output = secondItem.nextSibling; //next node will be text node whitespace. If it was nextElementSibling it would give div child 3 but with nextSibling it gives us the text node whitespace.  

output = secondItem.previousSibling;

console.log(output)


// ***Create & Append Elements***

// Create Elements

// We know how to select elements from the DOM using multiple methods, navigate to related elements using certain properties, and manipulate elements by changing their innerText, innerHTML, styles etc. 

// To create elements with JavaScript, we can create any DOM element we want and then insert it into the document wherever want using specific methods. 

// You will want to create a new element and then insert it into the document on some kind of event. For example when we build the final functionality of our shopping list, we're going to want to create a new list item when we click on the _Add Item_ button.

// We have events, but first creating elements via JavaScript. First insert, move, create.

document.createElement() //method 

// Let's create a `div` element.

const div = document.createElement('div'); 

console.log(div)

// This is the main method we'll use to create elements. It takes one argument, which is the tag name of the element we want to create e.g. 'div' element.

//It does not do anything to the page just yet all it does is create's it in memory from our Javascript. It is not placed in the page just yet.

// We can add any attributes we want to our new `div` element. So you can create it with createElement('div') and add attributes you want to it.

// Add a class
div.className = 'my-element' //<div class="my-element"></div> //empty div

// Add an id
div.id = 'my-element'; //<div class="my-element" id="my-element"></div> //empty div

// Add an attribute
div.setAttribute('title', 'My Element'); //<div class="my-element" id="my-element" title="My Element"></div> //empty div


// document.createTextNode()

// If we want to add text, we could technically do it like this: 

div.innerText = "Hello World" 

// Normally innerText is used to get and change the text for an already existing element.

div.innerText = "Hello World" //<div class="my-element" id="my-element" title="My Element">Hello World</div>

// It's better to create a new text node with document.createTextNode() and then append it to the element. There are element nodes but there are also text nodes.

// Create a text node

const text = document.createTextNode('Hello World');

// Add the text node to the div

div.appendChild(text) //This appends a child e.g. to an element or text node inserts it into whatever the parent will be e.g. div. So you are putting the text inside of the div. We use appendChild to put it onto the page as well and where you want to put it or what you want to append it to is up to you.

// Inserting Elements into the Document

// Just like we used `appendChild()` to add the text node, we can use it to add it to the document.

// If for example you want to put it at the end of the inside of the body. 

document.body.appendChild(div); 

// That will place it in the body tag as the last element. We can target any element in the document and insert it into another element.

// If for example you want to put it at the end of unordered list ul. 

document.querySelector('ul').appendChild(div)

console.log(div)



// ***innerHTML vs createElement()***

// There's a quick and dirty solution, setting the innerHTML to whatever you want. 
// There's a cleaner more performant way of creating all of your elements and then inserting them into the DOM.

function createListItem(item){

const li = `<li>${item}</li>` //This is simply a string. It has to be a node.

document.querySelector('.item').appendChild(li);
// Uncaught TypeError: Cannot read properties of null (reading 'appendChild')
}


// Quick & Dirty (Using innerHTML)
// The first method is to create a `li` element and then simply set the `innerHTML` property to the output that you want, using a template string. 


function createListItem(item){

const li = document.createElement('li');

li.innerHTML = `${item}
<button class="remove-item btn-link text-red">
<i class="fa-solid fa-xmark"></i>
</button>`
  
document.querySelector('.items').appendChild(li);
// Uncaught TypeError: Cannot read properties of null (reading 'appendChild')
}
  

// Clean & Performant (Creating the elements)

// The second way is to actually create all of the elements including the  li element, text node, button element and icon element and appending each one. In this function, we created multiple elements. We created a list item, a button and an icon. Generally should have functions do one thing at a time. In this case our function did 3 things.

function createNewItem(item){

const li = document.createElement('li');

li.appendChild(document.createTextNode(item));

const button = document.createElement('button');
button.className = 'remove-item btn-link text-red';

const icon = document.createElement('i');
icon.className = 'fa-solid fa-xmark';

button.appendChild(icon)
li.appendChild(button)

// console.log(button);
// console.log(li.innerHTML)

document.querySelector('.items').appendChild(li)
}


createListItem('Eggs');
createNewItem('cheese')

// You could use either method, just know that using innerHTML causes the web browsers to reparse and recreate all the DOM nodes inside the ul element. So this is less efficient than creating a new element and appending to the ul. So the second way is more performant. Also, setting innerHTML will not automatically reattach event handlers to the new elements it creates, so you would have to keep track of them manually. It is just better practice to create your elements, rather than using innerHTML.


// ***Refactor To Use Multiple Functions***

// In the function, we created multiple elements. In the function we did 3 things we created a list item, a button and an icon. Generally we should have functions do one thing at a time. Let's refactor this code into multiple functions that we can reuse if needed. Broken up into small funcions. If something goes wrong, it is much easier to debug and the code is more readable and reusable. 


function createNewItem(item) {
  const li = document.createElement('li');
  li.appendChild(document.createTextNode(item));

  // const button = document.createElement('button'); //cut and paste into createButton() function
  // button.className = 'remove-item btn-link text-red'; //cut and paste into createButton() function
  const button = createButton('remove-item btn-link text-red') //set new variable of button to the return value of createButton() then pass through your classes.

  // const icon = document.createElement('i'); //cut and paste into createIcon() function
  // icon.className = 'fa-solid fa-xmark'; //cut and paste into createIcon() function

  // button.appendChild(icon); //cut and paste into createButton() function

  li.appendChild(button); //appending button to the list item

  document.querySelector('.items').appendChild(li); //appending the list item to the ul DOM 
}


// Let's create a function to create the button. We will take the classes in as arguments

function createButton(classes) { //each button has classes

  const button = document.createElement('button');
  // button.className = 'remove-item btn-link text-red'; //cut set button.className to the classes that are passed in as arguments
  button.className = classes //passed in as arguments


  // The icon is inside the button. There is preferance to put it within the createButton() function.  
  

  const icon = createIcon('fa-solid fa-xmark')
  button.appendChild(icon);

  return button
}

// We create and return the button. We need to include the icon, so let's create a function to create an icon

function createIcon(classes){ //each icon has classes

  const icon = document.createElement('i');
  // icon.className = 'fa-solid fa-xmark'; //cut set icon.className to the classes that are passed in as arguments
  icon.className = classes; //set that to the classes that come in as arguments

  return icon

  
}

createNewItem('cheese')
createNewItem('Sauce')

// Step by Step Guide  

// 1. Here is the original code.

function createNewItem(item) {
const li = document.createElement('li');
li.appendChild(document.createTextNode(item));

const button = document.createElement('button');
button.className = 'remove-item btn-link text-red';

const icon = document.createElement('i');

icon.className = 'fa-solid fa-xmark';

button.appendChild(icon);
li.appendChild(button);

document.querySelector('.items').appendChild(li);
}


// 2. Let's create a function to create the button. We will take the classes in as arguments

function createButton(classes) {
const button = document.createElement('button');
button.className = classes;

return button;
}


// 3. We create and return the button. We need to include the icon, so let's create a function to create an icon


function createIcon(classes) {
const icon = document.createElement('i');
icon.className = classes;

return icon;
}


// 4. Now we can add the `createIcon()` function to our `createButton()` function

function createButton(classes) {
const button = document.createElement('button');
button.className = classes;

const icon = createIcon('fa-solid fa-xmark');
button.appendChild(icon);

return button;
}

// 5. Now, add the `createButton()` function to our main function

function createNewItem(item) {
const li = document.createElement('li');
li.appendChild(document.createTextNode(item));

// Add button & icon
const button = createButton('remove-item btn-link text-red');
li.appendChild(button);
document.getElementById('item-list').appendChild(li);
}

// Now we have everything broken up into small funcions. If something goes wrong, it is much easier to debug and the code is more readable and reusable.


// ***Insert Elements, Text & HTML***

// -textContent vs innerText vs createTextNode-
 
// -textContent-

// textContent sets or returns the text content of an element and its descendants. It returns the text as it is, without any formatting or styling. One of the main advantages of textContent is that it returns all the text content, even if it is hidden by CSS styles or script.

// -innerText-

// The innerText property sets or returns the visible text content of an element and its descendants. It differs from textContent in that it returns only the visible text content, excluding any text that is hidden by CSS styles or script. This can be useful when you want to get or set the text that the user sees on the screen.

// -createTextNode-

// The createTextNode method creates a new Text node with the specified text content, which can then be inserted into the DOM tree using various methods. It is used when you want to create new text content dynamically and insert it into the DOM.

// - Conclusion textContent vs innerText vs createTextNode -
// In general, you should use textContent rather than innerText, unless you specifically need to get or set only the visible text content. Also createTextNode should be used when you need to create new text content dynamically and insert it into the DOM, or when you need to insert text content that has to be formatted differently from the rest of the text in the element.




// ***Insert Elements, Text & HTML***

// We know how to select and create elements. We also learned how to insert an item into the DOM using appendChild(). 

// There are other methods that we can use to insert elements, text and HTML into the DOM.

insertAdjacentElement() 
insertAdjacentText()
insertAdjacentHTML() 

// All three are all related and work in a similar way. The only difference is what you are inserting.

// Inserting Element 
insertAdjacentElement() 

// Inserting Text 
insertAdjacentText()

// Inserting HTML (works like innerHTML)
insertAdjacentHTML() 

// The way they all work is that they take in a position which will be one of these four positions:

// 1. beforebegin
// 2. afterbegin 
// 3. beforeend 
// 4. afterend


// The placement is as follows:

// 1. <!--- beforebegin --->
// 
// <p>
// 2. <!--- afterbegin --->
// **content of the initial element**
// 3. <!--- beforeend --->
// </p>
//
// 4. <!--- afterend --->


// 1. beforebegin If you choose beforebegin it is going to go above the paragraph. 

// 2. afterbegin If you choose afterbegin it will be directly inside of the paragraph at the top above all the content. 

// 3. beforeend If you choose beforeend it will be directly after the content but still within the paragraph. 

// 4. afterend If you choose afterend it will be after the entire paragraph.  


// insertAdjacentElement - Example:

function insertElement(){

const filter = document.querySelector('.filter')

const h1 = document.createElement('h1');

h1.textContent = 'insertAdjacentElement';

filter.insertAdjacentElement('beforebegin', h1)

}
insertElement();


// insertAdjacentText - Example:

function insertText(){

const item = document.querySelector('li:first-child');

item.insertAdjacentText('afterend', 'insertText')


}
insertText();


// insertAdjacentHTML - Example:

function innerHTML(){

const clearButton = document.querySelector('#clear');

clearButton.insertAdjacentHTML('afterend', '<h2>insertAdjacentHTML</h2>');

}

innerHTML() 


insertBefore() 
//It is similar to appendChild(). However in insertBefore() you define or bring in a parent and then you choose the item inside that parent that you want to insert your new item element before that already existing reference item element.

// insertBefore() - Example 

function insertBeforeItem(){

const ul = document.querySelector('ul'); //parent

const li = document.createElement('li');

li.textContent = 'insertBefore'

//select an item inside the parent where we want to insert your new item element before that already existing li:nth-child(3) reference item element. 
const thirdItem = document.querySelector('li:nth-child(3)')

ul.insertBefore(li, thirdItem); //You have to call it on the parent so in this e.g. ul.insertBefore (your element, reference existing item element). 

// On appendChild() you select the item you want to put it inside of and then you call appendChild on that.

}
insertBeforeItem()


// ***Custom insertAfter() Challenge***

// There is NO insertAfter it does NOT exist. You will have to make a customised insertAfter.

// The function will be called like this:

function insertAfter(newEl, existingEl){
console.log(existingEl.parentNode) //<ul id="item-list" class="items">…</ul>

console.log(existingEl.parentElement) //<ul id="item-list" class="items">…</ul>

existingEl.parentElement.insertBefore(newEl, existingEl.nextSibling);
} 

// New element to insert (newEl)
const li = document.createElement('li');
li.textContent = 'Insert Me After!';

// Existing element to insert after (existingEl)
const firstItem = document.querySelector('li:first-child');

// Our custom function
insertAfter(li, firstItem);




// ***Replacing DOM Elements*** (methods to replace elements)

// Method 1 - replaceWith()
// Let's replace the first `li` element with a new `li` element using the `replaceWith()` method.

function replaceFirstItem() {
  const firstItem = document.querySelector('li:first-child');

  const li = document.createElement('li');
  li.textContent = 'Replaced First';

  firstItem.replaceWith(li);
}

replaceFirstItem();

// Method 2 - outerHTML (the HTML of an element including the element itself e.g. li tags vs. innerHTML which is the HTML contained within an elements opening and closing tags)

function replaceSecondItem() {
  const secondItem = document.querySelector('li:nth-child(2)');

  secondItem.outerHTML = '<li>Replaced Second</li>'; //similar to setting the innerHTML except also setting the outer tags
}

replaceSecondItem();

// Replacing All Elements

function replaceAllItems() {
  const li = document.querySelectorAll('li'); //querySelectorAll() returns a nodeList accessed by their index number.

  li.forEach((item, index) => {
    // item.outerHTML = '<li>Replace All</li>';
    item.innerHTML = 'Replace All';
  });
}
replaceAllItems();

// with condition 

function replaceAllItems() {
  const li = document.querySelectorAll('li'); //

  li.forEach((item, index) => {
    if (index === 1) {
      item.innerHTML = 'Second Item';
    } else {
      item.innerHTML = 'Replace All';
    }
  });
}
replaceAllItems();

// shorter syntax 

function replaceAllItems() {
  const li = document.querySelectorAll('li'); 

  li.forEach((item, index)=> item.outerHTML = index === 1 ? '<li>Second Item</li>' : '<li>Item</li>')


}
replaceAllItems();

// replaceChild()
// replaceChild() is called on the parent element and takes two arguments, the new element and the old element.

// We select the parent which in this example is the header. We select the item we want to replace and then we replace it with a new item.  

// Another way that we can replace something is by selecting the parent element and then using the replaceChild() method. Let's replace the `h1` element with an `h2`.


function replaceChildHeading(){
  const header = document.querySelector('header')
  const h1 = document.querySelector('header h1')

  const h2 = document.createElement('h2');
  h2.id = 'app-title';
  h2.textContent = 'Shopping List'
  header.replaceChild(h2, h1) //h2 to replace the h1
}

replaceChildHeading()




// ***Remove DOM Elements***

// Now let's look at methods to remove elements completely from the DOM.

remove()
// remove() you use it on the element you want to remove and it will remove it from the DOM. Let's say that we want to remove the clear button from the page.

// syntax 1 

function removeClearButton(){
document.querySelector('#clear').remove();
}
removeClearButton()

// syntax 2 

function removeClearButton(){
const clearButton = document.querySelector('#clear')
clearButton.remove();
}
removeClearButton()



removeChild()
// removeChild() is a bit more complicated. You use it on the parent element and it will remove the child element from the parent. Let's say that we want to remove the first `li` in the shopping list.

function removeFirstItem(){
const ul = document.querySelector('ul') //select the parent ul

const li = document.querySelector('li:first-child') //select the item you want to remove

ul.removeChild(li) //We want to call on the parent the ul .removeChild and pass in the li


}
removeFirstItem()


function removeItem(itemNumber){
const ul = document.querySelector('ul');
const li = document.querySelector(`li:nth-child(${itemNumber})`);

ul.removeChild(li)

}
removeItem(2)



function removeItem2(itemNumber){
  const ul = document.querySelector('ul');
  // const li = document.querySelectorAll('li')[0];
  const li = document.querySelectorAll('li')[itemNumber - 1];
  
  ul.removeChild(li)
  
  }
  removeItem2(1)
  


 function removeItem3(itemNumber){
  const li = document.querySelectorAll('li'); //nodeList[array like] 
  li[itemNumber - 1].remove() 
 }

 removeItem3(4)


//  shorter syntax 

const removeItem4 = (itemNumber) =>
document.querySelectorAll('li')[itemNumber - 1].remove();

removeItem4(2)



// ***Manipulating Styles & Classes***

const text = document.querySelector('p');
const itemList = document.querySelector('.item-list');
const items = itemList.querySelectorAll('li');

function run() {
  // className - Gets a string of all classes
  console.log(itemList.className);
  // Changing the classes with className
  text.className = 'card dark'; //overides any classes set in HTML so make sure you put both classes to keep the previous styling e.g. card (HTML existing class) and dark (js class).

  // classList - Array of classes, which also has methods to add, remove, toggle and replace
  console.log(itemList.classList);



  // We can loop through the classes
  // console.log(itemList.classList) //DOMTokenList()
  itemList.classList.forEach((c) => console.log(c));

  // Add, remove, toggle, replace
  text.classList.add('dark'); //still has formatting of the card class from HTML
  text.classList.remove('card'); 
  text.classList.toggle('hidden');
  text.classList.replace('card', 'dark');

  // style property - Add styles to elements
  itemList.style.lineHeight = '3';

  items.forEach((item, index) => {
    item.style.color = 'red';

    if (index === 2) {
      item.style.color = 'blue';
    }
  });
}

// Output 
document.querySelector('button').onclick = run; //Don't add parenthesis run() as it will automatically execute it.

// ***Events***

// We looked at properties and methods on the document object to be able to add, change and remove things from the DOM. The document object is when an HTML document is loaded into a web browser, it becomes a document object. The document object is a property of the window object accessed with window.document or just document. Document Object Properties and Methods e.g. createElement().

// Now we need to learn the actions the user takes to make these things happen and these are called events. Any interaction that the user has with the web page including loading of the page is an event.

// What Are Events?

// Events are something that happens or action within the browser. There are many kinds of events. Even the page loading is an event that we can listen for and respond to. Some other examples of events would be..

//     - Clicking on an element, e.g. button
//     - Typing into a text input field
//     - Hovering over an element
//     - Submitting a form
//     - Closing a window
//     - Dragging an element
//     - Resizing an element
//     - etc.

// Inline Event Listeners

// There are a few ways to listen for an event and react to it. One of the simplest ways is to use the onclick attribute direct into HTML. This is NOT recommended as it is not very flexible and can possibly pose a security risk.

// To put the Inline Event listener direct into the HTML file as an attribute. Let's add an `onclick` event listener to the clear button. We will set the value to `alert('clear')`, which will show a browser alert popup when we click the button.

// HTML 
// <button onclick="alert('clear')" type="submit" class="btn">

// There is only so much code you put into the HTML so you can make a function in Javascriptcto handle the event e.g.

// Now create the function onClear() in the linked JS file.

// HTML
// <button onclick="onClear()" type="submit" class="btn"> 

// Javascript

// function onClear(){
// alert ('clear');
// }


// - Event Listeners in JavaScript -

// HTML 
// <button id="clear" class="btn-clear">Clear All</button>

const clearBtn = document.getElementById('clear')

// onClick() is one many Javascript Event Listners
clearBtn.onclick = function(){
  alert('clear')
}; 

// - addEventListener -

clearBtn.addEventListener('click', function(){ // call back function
alert('clear')
});

clearBtn.addEventListener('click', function(){ 
console.log('clear')
});
  

// You can have as many event listeners as you want on the same event with addEventListener:

// Shorter Syntax

clearBtn.addEventListener('click', ()=> alert('clear'));

clearBtn.addEventListener('click', ()=> console.log('clear'));


// - Named Function -

// We put in an anonymous function but we can use named function such as onClear. So instead of passing an arrow function as the second argument let's pass in the onClear function. 

function onClear() {
  alert('clear')
  console.log('clear')
}

clearBtn.addEventListener('click', onClear);

// You do not want to put parenthesis onClear() as it will just execute. The function get's invoked because of using parenthesis (). You just want to pass in the callback, you want to pass in the function name. That way it only fires off when you fire the event.  

//alert is a blocking operation related to synchronous vs asynchronous. An alert is synchronous and is blocking so nothing will hapen until the alert is pressed ok and cleared up but it does run both of them that is an advantage of addEventListener.

removeEventListener()

// We can also remove event listeners from elements. You don't have to use it everytime you addEventListener. Where you do want to use it is when you have an element that you are removing from the DOM. We learn't about remove() and removeChild(). If you are using those methods remove() and removeChild() it is a good idea to remove the removeEventListener() first. 

// Call removeEventListener() but I want to call it 5 seconds after the page loads using a function called setTimeout() which is an asynchronous javascript function.


setTimeout() 

// It takes in two things a function and number of milliseconds that I want to wait to fire this function off. 

setTimeout(()=> clearBtn.removeEventListener('click', onClear), 5000)
// click event and reference function onClear
// We get to 5 seconds can no longer click it because that event listener has been removed.

// We can trigger an event programmatically. If I want to have my script to actually do the click instead of physically having to click manually it will work automatically. In this example after 5 seconds without clicking or doing anything there will be an alert that will popup.

setTimeout(()=> clearBtn.click(), 5000)


// Clearing The Items

// Let's add some code to clear all of the items from the list. 3 different ways to make that happen.

// Example 1 

function onClear(){

  const itemList = document.querySelector('ul');
  itemList.innerHTML = ''
};

// Example 2 

function onClear(){

  const itemList = document.querySelector('ul');

  //bring in li list items 
  const items = itemList.querySelectorAll('li')

  items.forEach((item)=>item.remove());
  
};

// Example 3

function onClear(){

    const itemList = document.querySelector('ul');
  
    const items = itemList.querySelectorAll('li')

    // while loop (most performant way to delete multiple items)

    while(itemList.firstChild){ //checking the firstchild property means if there is a firstchild that means there is a list item.

    itemList.removeChild(itemList.firstChild)

    // Once it check's there is a li firstChild then we are going to remove it and it will do that until there is no more children.   
    }
  };



    // ***Mouse Events***

    const logo = document.querySelector('img')

    // Top
    // Functions Start 

    const onClick = () => console.log('click event')

    // option 1 
    const onDoubleClick = () => console.log('dblclick', onDoubleClick)

    // option 2
    const onDoubleClick = () => {
    document.body.style.backgroundColor = 'purple'
    }

    // option 3 
    const onDoubleClick = () => {
    if(   
    document.body.style.backgroundColor !== 'purple'){

    document.body.style.backgroundColor = 'purple'
    document.body.style.color = 'white'

    }else{

    document.body.style.backgroundColor = 'white'
    document.body.style.color = 'black'
  }
}

const onRightClick = () => console.log('right click event')
const onMouseDown = () => console.log('mouse down event')
const onMouseUp = () => console.log('mouse up event')
const onMouseWheel = () => console.log('mouse wheel event')
const onMouseOver = () => console.log('mouse over event')
const onMouseOut = () => console.log('mouse out event')
const onDragStart = () => console.log('drag start event')
const onDrag = () => console.log('drag event')
const onDragEnd = () => console.log('drag end event')

// Functions End

// Bottom (Event Listeners below Functions)

// Event Listeners 

logo.addEventListener('click', onClick)
logo.addEventListener('dblclick', onDoubleClick)
logo.addEventListener('contextmenu', onRightClick)
logo.addEventListener('mousedown', onMouseDown)
logo.addEventListener('mouseup', onMouseUp)
logo.addEventListener('wheel', onMouseWheel)
logo.addEventListener('mouseover', onMouseOver)
logo.addEventListener('mouseout', onMouseOut)
logo.addEventListener('dragstart', onDragStart)
logo.addEventListener('drag', onDrag)
logo.addEventListener('dragend', onDragEnd)


// ***The Event Object***
// Available to us when we add an event listener then we run a function.

const logo = document.querySelector('img');

logo.addEventListener('click', function(e){  // (e) optional event object 
console.log(e) //PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
})

function onClick(e){
console.log(e.target) //<img src="images/note.png" alt>
console.log(e.currentTarget) //<img src="images/note.png" alt>

}

logo.addEventListener('click', onClick) // PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}

document.body.addEventListener('click', function(e){
  console.log(e.target) 
  console.log(e.currentTarget)
  console.log(e.type)
  console.log(e.timeStamp)
  console.log(e.clientX)
  console.log(e.clientY)
  console.log(e.offsetX)
  console.log(e.offsetY)
  console.log(e.pageX)
  console.log(e.pageY)
  console.log(e.screenX)
  console.log(e.screenY)
})

preventDefault() 
// Especially when dealing with forms. Stops the prevemt default behaviour. In a form when dealing with front end Javascript for validation fetch request and you don't want the from to actually submit to the page you use preventDefault(). You can also use it on a link.

// HTML 
{/* <a href="http://google.com">Google</a> */}

document.querySelector('a').addEventListener('click', function(e) {
e.preventDefault();
console.log('Link was clicked')
})

function onDrag(e) {
document.querySelector('h1').textContent = `X ${e.clientX} Y ${e.clientY}`;
}

logo.addEventListener('drag', onDrag)


// Properties on the Event Object:

// - `target` - The element that triggered the event
// - `currentTarget` - The element that the event listener is attached to (These are the same in this case    with target and currentTarget)
// - `type` - The type of event that was triggered 
// - `timeStamp` - The time that the event was triggered
// - `clientX` - The x position of the mouse click relative to the window
// - `clientY` - The y position of the mouse click relative to the window
// - `offsetX` - The x position of the mouse click relative to the element
// - `offsetY` - The y position of the mouse click relative to the element
// - `pageX` - The x position of the mouse click relative to the page
// - `pageY` - The y position of the mouse click relative to the page
// - `screenX` - The x position of the mouse click relative to the screen
// - `screenY` - The y position of the mouse click relative to the screen


    
// ***Keyboard Events & Key Properties***
    
const itemInput = document.getElementById('item-input')

const onKeyPress = (e) => {
console.log('keypress')
} 

const onKeyUp = (e) => {
console.log('keyup')
} 
  
// const onKeyDown = (e) => {
// console.log('keydown')
// } 

const onKeyDown = (e) => {

// key 
console.log(e.key)
document.querySelector('h1').innerText = e.key

if(e.key === 'Enter'){
alert('You pressed Enter')
}


// keyCode
// https://www.toptal.com/developers/keycode/table

if(e.keyCode === 13)
alert('You Pressed Enter')

// code
console.log(e.code) //e.g. KeyF, Digit1

if(e.code === 'Digit1'){
console.log('You Pressed 1')
}

if(e.repeat){ //true false
console.log('You are holding down ' + e.key) //repeatedly holding down the same key 
}

console.log('Shift: ' + e.shiftKey) // Shift: false or when you actually press shift you get Shift: true 
console.log('Control: ' + e.ctrlKey) //Control: true or Control: false
console.log('Alt: ' + e.altKey); //Alt: true or Alt: false

if (e.shiftKey && e.key === 'K') {
    console.log('You hit shift + K');
  }
};

itemInput.addEventListener('keypress', onKeyPress) 
itemInput.addEventListener('keyup', onKeyUp)
itemInput.addEventListener('keydown', onKeyDown) //keeps going if you keep pressing key down


// ***KeyCode Mini-Project***

// Method 1 Quick & Dirty Coding

window.addEventListener('keydown', (e) => {
  const insert = document.getElementById('insert');

  insert.innerHTML = ` 
  <div class="key">
  ${e.key === ' ' ? 'Space' : e.key}
  <small>e.key</small>
  </div>

  <div class="key">
  ${e.keyCode}
  <small>e.keyCode</small>
  </div>

  <div class="key">
  ${e.code}
  <small>event.code</small>
  </div> 
  `;
});



// Method 2

function showKeyCodes(e){
const insert = document.getElementById('insert');
insert.innerHTML = ''


// create an object 
const keyCodes = {

// As we are using a dot e.key we have to put quotes around it e.g. 'e.key' as it is the key the title.
// key : value  
'e.key':e.key === ' ' ? 'Space' : e.key,  
'e.keyCode':e.keyCode,
'e.code':e.code,
}

// console.log(keyCodes)
// For in Loop can loop through Arrays and Objects. Loop’s properties (keys) of assigned, against the object data values.

// e.g. one of these divs:

//   <div class="key"> //key
//   ${e.keyCode}
//   <small>e.keyCode</small>
//   </div>

// for each of these:

// const keyCodes = { //keyCodes (name of the object)  
// 'e.key': e.key === ' ' ? 'Space' : e.key,  
// 'e.keyCode':e.keyCode,
// 'e.code':e.code,
// }

for (let key in keyCodes){
const div = document.createElement('div');
div.className = 'key';
const small = document.createElement('small');

const keyText = document.createTextNode(key);
const valueText = document.createTextNode(keyCodes[key])
small.appendChild(keyText);
div.appendChild(valueText);
div.appendChild(small);
insert.appendChild(div)
}
}

window.addEventListener('keydown', showKeyCodes);





// ***Input Events***



// Text Input
const itemInput = document.getElementById('item-input')

// List Options Input
const priorityInput = document.getElementById('priority-input')

// Checkbox Input
const checkbox = document.getElementById('checkbox')

// Header Shopping List 
const heading = document.querySelector('h1')


function onInput(e){
// console.log('Input');
// console.log(e.target.value);
heading.textContent = e.target.value
}


function onChecked(e){
// console.log(e.target.checked)
const isChecked = e.target.checked
heading.textContent = isChecked ? 'Checked' : 'Not Checked'
}

function onFocus(){
console.log('Input is focused')
itemInput.style.outlineStyle = 'solid'
itemInput.style.outlineWidth = '1px'
itemInput.style.outlineColor = 'red'
}

function onBlur(){
console.log('Input is not focused')
itemInput.style.outlineStyle = 'none'
}


// itemInput.addEventListener('keydown', onInput); //Can use keydown but for input feilds better to use input. A keydown isn't going to work for a HTML select options list becuase you are not pushing any key. 
itemInput.addEventListener('input', onInput); //Use input for most of your input feilds. 


// priorityInput.addEventListener('input', onInput);

// Also can use a change event that you can use on a select option list. It works the same as input. Also input is recommended.  

priorityInput.addEventListener('change', onInput);

checkbox.addEventListener('input', onChecked);

// Focus & Blur
// Usually used for styling. So focus is clicking in and activating the input and blur is clicking out and unactivating.   

itemInput.addEventListener('focus', onFocus);
itemInput.addEventListener('blur', onBlur);




// ***Form Submission & FormData Object***

const form = document.getElementById('item-form');

function onSubmit(e){
e.preventDefault();
console.log('submit') // It flashed submit. It did do the console.log then it submitted to the actual file. If you don't have an action attribute on your form that you are submitting to the back end then it will submit to the same page. To stop that happening you can use e.preventDefault(). This will not submit to the file it just does what the code is written. In this case it is just a simple console.log. 

// To get values that are being submitted to the form. Getting the value with .value

const item = document.getElementById('item-input').value;
const priority = document.getElementById('priority-input').value;


if(item === '' || priority === '0'){
alert('Please fill in all fields')
return // console.log will not work later because it has been returned in the function
}


console.log(item.value, priority.value) //can also write value in console.log
console.log(item, priority) // console.log does not work because there is a return from the function.  
}




// Using the FormData Object
function onSubmit2(e){
e.preventDefault()

const formData = new FormData(form); 
// (form) is global so can access it anywhere in the script.

 // Get individual items
const item = formData.get('item') // HTML name property name="item"
{/*<input type="text" class="form-input" id="item-input" name="item" placeholder="Enter Item"/>*/}

const priority = formData.get('priority')

console.log(item, priority)

console.log(formData) // FormData {} inside the output of the console there is an output of formData(). Inside the formData() there is a get method.

// Get all entried as an Iterator
const entries = formData.entries();
console.log(entries) // Iterator{} allows us to loop iterate through it, the easy way is to use for of. 


// Loop through entries
for (let entry of entries){
console.log(entry[1]) //milk 1
console.log(entry[0]) //item priority
// It gives an array:
// ['0', '1'] 
// ['item', 'milk']
// ['priority', '1'] 
}

}

form.addEventListener('submit', onSubmit);
form.addEventListener('submit', onSubmit2);



// ***Event Bubbling***


// When we addEventListener on to an element that event moves up the DOM tree and if it finds a parent element that has a listener for that event it will fire that as well. So even of we click on a button it will bubble all the way to the document.

// With bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements.


const button = document.querySelector('form button')

const div = document.querySelector('form div:nth-child(2)')

// The form is the parent to the div:
const form = document.querySelector('form')


button.addEventListener('click', (e)=>{
alert('button was clicked');
e.stopPropagation() // click on the button and there is no bubbling of other alerts popping.
});

div.addEventListener('click', ()=>{
alert('div was clicked'); //When clicking on the button simultaneously the div is also alerted and pops up. So there is two alerts one for the button and secondly for the parent div. By clicking on the button it is bubbling up to any of its parents that have a click event listener which is also going to fire that as well. 
})

form.addEventListener('click', ()=>{
  alert('form was clicked'); //When clicking on the button simultaneously the div and then the form is alerted and all three pops up. So there is now three alerts one for the button, secondly for the parent div and thirdly the form. By clicking on the button it is bubbling up to any of its parents that have a click event listener which is also going to fire the button, div and then form. 

});


document.body.addEventListener('click', ()=>{
alert('body was clicked');
//1. button was clicked alert pops up
//2. div was clicked alert pops up
//3. form was clicked alert pops up
//4. body was clicked alert pops up
})

stopPropagation() 
// There are cases you do not want bubbling to happen as it will mess your application output. So that is where the stopPropagation() method comes in which is part of the event object.  

// You should only use stopPropagation() if we have a parent and child with the same event listener. Dont just call it unnecessarily.

stopImmediatePropagation()
// There is also stopImmediatePropagation() and is used if you have multiple handlers on a single event and you want to stop the event for all of them. 



// ***Event Delegation & Multiple Select Elements Events***

const listItems = document.querySelectorAll('li')

const list = document.querySelector('ul');

// Add an event listener on all items

listItems.forEach(item =>{
item.addEventListener('click', (e)=>{
  // console.log(e.target)
  e.target.remove()
})
});


// Add a single event listener on the parent, more efficient (Event Delegation)

list.addEventListener('click', (e)=>{

// console.log(e.currentTarget) // what the event listener is on. It is the element that the event listener is attached to. e.g. will give ul as well as li

// console.log(e.target) // what you click on

if(e.target.tagName === 'LI'){
e.target.remove() 
}

})

list.addEventListener('click', (e)=>{
if(e.target.tagName === 'LI'){
e.target.style.color ='red'
}
})

// ***Page Loading & Window Events***

// On Page Load 
// src="./script.js" if it is in the head above the title at the top of the HTML use 'defer' when you put script in the head. You are running the javascript before the page DOM is loaded. A common practice is to use the load event.

// option 1
// older practice 
// window.onload = function(){
// document.querySelector('h1').textContent = 'Hello World';
// }

// option 2
// load (waits for the entire page to load including all resources, images). The load would console second and if using DOMContentLoaded it will be loaded first. "DOMContentLoaded" is an event that happens when a web page finishes loading and all its content is ready to be shown to you. It means that the web page's HTML, CSS, and JavaScript code have been downloaded and processed by your web browser. Once "DOMContentLoaded" occurs, you can see and interact with the elements on the web page, like buttons, images, and text. It's like a signal that tells the browser, "Hey, the web page is ready, you can start showing everything now!"

window.addEventListener('load', () =>{
document.querySelector('h1').textContent = console.log('Page Loaded')
})


// option 3

// On DOM Load

// DOMContentLoaded (runs as soon as the DOM is parsed browser parses HTML into a DOM tree.). The DOM is loaded first and load second.


window.addEventListener('DOMContentLoaded', () =>{
document.querySelector('h1').textContent = console.log('DOM Loaded')
})

console.log('Run Me') // This is global and would run before load and DOMContentLoaded because we are not in any of these addEventListener where we are waiting for the page to load. 


{/* <script src="./script.js" defer></script> */}
// The defer after the script.js if placing above in the head of HTML. It will defer the javascript code from running until until the pages are loaded.   



// Resize Event

window.addEventListener('resize', ()=>{

document.querySelector('h1').innerText = `Resized to ${window.innerWidth} x ${window.innerHeight}`
}); 

// Scroll Event

// object.onscroll = function(){}
window.addEventListener('scroll', () =>{

  console.log(`Scrolled: ${window.scrollX} x ${window.scrollY}`)

  if(window.scrollY > 70){
    document.body.style.backgroundColor = 'black' 
    document.body.style.color = 'white' 
  }else{
    document.body.style.backgroundColor = 'white' 
    document.body.style.color = 'black' 
  }
});

 // Focus & Blur Events

 // focus e.g. click on in  
 window.addEventListener('focus', ()=>{

  document.querySelectorAll('p').forEach((p) => {
  p.style.color = 'blue';
  });
 });

 // blur e.g. click off out  
 
 window.addEventListener('blur', ()=>{

  document.querySelectorAll('p').forEach((p) => {
  p.style.color = 'black';
  });
 });


// ***Shopping List Project***

// Add Items To List (DOM Only)

const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');

// functions
function addItem(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value

if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// Create List Item 

const li = document.createElement('li');

li.appendChild(document.createTextNode(newItem));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 

itemList.appendChild(li);

itemInput.value = ''

} 

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}


function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 


}


// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', addItem);

// ***Shopping List Project***

// ***Remove & Clear Items***

const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');

// functions

function addItem(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value

if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// Create List Item 

const li = document.createElement('li');

li.appendChild(document.createTextNode(newItem));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 

itemList.appendChild(li);

itemInput.value = ''

} 

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 
}


function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}

function removeItem(e){
// console.log(e.target) //selects ul li icon
// e.target.remove() //deletes the cross
// console.log(e.target.parentElement) //button is the parent to the icon that was clicked
//  console.log(e.target.parentElement.classList) // we get all the different classes and remove item is one of them. We want to check to make sure that what we click on the parent has that class name.
 
if(e.target.parentElement.classList.contains('remove-item')){
// console.log('click');

// we only want this to fire off if what we are clicking on the icon whos parent is a button with a class of remove-item  

e.target.parentElement.parentElement.remove()
// 1. parentElement button 
// 2. parentElement list-item 
// We are reversing the DOM to get to where we want to to manipulate it is called event delegation.
} 
}

function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}
}

// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', addItem);
itemList.addEventListener('click', removeItem);
clearBtn.addEventListener('click', clearItems);


// ***Clear UI State***


const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  


// functions
function addItem(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value


if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')


// Create List Item 

const li = document.createElement('li');

li.appendChild(document.createTextNode(newItem));
// console.log(li) //<li>milk</li>



const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);

checkUI()

itemInput.value = ''


} 

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}

function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}

function removeItem(e){
  // console.log(e.target) //selects ul li icon
  // e.target.remove() //deletes the cross
  // console.log(e.target.parentElement) //button is the parent to the icon that was clicked
  // console.log(e.target.parentElement.classList) // we get all the different classes and remove item is one of them. We want to check to make sure that what we click on the parent has that class name.
 
if(e.target.parentElement.classList.contains('remove-item')){
// console.log('click');

// we only want this to fire off if what we are clicking on the icon whos parent is a button with a class of remove-item  


if(confirm('Are you sure you want to delete?')){ //confirm() window object window.confirm should also work.
e.target.parentElement.parentElement.remove()
}
// 1. parentElement button 
// 2. parentElement list-item 
// We are reversing the DOM to get to where we want to to manipulate it is called event delegation.

checkUI()

} 
}


function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

checkUI()
}

function checkUI(){
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
    clearBtn.style.display = 'none'
   itemFilter.style.display = 'none'
  }else{
    clearBtn.style.display = 'block'
   itemFilter.style.display = 'block'
  }
}

// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', addItem);
itemList.addEventListener('click', removeItem);
clearBtn.addEventListener('click', clearItems);


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.



// ***Filter Items Letter by Letter*** 


const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  


// functions
function addItem(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value


if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')


// Create List Item 

const li = document.createElement('li');

li.appendChild(document.createTextNode(newItem));
// console.log(li) //<li>milk</li>



const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);

checkUI()

itemInput.value = ''


} 

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}


function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 


}

function removeItem(e){
  // console.log(e.target) //selects ul li icon
  // e.target.remove() //deletes the cross
  // console.log(e.target.parentElement) //button is the parent to the icon that was clicked
  // console.log(e.target.parentElement.classList) // we get all the different classes and remove item is one of them. We want to check to make sure that what we click on the parent has that class name.
 
if(e.target.parentElement.classList.contains('remove-item')){
// console.log('click');

// we only want this to fire off if what we are clicking on the icon whos parent is a button with a class of remove-item  


if(confirm('Are you sure you want to delete?')){ //confirm() window object window.confirm should also work.
e.target.parentElement.parentElement.remove()
}
// 1. parentElement button 
// 2. parentElement list-item 
// We are reversing the DOM to get to where we want to to manipulate it is called event delegation.

checkUI()

} 
}


function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
    clearBtn.style.display = 'none'
   itemFilter.style.display = 'none'
  }else{
    clearBtn.style.display = 'block'
   itemFilter.style.display = 'block'
  }
}

// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', addItem);
itemList.addEventListener('click', removeItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.





// ***Local Storage Crash Course***

// - Local Storage / Session Storage - 

// Properties on the window interface object access to a storage object. We can store data directly in the browser. When we use localStorage in our shopping list when we add an item it gets stored in the browser. It's not connected to a database. We store right in our own browser only we can see it. Data is stored as key/value pairs and the values are stored as strings. We can stringify the objects store them in local storage and we need to use them we pull them out and parse them as an object.

// The difference between localStorage and sessionStorage is that localStorage will not expire and sessionStorage only last's as long as the page is open. As soon as you close the page browser the sessionStorage is gone, localStorage will stick around unless you set it to expire. They have the same API same methods.

// localStorage Methods 

localStorage.setItem('name', 'Brad'); //set value with a key. We want to save with a key of name and the value is Brad.

localStorage.getItem('name'); //get value using passing in the key. 

localStorage.removeItem('name'); //remove item from the localStorage we pass it by using the key name.

localStorage.clear(); //clear all values


// You can go into the console and click on the tab Applications. Click on the side tabe localStorage. You will see Key and Value.

localStorage.setItem('name', 'Brad');
//If you save the page, close the page, reload the page it will still be there. If you use sessionStorage it will go away.

console.log(localStorage.getItem('name')) //key name output in console Brad

localStorage.removeItem('name'); //key name it logs it in the console but if you go into Application it will be removed. 

localStorage.clear(); //cleared any values

//In localStorage() we will be using it and saving it as a stringify objects. It is not good for sensitive data.




// ***Add Items To Local Storage***

const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  


// functions
function onAddItemSubmit(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value


if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// create item DOM element 
addItemToDOM(newItem)

// Add item to local storage 
addItemToStorage(newItem)
// Key    Value
// items  ["Juice"]
// ["Juice"] looks like an array has the brackets and string inside it but it's just a stringify array. You can't store true arrays in localStorage. When we pull it out we are doing a JSON.parse and turn it back into a regular array.


checkUI()

itemInput.value = ''


} 

function addItemToDOM(item){

// Create List Item 
const li = document.createElement('li');

li.appendChild(document.createTextNode(item));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);
}



function addItemToStorage(item){
let itemsFromStorage; //initialising creating this variable

if(localStorage.getItem('items') === null ){ //checking if there is no items in storage if there is not then that variable is set to an empty array.
itemsFromStorage = []


//if there are items in storage then we are parsing the string back to an array putting those items into the variable of itemsFromStorage   
}else{
itemsFromStorage = JSON.parse(itemsFromStorage = localStorage.getItem('items'))
}

// Then we are adding new item to an array
itemsFromStorage.push(item)

//Finally converting it to JSON string and setting set it back to local storage

localStorage.setItem('items', JSON.stringify(itemsFromStorage))
} 

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}



function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}


function removeItem(e){
  // console.log(e.target) //selects ul li icon
  // e.target.remove() //deletes the cross
  // console.log(e.target.parentElement) //button is the parent to the icon that was clicked
  // console.log(e.target.parentElement.classList) // we get all the different classes and remove item is one of them. We want to check to make sure that what we click on the parent has that class name.
 
if(e.target.parentElement.classList.contains('remove-item')){
// console.log('click');

// we only want this to fire off if what we are clicking on the icon whos parent is a button with a class of remove-item  


if(confirm('Are you sure you want to delete?')){ //confirm() window object window.confirm should also work.
e.target.parentElement.parentElement.remove()
}
// 1. parentElement button 
// 2. parentElement list-item 
// We are reversing the DOM to get to where we want to to manipulate it is called event delegation.

checkUI()

} 
}


function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
  clearBtn.style.display = 'none'
  itemFilter.style.display = 'none'
  }else{
  clearBtn.style.display = 'block'
  itemFilter.style.display = 'block'
  }
}

// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', onAddItemSubmit);
itemList.addEventListener('click', removeItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.





// ***Display Items From Local Storage***

const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  


function displayItems() {
  const itemsFromStorage = getItemsFromStorage();
  itemsFromStorage.forEach((item) => addItemToDOM(item));
  checkUI();
 
}


function onAddItemSubmit(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value


if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// create item DOM element 
addItemToDOM(newItem)

// Add item to local storage 
addItemToStorage(newItem)
// Key    Value
// items  ["Juice"]
// ["Juice"] looks like an array has the brackets and string inside it but it's just a stringify array. You can't store true arrays in localStorage. When we pull it out we are doing a JSON.parse and turn it back into a regular array.


checkUI()

itemInput.value = ''


} 

function addItemToDOM(item){

// Create List Item 
const li = document.createElement('li');

li.appendChild(document.createTextNode(item));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);
}


function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}


function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}



function addItemToStorage(item){
  const itemsFromStorage = getItemsFromStorage(); //initialising creating this variable
  

  
  // Then we are adding new item to an array
  itemsFromStorage.push(item)
  
  //Finally converting it to JSON string and setting set it back to local storage
  
  localStorage.setItem('items', JSON.stringify(itemsFromStorage))
  } 


function getItemsFromStorage(){

let itemsFromStorage; //initialising creating this variable
  
  if(localStorage.getItem('items') === null ){ //checking if there is no items in storage if there is not then that variable is set to an empty array.
  itemsFromStorage = []
  
  
  //if there are items in storage then we are parsing the string back to an array putting those items into the variable of itemsFromStorage   
  }else{
  itemsFromStorage = JSON.parse(localStorage.getItem('items'));
  }

  return itemsFromStorage;

  }
  

function removeItem(e){
  // console.log(e.target) //selects ul li icon
  // e.target.remove() //deletes the cross
  // console.log(e.target.parentElement) //button is the parent to the icon that was clicked
  // console.log(e.target.parentElement.classList) // we get all the different classes and remove item is one of them. We want to check to make sure that what we click on the parent has that class name.
 
if(e.target.parentElement.classList.contains('remove-item')){
// console.log('click');

// we only want this to fire off if what we are clicking on the icon whos parent is a button with a class of remove-item  


if(confirm('Are you sure you want to delete?')){ //confirm() window object window.confirm should also work.
e.target.parentElement.parentElement.remove()
}
// 1. parentElement button 
// 2. parentElement list-item 
// We are reversing the DOM to get to where we want to to manipulate it is called event delegation.

checkUI()

} 
}


function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
  clearBtn.style.display = 'none'
  itemFilter.style.display = 'none'
  }else{
  clearBtn.style.display = 'block'
  itemFilter.style.display = 'block'
  }
}


// Initialize App
function init(){
  
// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', onAddItemSubmit);
itemList.addEventListener('click', removeItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing
document.addEventListener('DOMContentLoaded', displayItems); //run when the page loads create a new event listener and put it on the document itself


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.



}

init()


// ***Remove Items From Local Storage***

const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  


function displayItems() {
  const itemsFromStorage = getItemsFromStorage();
  itemsFromStorage.forEach((item) => addItemToDOM(item));
  checkUI();
 
}


function onAddItemSubmit(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value


if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// create item DOM element 
addItemToDOM(newItem)

// Add item to local storage 
addItemToStorage(newItem)
// Key    Value
// items  ["Juice"]
// ["Juice"] looks like an array has the brackets and string inside it but it's just a stringify array. You can't store true arrays in localStorage. When we pull it out we are doing a JSON.parse and turn it back into a regular array.


checkUI()

itemInput.value = ''
} 

function addItemToDOM(item){

// Create List Item 
const li = document.createElement('li');

li.appendChild(document.createTextNode(item));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);
}


function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}


function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}

function addItemToStorage(item){
  const itemsFromStorage = getItemsFromStorage(); //initialising creating this variable
    
  // Then we are adding new item to an array
  itemsFromStorage.push(item)
  
  //Finally converting it to JSON string and setting set it back to local storage
  
  localStorage.setItem('items', JSON.stringify(itemsFromStorage))
  } 


function getItemsFromStorage(){

let itemsFromStorage; //initialising creating this variable
  
  if(localStorage.getItem('items') === null ){ //checking if there is no items in storage if there is not then that variable is set to an empty array.
  itemsFromStorage = []
  
  
  //if there are items in storage then we are parsing the string back to an array putting those items into the variable of itemsFromStorage   
  }else{
  itemsFromStorage = JSON.parse(localStorage.getItem('items'));
  }

  return itemsFromStorage;

  }

  function onClickItem(e){
    if(e.target.parentElement.classList.contains('remove-item')){


     removeItem(e.target.parentElement.parentElement) 
    }

  }
  

function removeItem(item){ //element 

  console.log(item)

  if(confirm('Are you sure?')){
    // Remove item from DOM
    item.remove();

    // Remove item from storage 
    removeItemFromStorage(item.textContent); //we don't need the actual element we need the text inside it so pass in textContent.
    checkUI()

  }
}

function removeItemFromStorage(item){ //item text
// To get the item from storage 
let itemsFromStorage = getItemsFromStorage();

// console.log(itemsFromStorage)

// Filter out item to be removed set itemsFromStorage to the filtered array.

// map(), filter() high order arrays these return a new array with the deleted item removed.

// The take a call back for each item i is not equal to the item that is being passed in should filter out any item that was passed in.  

itemsFromStorage = itemsFromStorage.filter((i)=> i !== item);

// Re-set to localStorage with the one we want to remove removed.

localStorage.setItem('items', JSON.stringify(itemsFromStorage))

}

function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

// Clear from localstorage
localStorage.removeItem('items') 
// could do localStorage.clear() but will get rid of all localStorage items in this case is fine as it is only a shopping list but for other larger projects could be a problem.

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
  clearBtn.style.display = 'none'
  itemFilter.style.display = 'none'
  }else{
  clearBtn.style.display = 'block'
  itemFilter.style.display = 'block'
  }
}


// Initialize App
function init(){
  
// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', onAddItemSubmit);
itemList.addEventListener('click', onClickItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing
document.addEventListener('DOMContentLoaded', displayItems); //run when the page loads create a new event listener and put it on the document itself


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.

}

init()




// ***Set Item To Edit Update Shopping List***

const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')
const formBtn = itemForm.querySelector('button')
let isEditMode = false; 



// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  


function displayItems() {
  const itemsFromStorage = getItemsFromStorage();
  itemsFromStorage.forEach((item) => addItemToDOM(item));
  checkUI();
 
}


function onAddItemSubmit(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value


if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// create item DOM element 
addItemToDOM(newItem)

// Add item to local storage 
addItemToStorage(newItem)
// Key    Value
// items  ["Juice"]
// ["Juice"] looks like an array has the brackets and string inside it but it's just a stringify array. You can't store true arrays in localStorage. When we pull it out we are doing a JSON.parse and turn it back into a regular array.


checkUI()

itemInput.value = ''
} 

function addItemToDOM(item){

// Create List Item 
const li = document.createElement('li');

li.appendChild(document.createTextNode(item));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);
}


function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}


function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}

function addItemToStorage(item){
  const itemsFromStorage = getItemsFromStorage(); //initialising creating this variable
    
  // Then we are adding new item to an array
  itemsFromStorage.push(item)
  
  //Finally converting it to JSON string and setting set it back to local storage
  
  localStorage.setItem('items', JSON.stringify(itemsFromStorage))
  } 


function getItemsFromStorage(){

let itemsFromStorage; //initialising creating this variable
  
  if(localStorage.getItem('items') === null ){ //checking if there is no items in storage if there is not then that variable is set to an empty array.
  itemsFromStorage = []
  
  
  //if there are items in storage then we are parsing the string back to an array putting those items into the variable of itemsFromStorage   
  }else{
  itemsFromStorage = JSON.parse(localStorage.getItem('items'));
  }

  return itemsFromStorage;

  }

  function onClickItem(e){
    if(e.target.parentElement.classList.contains('remove-item')){

      removeItem(e.target.parentElement.parentElement) 

      // Set Item To Edit
    }else{

      // console.log(1) //click anywhere in button will et a 1 in the console.

      setItemToEdit(e.target);
    }
  }
  
  function setItemToEdit(item){

   isEditMode = true; 

  //  if you click on one first item on the list then another item down that list the first itm will stay grey so to avoid this you can select all the itemlists
  
  itemList.querySelectorAll('li').forEach((i) => i.classList.remove('edit-mode'));

  item.classList.add('edit-mode');
  //  item.style.color = '#ccc'

  //change button text from Add Items to Update Item
  formBtn.innerHTML = '<i class="fa-solid fa-pen"></i> Update Item'

  //when click on the button add the text from that clicked button into the input form for edit
  itemInput.value = item.textContent; 

  //change color of button
  formBtn.style.backgroundColor = '#228B22';
  
}

function removeItem(item){ //element 

  console.log(item)

  if(confirm('Are you sure?')){
    // Remove item from DOM
    item.remove();

    // Remove item from storage 
    removeItemFromStorage(item.textContent); //we don't need the actual element we need the text inside it so pass in textContent.
    checkUI()

  }
}

function removeItemFromStorage(item){ //item text
// To get the item from storage 
let itemsFromStorage = getItemsFromStorage();

// console.log(itemsFromStorage)

// Filter out item to be removed set itemsFromStorage to the filtered array.

// map(), filter() high order arrays these return a new array with the deleted item removed.

// The take a call back for each item i is not equal to the item that is being passed in should filter out any item that was passed in.  

itemsFromStorage = itemsFromStorage.filter((i)=> i !== item);

// Re-set to localStorage with the one we want to remove removed.

localStorage.setItem('items', JSON.stringify(itemsFromStorage))

}

function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

// Clear from localstorage
localStorage.removeItem('items') 
// could do localStorage.clear() but will get rid of all localStorage items in this case is fine as it is only a shopping list but for other larger projects could be a problem.

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
  clearBtn.style.display = 'none'
  itemFilter.style.display = 'none'
  }else{
  clearBtn.style.display = 'block'
  itemFilter.style.display = 'block'
  }
}


// Initialize App
function init(){
  
// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', onAddItemSubmit);
itemList.addEventListener('click', onClickItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing
document.addEventListener('DOMContentLoaded', displayItems); //run when the page loads create a new event listener and put it on the document itself


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.

}

init()


// ***Update Item & Reset State***



const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')
const formBtn = itemForm.querySelector('button');

let isEditMode = false; 

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  

function displayItems() {
  const itemsFromStorage = getItemsFromStorage();
  itemsFromStorage.forEach((item) => addItemToDOM(item));
  checkUI(); 
}

function onAddItemSubmit(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value

if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// check for edit mode we want to take item we are editing want to remove it from local storage and then remove it from the DOM and add the the new item. We are not editing the item in localStorage you get and set. We are removing the old and putting in the new.  

if(isEditMode){

  let itemToEdit = itemList.querySelector('.edit-mode') //list item element

  removeItemFromStorage(itemToEdit.textContent) //takes in the text of the item instead li item  

  itemToEdit.classList.remove('edit-mode')

  // remove it from the DOM 
  itemToEdit.remove()
  itemToEdit = false;
}

// create item DOM element 
addItemToDOM(newItem)

// Add item to local storage 
addItemToStorage(newItem)
// Key    Value
// items  ["Juice"]
// ["Juice"] looks like an array has the brackets and string inside it but it's just a stringify array. You can't store true arrays in localStorage. When we pull it out we are doing a JSON.parse and turn it back into a regular array.


checkUI()

itemInput.value = ''
} 

function addItemToDOM(item){

// Create List Item 
const li = document.createElement('li');

li.appendChild(document.createTextNode(item));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);
}

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}

function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}

function addItemToStorage(item){
  const itemsFromStorage = getItemsFromStorage(); //initialising creating this variable
    
  // Then we are adding new item to an array
  itemsFromStorage.push(item)
  
  //Finally converting it to JSON string and setting set it back to local storage
  
  localStorage.setItem('items', JSON.stringify(itemsFromStorage))
  } 

function getItemsFromStorage(){

let itemsFromStorage; //initialising creating this variable
  
  if(localStorage.getItem('items') === null ){ //checking if there is no items in storage if there is not then that variable is set to an empty array.
  itemsFromStorage = []

  //if there are items in storage then we are parsing the string back to an array putting those items into the variable of itemsFromStorage   
  }else{
  itemsFromStorage = JSON.parse(localStorage.getItem('items'));
  }

  return itemsFromStorage;

  }

  function onClickItem(e){
    if(e.target.parentElement.classList.contains('remove-item')){

      removeItem(e.target.parentElement.parentElement) 

      // Set Item To Edit
    }else{

      // console.log(1) //click anywhere in button will et a 1 in the console.

      setItemToEdit(e.target);
    }
  }
  
  function setItemToEdit(item){

   isEditMode = true; 

  //  if you click on one first item on the list then another item down that list the first itm will stay grey so to avoid this you can select all the itemlists
  
  itemList.querySelectorAll('li').forEach((i) => i.classList.remove('edit-mode'));

  item.classList.add('edit-mode');
  //  item.style.color = '#ccc'

  //change button text from Add Items to Update Item
  formBtn.innerHTML = '<i class="fa-solid fa-pen"></i> Update Item'

  //when click on the button add the text from that clicked button into the input form for edit
  itemInput.value = item.textContent 

  //change color of button
  formBtn.style.backgroundColor = '#228B22'
  
}

function removeItem(item){ //element 

  console.log(item)

  if(confirm('Are you sure?')){
    // Remove item from DOM
    item.remove();

    // Remove item from storage 
    removeItemFromStorage(item.textContent); //we don't need the actual element we need the text inside it so pass in textContent.
    checkUI()

  }
}

function removeItemFromStorage(item){ //item text
// To get the item from storage 
let itemsFromStorage = getItemsFromStorage();

// console.log(itemsFromStorage)

// Filter out item to be removed set itemsFromStorage to the filtered array.

// map(), filter() high order arrays these return a new array with the deleted item removed.

// The take a call back for each item i is not equal to the item that is being passed in should filter out any item that was passed in.  

itemsFromStorage = itemsFromStorage.filter((i)=> i !== item);

// Re-set to localStorage with the one we want to remove removed.

localStorage.setItem('items', JSON.stringify(itemsFromStorage))

}

function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

// Clear from localstorage
localStorage.removeItem('items') 
// could do localStorage.clear() but will get rid of all localStorage items in this case is fine as it is only a shopping list but for other larger projects could be a problem.

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){

  itemInput.value = '';
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
  clearBtn.style.display = 'none'
  itemFilter.style.display = 'none'
  }else{
  clearBtn.style.display = 'block'
  itemFilter.style.display = 'block'
  }

  formBtn.innerHTML ='<class="fa-solid fa-plus"></i> Add Item';
  formBtn.style.backgroundColor = '#333'

  isEditMode = false;

}


// Initialize App
function init(){
  
// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', onAddItemSubmit);
itemList.addEventListener('click', onClickItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing
document.addEventListener('DOMContentLoaded', displayItems); //run when the page loads create a new event listener and put it on the document itself


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.

}

init()


// ***Prevent Duplicate Items***


const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter')
const formBtn = itemForm.querySelector('button');

let isEditMode = false; 

// const items = itemList.querySelectorAll('li') 
//querySelectorAll() is a nodelist similar to an array we can use the length property on it. Needs to be in the button function. When we came to the page no list items. To make it work for everytime you add a list item we have to select them inside of the checkUI() function instead of the global scope.  

function displayItems() {
  const itemsFromStorage = getItemsFromStorage();
  itemsFromStorage.forEach((item) => addItemToDOM(item));
  checkUI(); 
}

function onAddItemSubmit(e){
e.preventDefault() //since submitting a form have to call preventDefault() on the event object because we do not want the form to actually submit to the file. We want to stop it and continue with the code.   

// validate Input

const newItem = itemInput.value

if(newItem === ''){
alert('Please add an item')
return
}
// console.log('input inserted successfully')

// check for edit mode we want to take item we are editing want to remove it from local storage and then remove it from the DOM and add the the new item. We are not editing the item in localStorage you get and set. We are removing the old and putting in the new.  

if(isEditMode){

  const itemToEdit = itemList.querySelector('.edit-mode') //list item element

  removeItemFromStorage(itemToEdit.textContent); //takes in the text of the item instead li item  

  itemToEdit.classList.remove('edit-mode')

  // remove it from the DOM 
  itemToEdit.remove()
  isEditMode = false;
} else{

if(checkIfItemExists(newItem)){

alert('That item already exists!');
return;

}

}

// create item DOM element 
addItemToDOM(newItem)

// Add item to local storage 
addItemToStorage(newItem)
// Key    Value
// items  ["Juice"]
// ["Juice"] looks like an array has the brackets and string inside it but it's just a stringify array. You can't store true arrays in localStorage. When we pull it out we are doing a JSON.parse and turn it back into a regular array.


checkUI()

itemInput.value = ''
} 

function addItemToDOM(item){

// Create List Item 
const li = document.createElement('li');

li.appendChild(document.createTextNode(item));
// console.log(li) //<li>milk</li>

const button = createButton('remove-item btn-link text-red')
// console.log(button)

li.appendChild(button)
// console.log(li) 


// Add li to the DOM
itemList.appendChild(li);
}

function createButton(classes){

const button = document.createElement('button')
button.className = classes;

const icon = createIcon('fa-solid fa-xmark')
button.appendChild(icon)
return button 

}

function createIcon(classes){
const icon = document.createElement('i')
icon.className = classes;
return icon 
}

function addItemToStorage(item){
  const itemsFromStorage = getItemsFromStorage(); //initialising creating this variable
    
  // Then we are adding new item to an array
  itemsFromStorage.push(item)
  
  //Finally converting it to JSON string and setting set it back to local storage
  
  localStorage.setItem('items', JSON.stringify(itemsFromStorage))
  } 

function getItemsFromStorage(){

let itemsFromStorage; //initialising creating this variable
  
  if(localStorage.getItem('items') === null ){ //checking if there is no items in storage if there is not then that variable is set to an empty array.
  itemsFromStorage = []

  //if there are items in storage then we are parsing the string back to an array putting those items into the variable of itemsFromStorage   
  }else{
  itemsFromStorage = JSON.parse(localStorage.getItem('items'));
  }

  return itemsFromStorage;

  }

  function onClickItem(e){
    if(e.target.parentElement.classList.contains('remove-item')){

      removeItem(e.target.parentElement.parentElement) 

      // Set Item To Edit
    }else{

      // console.log(1) //click anywhere in button will et a 1 in the console.

      setItemToEdit(e.target);
    }
  }


function checkIfItemExists(item){

const itemsFromStorage = getItemsFromStorage();
// itemsFromStorage is an array. includes() runs on an array

// if(itemsFromStorage.includes(item)){

//   return true;
// }else{
//   return false;
// }

return itemsFromStorage.includes(item);

};

  
  function setItemToEdit(item){

   isEditMode = true; 

  //  if you click on one first item on the list then another item down that list the first itm will stay grey so to avoid this you can select all the itemlists
  
  itemList.querySelectorAll('li').forEach((i) => i.classList.remove('edit-mode'));

  item.classList.add('edit-mode');
  //  item.style.color = '#ccc'

  //change button text from Add Items to Update Item
  formBtn.innerHTML = '<i class="fa-solid fa-pen"></i> Update Item'

  //when click on the button add the text from that clicked button into the input form for edit
  itemInput.value = item.textContent 

  //change color of button
  formBtn.style.backgroundColor = '#228B22'
  
}

function removeItem(item){ //element 

  console.log(item)

  if(confirm('Are you sure?')){
    // Remove item from DOM
    item.remove();

    // Remove item from storage 
    removeItemFromStorage(item.textContent); //we don't need the actual element we need the text inside it so pass in textContent.
    checkUI()

  }
}

function removeItemFromStorage(item){ //item text
// To get the item from storage 
let itemsFromStorage = getItemsFromStorage();

// console.log(itemsFromStorage)

// Filter out item to be removed set itemsFromStorage to the filtered array.

// map(), filter() high order arrays these return a new array with the deleted item removed.

// The take a call back for each item i is not equal to the item that is being passed in should filter out any item that was passed in.  

itemsFromStorage = itemsFromStorage.filter((i)=> i !== item);

// Re-set to localStorage with the one we want to remove removed.

localStorage.setItem('items', JSON.stringify(itemsFromStorage))

}

function clearItems(){
// console.log('works')
// itemList.innerHTML = '';

while (itemList.firstChild){
itemList.removeChild(itemList.firstChild);

}

// Clear from localstorage
localStorage.removeItem('items') 
// could do localStorage.clear() but will get rid of all localStorage items in this case is fine as it is only a shopping list but for other larger projects could be a problem.

checkUI()
}

function filterItems(e){
  const items = itemList.querySelectorAll('li') //copied from checkUI() function to get the list items able to use it again in different functions 
  const text = e.target.value.toLowerCase(); //will give us the element the event is on which is the input and with input can use the value property
  
  console.log(text)

  // We want to loop through these items we can use forEach() because querySelectorAll is a nodeList if you used getElementsByTagName('li') it would be a HTMLCollection which you would have to wrap it in Array.from(items.forEach) which would turn HTMLCollection into an array so you can use forEach().

  items.forEach(item =>{ 
    // get the text content of each item
    console.log(item) //will give every list item that is stored as we are looping through those items <li>…</li>

    const itemName = item.firstChild.textContent.toLowerCase() //e.g. eggs firstChild is a textNode

    console.log(itemName) // get the text of each of the list e.g. "Apples", "Milk" etc. This is also the node. if we don't want the quotes "" e.g. "Milk" to be Milk you can add use textContent.

    // check match compare text with itemName so if you put e.g. a, in the filter items, and it matches the itemName it will be true if not it will be a negative 1: -1 as this is how indexOf() works. It will check to see if there is an a, anywhere not just if it begins with a.    

    if(itemName.indexOf(text) != -1){
      item.style.display = 'flex'
      // console.log(true)
    }else{
      item.style.display = 'none'
      // console.log(false)
    }
  });
  
}

function checkUI(){

  itemInput.value = '';
  
  const items = itemList.querySelectorAll('li') // everytime the function runs then we are taking the new items. 
  console.log(items)
  
  if(items.length === 0){
  clearBtn.style.display = 'none'
  itemFilter.style.display = 'none'
  }else{
  clearBtn.style.display = 'block'
  itemFilter.style.display = 'block'
  }

  formBtn.innerHTML ='<class="fa-solid fa-plus"></i> Add Item';
  formBtn.style.backgroundColor = '#333'

  isEditMode = false;

}


// Initialize App
function init(){
  
// Event Listeners (bottom of script) 
itemForm.addEventListener('submit', onAddItemSubmit);
itemList.addEventListener('click', onClickItem);
clearBtn.addEventListener('click', clearItems);
itemFilter.addEventListener('input', filterItems); //input event will also capture typing
document.addEventListener('DOMContentLoaded', displayItems); //run when the page loads create a new event listener and put it on the document itself


checkUI() // in the global scope filter and clear all button runs as the page loads will not everytime you add an item. Need to add to also the button function.

}

init()

// ***Shopping List Final***


const itemForm = document.getElementById('item-form');
const itemInput = document.getElementById('item-input');
const itemList = document.getElementById('item-list');
const clearBtn = document.getElementById('clear');
const itemFilter = document.getElementById('filter');
const formBtn = itemForm.querySelector('button');
let isEditMode = false;

function displayItems() {
  const itemsFromStorage = getItemsFromStorage();
  itemsFromStorage.forEach((item) => addItemToDOM(item));
  checkUI();
}

function onAddItemSubmit(e) {
  e.preventDefault();

  const newItem = itemInput.value;

  // Validate Input
  if (newItem === '') {
    alert('Please add an item');
    return;
  }

  // Check for edit mode
  if (isEditMode) {
    const itemToEdit = itemList.querySelector('.edit-mode');

    removeItemFromStorage(itemToEdit.textContent);
    itemToEdit.classList.remove('edit-mode');
    itemToEdit.remove();
    isEditMode = false;
  } else {
    if (checkIfItemExists(newItem)) {
      alert('That item already exists!');
      return;
    }
  }

  // Create item DOM element
  addItemToDOM(newItem);

  // Add item to local storage
  addItemToStorage(newItem);

  checkUI();

  itemInput.value = '';
}

function addItemToDOM(item) {
  // Create list item
  const li = document.createElement('li');
  li.appendChild(document.createTextNode(item));

  const button = createButton('remove-item btn-link text-red');
  li.appendChild(button);

  // Add li to the DOM
  itemList.appendChild(li);
}

function createButton(classes) {
  const button = document.createElement('button');
  button.className = classes;
  const icon = createIcon('fa-solid fa-xmark');
  button.appendChild(icon);
  return button;
}

function createIcon(classes) {
  const icon = document.createElement('i');
  icon.className = classes;
  return icon;
}

function addItemToStorage(item) {
  const itemsFromStorage = getItemsFromStorage();

  // Add new item to array
  itemsFromStorage.push(item);

  // Convert to JSON string and set to local storage
  localStorage.setItem('items', JSON.stringify(itemsFromStorage));
}

function getItemsFromStorage() {
  let itemsFromStorage;

  if (localStorage.getItem('items') === null) {
    itemsFromStorage = [];
  } else {
    itemsFromStorage = JSON.parse(localStorage.getItem('items'));
  }

  return itemsFromStorage;
}

function onClickItem(e) {
  if (e.target.parentElement.classList.contains('remove-item')) {
    removeItem(e.target.parentElement.parentElement);
  } else {
    setItemToEdit(e.target);
  }
}

function checkIfItemExists(item) {
  const itemsFromStorage = getItemsFromStorage();
  return itemsFromStorage.includes(item);
}

function setItemToEdit(item) {
  isEditMode = true;

  itemList
    .querySelectorAll('li')
    .forEach((i) => i.classList.remove('edit-mode'));

  item.classList.add('edit-mode');
  formBtn.innerHTML = '<i class="fa-solid fa-pen"></i>   Update Item';
  formBtn.style.backgroundColor = '#228B22';
  itemInput.value = item.textContent;
}

function removeItem(item) {
  if (confirm('Are you sure?')) {
    // Remove item from DOM
    item.remove();

    // Remove item from storage
    removeItemFromStorage(item.textContent);

    checkUI();
  }
}

function removeItemFromStorage(item) {
  let itemsFromStorage = getItemsFromStorage();

  // Filter out item to be removed
  itemsFromStorage = itemsFromStorage.filter((i) => i !== item);

  // Re-set to localstorage
  localStorage.setItem('items', JSON.stringify(itemsFromStorage));
}

function clearItems() {
  while (itemList.firstChild) {
    itemList.removeChild(itemList.firstChild);
  }

  // Clear from localStorage
  localStorage.removeItem('items');

  checkUI();
}

function filterItems(e) {
  const items = itemList.querySelectorAll('li');
  const text = e.target.value.toLowerCase();

  items.forEach((item) => {
    const itemName = item.firstChild.textContent.toLowerCase();

    if (itemName.indexOf(text) != -1) {
      item.style.display = 'flex';
    } else {
      item.style.display = 'none';
    }
  });
}

function checkUI() {
  itemInput.value = '';

  const items = itemList.querySelectorAll('li');

  if (items.length === 0) {
    clearBtn.style.display = 'none';
    itemFilter.style.display = 'none';
  } else {
    clearBtn.style.display = 'block';
    itemFilter.style.display = 'block';
  }

  formBtn.innerHTML = '<i class="fa-solid fa-plus"></i> Add Item';
  formBtn.style.backgroundColor = '#333';

  isEditMode = false;
}

// Initialize app
function init() {
  // Event Listeners
  itemForm.addEventListener('submit', onAddItemSubmit);
  itemList.addEventListener('click', onClickItem);
  clearBtn.addEventListener('click', clearItems);
  itemFilter.addEventListener('input', filterItems);
  document.addEventListener('DOMContentLoaded', displayItems);

  checkUI();
}

init();



// ***Asynchronous JavaScript***

// At it's core javascript is synchronous. However there are web API's we can use that give us asynchronous capabilities. Asynchronous funtionalities like callbacks and promises. We are also going to look at AJAX, XML, HTTP request object. The fetch API replaced the older XHR object, async await is after but we want look at how older AJAX works. We cover the fundamentals of javascript and how to work with a document object model (DOM) and events. Now we focus on asynchronous javascript. Events are asynchronous. 


// How javascript works at its core javascript is synchronous and is single threaded it happens one at a time. Each line of code is executed one at a time and the line before has to be done before the next one starts. It does this is on a single thread of execution.

// We talked about the execution context which contains the currently running code and everthing that aids in it's execution. It runs on the thread of execution. A single thread a process it runs one line of code at a time. 

// - Thread of Execution -

// A single sequential flow of control. Forming or following in a logical order or sequence. Each operation no matter what that is the second line of code can only happen once the first line is done. The third can only happen once the second is done and so on. 

// The thread of execution also includes the call stack and memory heap. 


// Let's look at asynchronous concepts some of the things that can help us write asynchronous code within the browser or even within node.js which is a javascript run time.


// ***Under The Hood: How Async JS Works***

// When we wait for a while for one operation or line of code to finish first before you can move on to the next second operation or line of code e.g. if we are fetching data from a server or if you are in node.js writing or reading a file those are operations that might take a while. A few seconds or milliseconds is a long time in programming. When an operation takes a while and holds up the line thats called blocking code or blocking operations and it blocks the flow of the programme until it completes, non-blocking code refers to code that does not block execution. 

// - Blocking vs. Non-Blocking Code -

// Let's look at the following code. Don't worry if you don't understand everything, but both pieces of code are reading a file using Node.js file system methods and then calculating the sum of numbers from 1 to 10.

// On the left, we are using the `readFileSync()` method. This is a blocking method. It will read the file and then move on to calculate the sum. In the console, we see the file contents and then the sum.

// On the right, we are using the `readFile()` method. This is a non-blocking, asynchronous method. It will read the file but it will not block the execution of the program by making it wait. The way it works, is it takes in a callback function and when the file is read, it will execute the callback function. In the console, we see the sum first and then the file contents, because we did not have to wait for the file to be read before calculating the sum.

// Now `readFile()` is not available to us in the browser, but there are a lot of APIs that are available that work in a similar asynchronous way.

// I'm going to show you a diagram to try and explain what happens when we write asynchronous code using these web APIs.

// The yellow box represents the `JavaScript engine`. This is the part of the browser that executes our JavaScript code. This is where our `call stack` is that executes all of our functions, etc. This is also where the `memory heap` is, which is where all of our variables and objects are stored.

// Outside of that, in the green box, we have a bunch of web APIs that are accessible to us via the browser and the `global object`. Remember, this is created during the _creation phase_ of the `global execution context`.

// If we go to the browser console and type in `window` and hit enter, you will see `setTimeout()` and `setInterval()` and a bunch of other functions that allow us to do things asynchronously.


// In addition to `setTimeout()` and `setInterval()`, we have the whole DOM API. We select elements and put event listeners on them. That's another API we have available to us. It's not part of JavaScript. When you use Node.js, you don't have access to the document object, because there is no DOM or browser in Node.js. But as you saw in the code examples, in Node, you do have access to the filesystem API, which allows you to read and write files.

// `fetch()` is another API that we have access to. It allows us to make HTTP requests. We'll be working with the fetch API quite a bit to send requests to APIs and services. This is something that a front-end developer has to know how to use, and we'll get to that soon enough.

// Right now, I just want you to understand that this is stuff provided to us by the browser environment. Now, let's talk about how they work with the JavaScript engine, which is inherently synchronous.

// Task Queue

// So we know these APIs are separate from the JavaScript engine. We know that we have the ability to go off and do something while the script continues to execute and when that something is done, we fire off a callback function. This is possible because of something called the `task queue`.

// When we call an asynchronous function such as `setTimeout()`. In the diagram it's being called from a function, but it could just as well be from the global scope. When we call it, we added a callback function as an argument. It then registers that callback and it gets added to what we call a `task queue`. This is a queue of callbacks that are waiting to be added to the call stack and executed.

// A `queue` is a data structure that follows the `first in, first out` principle. This means that the first item that is added to the queue will be the first item that is removed from the queue. In our case, the first callback that is added to the task queue will be the first callback that is executed.


// Remember, we already looked at a `stack`, which follows the `last in, first out` principle. This means that the last item that is added to the stack will be the first item that is removed. The `call stack` is an example. So both `queues` and `stacks` are data structures that are used in programming.

// Event Loop

// Any callbacks that are in the queue, have to be put on the stack to be executed. This is where the `event loop` comes in. The event loop is a process that checks the call stack and the task queue. If the call stack is empty, it will take the first callback in the task queue and add it to the call stack to be executed. When we create event listeners with `addEventListener()`, we are also adding callbacks to the task queue.

// You can think of the event loop like one of those revolving doors at the mall. It's constantly checking to see if the door is open and if it is, it will let people in. If it's not, it will keep spinning until it is. In this case, we're dealing with functions instead of people.

// Now this is also how the event loop and the task queue work within Node.js. There are different APIs and functions available, but it all works the same under the hood. Node even uses the same V8 engine that Chrome uses.


// Promises

// Now just to confuse you a little bit more, with things like event listeners and `setTimeout()`, callbacks get added to the task queue. When we work with let's say, the `fetch` API, we get a `Promise` object back, which work a little differently.

// Promises are objects that represent the eventual completion or failure of an asynchronous operation. They are a way to handle asynchronous code in a more elegant way than using callbacks. We'll be working with promises a lot in the future. The reason I'm mentioning them now is because promises create what are called `PromiseJobs` or the v8 engine calls them `microtasks`.

// Microtasks are callbacks that are added to the `microtask queue`. It works in a similar way to the task queue, but it's a separate queue and it's checked before the task queue. It has a higher priority. There are also something called `observers` that are added to the microtask queue. We'll get to those later.



// ***setTimeout & clearTimeout Functions***

// setTimeout - takes in a callback and a time to wait until that callback is executed


// example 1:

setTimeout(function(){

console.log('Hello from Callback 2nd')
// The reason why this is executed second is because this callback get's put onto the task queue and waits for the call stack to clear before it is run.




}, 0)

console.log('Hello from Global Scope 1st')


// example 2:

// named function:

setTimeout(changeText, 2000);

function changeText(){
document.querySelector('h1').textContent = 'Hello from callback'
}

// example 3:

function changeText(){
document.querySelector('h1').textContent = 'Hello from callback'
}

// clear a timeout
// need the timer id that setTimeout return
const timerId = setTimeout(changeText, 3000);
document.querySelector('#cancel').addEventListener('click', ()=>{

console.log(timerId)

clearTimeout(timerId); // pass in the timer id
console.log('Timer Cancelled');
})


// ***setInterval & clearInterval Functions***

// setInterval repeatedly call a function or execute a code snippet with a fix time delay between each call and we can define what they delay to be...

// clearInterval which will stop the interval from running.

// start color change and have the body background color keep changing every 1-2 seconds and then we click stop color change it will stop that the background from channging.

// setInterval will return an id 
// const intervalID = setInterval(()=>{});

const intervalID = setInterval(myCallback, 1000);


const intervalID = setInterval(myCallback, 1000, 'Hello'); //'Hello' you can also pass in an argument... 

function myCallback(Hello){
console.log(Hello, Date.now()) //will log the time stamp every second will not stop until we call clearInterval
}

function stopChange(){
clearInterval(intervalID)
}

document.getElementById('stop').addEventListener('click', stopChange);
  

// - background color change:


let intervalID;

function startChange(){
if(!intervalID){ //not run setInterval yet let intervalID will be undefined; 
intervalID = setInterval(changeColor, 1000); // add a value 
}
}

function changeColor(){
if(document.body.style.backgroundColor !== 'black'){
document.body.style.backgroundColor = 'black'
document.body.style.color = 'white'
}else{
document.body.style.backgroundColor = 'white'
document.body.style.color = 'black'
}
}

function stopChange(){
clearInterval(intervalID) //stop puts the id inside of it. 
}
  
document.getElementById('start').addEventListener('click', startChange);
document.getElementById('stop').addEventListener('click', stopChange);



// - random change color 

let intervalID;

function startChange(){
if(!intervalID){ //not run setInterval yet let intervalID will be undefined; 
intervalID = setInterval(changeRandomColor, 1000); // add a value 
}
}

function changeRandomColor(){
const randomColor = Math.floor(Math.random() * 16777215).toString(16); //hexadecimal
document.body.style.backgroundColor = `#${randomColor}`
} 

function stopChange(){
clearInterval(intervalID) //stop puts the id inside of it. 
}
     
document.getElementById('start').addEventListener('click', startChange);
document.getElementById('stop').addEventListener('click', stopChange);



// ***Callbacks***
// ...implement our own function that takes in a callback.

// callback example 

function toggle(e){
e.target.classList.toggle('danger')
}

document.querySelector('button').addEventListener('click', toggle) //toggle is a callback also a function and get's passed into addEventListener another function. Do not add parenthesis e.g. toggle() if you save it with a parenthesis added on to it you will get an error becuase the toggle() will get invoked because of the parenthesis that means you want to invoke the function. It doesn't wait for you to click it. In that case you get an error because e is not defined. It is trying to read target from undefined. The reason e is not defined is becuase the event was not fired of so there is no event object. 

// We wanr to create our own example of a callback. Why it is useful for asynchronous programming. Just to mention that just becuase you use a callback somewhere doesn't mean it is asynchronous. In the case of addEventListener or setTimeOut we saw it was asynchronous it get's put into the task queue the event loop moves it to the call stack.

// However a callback in the case of forEach or map on arrays those take in callbacks but it is not asynchronous those are executed right away. Just becuase it is a callback it doesn't always mean it is asynchronous.


// - create our own example of a callback normally for advanced javascript:

const posts = [
  { title: 'Post One', body: 'This is post one' },
  { title: 'Post Two', body: 'This is post two' },
];


function createPost(post, cb){ //cb callback it calls createPost adds the post to the array posts.push(post) but it does not call function getPosts() until after it is added to cb() and then waits another 1 second so all together we are waiting 3 seconds. It waits 2 seconds adds the post createPost(post, cb) calls the cb() callback waits another 1 second then shows the post.   

//Also when you are creating a post you are reaching out to a server you are making a post request a HTTP request and you are sending data to add to a database or wherever it goes...     

// To replicate this network request will use setTimeout():

setTimeout(()=>{

posts.push(post); 

cb(); //after posts.push(post) post is created going to execute cb() callback function.    

}, 2000);
}


function getPosts() { 

  setTimeout(()=>{

    posts.forEach(function (post){ 

      const div = document.createElement('div');
      div.innerHTML = `<strong>${post.title}</strong> - ${post.body}`
      document.querySelector('#posts').appendChild(div);
    });

  }, 1000); //wrap in a setTimeout because we want to mimick how this will work fetching it from a server. When you fetch from a server you are making a network request. That takes some time. It depends on many different factors your connection, your server it depends on how long it takes. It could take a couple of milliseconds to a couple of seconds.         

}

createPost({title: 'Post Three', body: 'This is post three'}, getPosts)
// getPosts() //Instead of calling getPosts() here we are going to pass it in as a callback to createPost(). When you use createPost you do not want to add the parenthesis createPost() because that will execute it right away. We want it to get executed above in cb() when it is passed in and after the posts.push(post) is created. 


// ***Crash Course On HTTP Requests***

// HTTP Requests

// So we been talking about asynchronous javascript. One of the most common task or use case for asynchronous javascript is working with back-end servers API's making requests. The way we communicate with a server, whether that is your own server you created with Node JS e.g. server-side JavaScript with Node.js, or a public API e.g. twitter API or the github API's, where you can fetch specific tweets or github repository. We do this by making HTTP requests. We interact with APIs by making HTTP requests.

// What is an HTTP request?

// HTTP stands for `HyperText Transfer Protocol`. It is the protocol that is used to send and receive data on the web. HTTP is a client-server protocol, which means requests are initiated by the client, usually the web browser and the server will respond with a specific type of response. 

// Every time that you go to a web page, your browser is making a 'get' request to the server. The server is responding with things like HTML, CSS, and JavaScript files. It will also respond with whatever is on that page like images, videos, and other media. We can also make requests to 'get' data as well as data formatted as JSON data or the outdated XML data. When we make HTTP requests from our javascript code typically what we most commonly get back is JSON data and we can use that data to display it on our page wherever we want to do with it. We can also make requests to submit data to the server we want to update a field in a database, we want to add a blog post or whatever the application is designed to do.


// Making requests from Javascript

// There is a few ways to do this but most commonly you are going to use is the fetch API which is included with the window object in the browser. There are third party tools you can use like Axios there is also an older method called AJAX or what we call the XMLHttpRequest (XHR) object. That was the original way of making HTTP requests. However these days we mostly use the fetch API. 

// Network Browser Tab

// When we fetch data using JavaScript, it is usually JSON data. If you go to your browser's developer tools `network` tab, you can see the requests that are being made to the server. You can also see the responses that are being sent back.

// JSON responses

// When you make an HTTP request from your JavaScript code, the server will respond with some data. The data can be in a variety of formats, but the most common format is `JSON`.

// `JSON` stands for **JavaScript Object Notation**. It is a way to represent data in a format that is easy for both humans and machines to read and write. We used to use XML (Which is why the X in AJAX stands for XML), but it's become more common to use `JSON` because it's easier to work with. We'll be fetching JSON data from the APIs that we'll work with. We can then use that data in our web page.

// // HTTP Methods

// When you make an HTTP request, you need to specify what kind of request you're making. There are a few different types of requests, but the most common ones are `GET`, `POST`, `PUT`, and `DELETE`. We'll mostly be using `GET` in this course.

// `GET` requests are used to fetch or retrieve data from the server. Whether that is going to a web page and getting the HTML file and everything that comes with it or making a get request from Javascript to get a set of blog posts. In fact, every time you visit a webpage, you are making a `GET` request.

// `POST` requests are used to send data to the server. When you submit a form and you submit for example a blog post it is going to make a POST request to send that data to the server and that data gets added to the database through the server code. When you submit a website form, it makes a `POST` request.

// `PUT` requests are used to update data on the server. There's also a `PATCH` method that can be used to update. You can use PUT or PATCH to update on a server.

// `DELETE` requests are used to delete or remove data on the server.

// There are other less common methods, but these are the main four. When you use the `fetch` API or `AJAX`, you can choose which type of request you want to make.


// HTTP Status Codes

// When you get the response back you are going to get specific status code. It goes by range. When you make an HTTP request, the server will respond with a status code. The status code will tell you if the request was successful or not. Status code ranges have specific meanings.

// - `100` range is just continue or processing. When the response is not done yet, but is ok up to that point. You don't work with 100 range responses very often.

// - `200` range means **success** and everything went as it should. 200 is what you want.

// - `300` range means some kind of redirect. If something is not there anymore or if something is permanently moved.  

// - `400` range means there was a client error. So if you forget to submit a form or you need a required field you might get a 400 response. So basically, it's your fault whether that is a missing field in a form or if you're unauthorized to make that request.

// - `500` range is a server error. So it's not the client's fault something went wrong on the server in the back-end code.
// Common Codes

// Here are some very common codes. These are the main codes you will run into:
// - 200: Success
// - 201: Success and something was created
// - 204: Success but no content returned e.g. deleting content and it was successfully deleted
// - 301: Permanent redirected moved
// - 400: Bad request e.g. forgetting a field
// - 401: Unauthorized e.g. access something when not logged in
// - 403: Forbidden e.g. no access 
// - 404: Resource not found
// - 500: Something wrong on server

// Read more about status codes [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).



// ***DevTools Network Tab***

// Sample HTTP Requests & The Network Tab

// The Network tab in your browser's developer tools. This is a really useful tool for debugging your code. It allows you to see what requests are being made to your server and what data is being sent back.

// I'm going to use my own website as an example, so I'll go to https://traversymedia.com and go to the developer tools. I'll click on the Network tab and then refresh the page.

// This will show us every single resource that was sent with the response from the `GET` request that was made to the server by the browser. You can see that there are a lot of resources here. There are images, CSS files, JavaScript files, and more. If you click on one of these, you can see the details of the request and response.

// If I click on one of the resources such as one of the CSS files, we can see the status code is `200`, which means `success`. We can also see the size of the file, the type of file and much more. If I click on `response`, we can see the actual CSS file that was sent back to the browser.

// Getting Data

// So that's how you can use the Network tab to see what resources are being sent back to the browser. Now, let's look at a data resource that we would typically use JavaScript to fetch data from. I'm going to use the GitHub API as an example.

// In your browser, you can go to https://api.github.com/users/bradtraversy. This is the API endpoint for my GitHub profile.

// The data will display right in the browser. I have a Chrome extension called **JSON Viewer** that makes it easier to read. If you don't have this extension, you can install it from the Chrome Web Store.

// If we click on the Network tab and refresh the page, we can see that the request was made to the server and the response was sent back. If we click on the response, we can see the data that was sent back.

// Ultimately, we would want to use JavaScript to fetch this data and use it within our project. We can do this with the `fetch API`. Before we get to fetch, I want to show you how we can do it using the `XMLHttpRequest` object. This will give us more opportunities to work with callbacks.

// ***AJAX & XHR Object***

// AJAX & XHR (XMLHttpRequest) Object

// XHR (XMLHttpRequest) is a built-in browser and allows us to make HTTP request. XML is included in the name of the object. Also AJAX stands for Asynchronous JavaScript and XML. This is because years ago when this technology was created XML was the common data format we used for HTTP this type of communication. These days you will almost never see XML as we work with JSON which is much simpler and cleaner. We are not dealing with XML even though it is in the name of these technologies.

// We can make requests to servers without having to refresh the page. This allows us make our webpages more dynamic. These days you will be using the fetch API over XHR.


// How It Works - AJAX & XHR (XMLHttpRequest) Object

// This is when we go to a webpage and we make a HTTP request and get a response. So our client (your browser) makes a request to the server and the server gives a response back demonstrated on the left of the image everytime you load the webpage.

// What AJAX and the XHR object allow us to do is make those same types of requests via JavaScript. So from our code we make a javascript call using the AJAX Engine object. It sends a request behind the scenes without refreshing the page.

// When we are dealing with AJAX or even the new fetch() API we make that request from our client (your browser) a Javasript call to the code (AJAX Engine) which will then send it forward to the server. 

// The server will send a response back in a JSON or XML data back to the AJAX Engine and we can take that response (HTML response) back to the client (your browser) and then update the DOM with that data. We can update certain parts of the page e.g. show a list of something we got from a request to an API that was connected to a database or if we submit a form using XHR or the fetch() API back to the client (your browser). This all works behind the scenes so we don't have to refresh the page.          

// Example:

// HTML a simple: 
// <ul id="results"></ul>

// movies.json (object) file:
// [
//   {
//     "title": "The Godfather",
//     "year": "1972"
//   },
//   {
//     "title": "Goodfellas",
//     "year": 1990
//   },
//   {
//     "title": "A Bronx Tale",
//     "year": 1993
//   },
//   {
//     "title": "Casino",
//     "year": 1994
//   }
// ]

// You need to know what is available in your data. You can also check by going to the console and click on the `network` tab then `fetch XHR` click on the file and then `response` which will show the output of all the data.

// AJAX & XHR (XMLHttpRequest) Object Code Example:

let xhr = new XMLHttpRequest(); // Initialise XMLHttpRequest() object

// We want to call the open method first. 

//Specify method and endpoint/URL
// xhr.open('GET', './movies.json');
xhr.open('GET', 'https://api.github.com/users/bradtraversy/repos');
//It will take in two things the type of request in this case a GET request and the URL of the API we are fetching the data from or the file './movies.json' as it in this case it is a local file.

// We want to then create an event handler for an event for onreadystatechange.

// readyState can be in 5 possible state values: 
// - 0: request not initialized
// - 1: server connection established
// - 2: request received
// - 3: processing request
// - 4: request finished and response is ready

// To access the readyState properties is with `this` keyword e.g. console.log(this)  

xhr.onreadystatechange = function (){

// console.log(this.readyState); //2, 3, 4 
// console.log(this.status); // 200

if (this.readyState === 4 && this.status === 200){

// console.log(JSON.parse(this.responseText)) 
//JSON.parse() to take a string, if you have an array that is a JSON string you want to pass it as a regular array you parse it in JSON.parse(). The output will show the data and you can do what you want with the data.   

// The movies are in the data: 
const data = JSON.parse(this.responseText)
    
// It is an array so can loop through using forEach()

// Movies File Data Example: 

// data.forEach(movie =>{

// const li = document.createElement('li');

// li.innerHTML = `<strong>${movie.title}</strong> - ${movie.year}` 

// document.querySelector('#results').appendChild(li)

// API Data Example: 

data.forEach(repo =>{

const li = document.createElement('li');
  
li.innerHTML = `<strong>${repo.name}</strong> - ${repo.description}` 
  
document.querySelector('#results').appendChild(li)
})
}
}; 

// send request
xhr.send();



// ***Joke Generator Project Challenge***

const jokeEl = document.getElementById('joke');
const jokeBtn = document.getElementById('joke-btn');

const generateJoke = () => {
  console.log('click working');

  const xhr = new XMLHttpRequest();

  xhr.open('GET', 'https://api.chucknorris.io/jokes/random');

  xhr.onreadystatechange = function () {
    // when using onreadystatechange need to remember to also use xhr.send() down below otherwise it will not work.

    if (this.readyState === 4) {
      if (this.status === 200) {
        // this.responseText is a 'string' that also looks like an object however to get an actual object we first need to JSON.parse() so it is an actual object which you can do by wrapping parse(this.responseText) this.responseText is the object itself

        // console.log(JSON.parse(this.responseText).value);

        // value is from the API you have to understand the API to know what you are getting back from the API
        jokeEl.innerHTML = JSON.parse(this.responseText).value;
      } else {
        jokeEl.innerHTML = 'Something Went Wrong (Not Funny)';
      }
    }
  };

  xhr.send();
};

jokeBtn.addEventListener('click', generateJoke);
document.addEventListener('DOMContentLoaded', generateJoke);


// ***Callback Hell***

// When making multiple request's or running multiple pieces of code in order you can sometime's run into callback hell because you have a bunch of nested callback functions. This is why `promises` were created. 

// Example of multiple nested callbacks by getting data from three .json files, actors.json, movies.json and directors.json. 

function getData(endpoint, cb){ //endpoint which will be the .json files

const xhr = new XMLHttpRequest();

xhr.open('GET', endpoint);

xhr.onreadystatechange = function (){

if(this.readyState === 4 & this.status === 200){

  // console.log(JSON.parse(this.responseText)); 
  cb(JSON.parse(this.responseText)); 
  //We want the responseText but run it through JSON.parse()
}
}

// Where we want to send it we actually want to make this random because we want to run this GET data a few times as we want to get the movies.json, actors.json and directors.json and for each time it is going to be completly random for a number of seconds between 1 and 4.      

setTimeout(()=>{
xhr.send();
}, Math.floor(Math.random() * 3000) + 1000);
// 3000 gives a number between 0 - 3000
// 1000 adds another 1000 giving between 1000 - 4000 so it will be nothing below 1000 
}

// getData('./movies.json')
// getData('./actors.json')
// getData('./directors.json')
//order of the data will be random if you want to return the data in the order that we requested it we can do that by passing in a cb above callback to get data..

// To get the order of the script we created a function (data)=>{console.log(data)}) that takes in a callback to get the order we requested..
getData('./movies.json', (data)=>{
console.log(data);
getData('./actors.json', (data)=>{
console.log(data);
getData('./directors.json', (data)=>{
console.log(data);
});





// ***Promises***

// A promise is an object that represents the eventual completion or the failure of a asynchronous operation. A promise is made like to a person that the script will complete some kind of task or operation such as fetching data from a server or some asynchronous operation, mean while the rest of the code will continue to execute so it is asynchronous non-blocking when the task is complete the promise is either fulfilled or rejected and it also prevents us from entering callback hell which is multiple nested callbacks. We normally deal with the response of a promise not writing creating promises (promise constructor) until we reach more advanced javascript. When you use the fetch API it returns a promise so you need to know what to do with that promise and how to handle it.

// Example 1 

// create a promise

const promiseVariable = new Promise((resolve, reject)=>{ //takes in two parameters resolve and reject when the promise completes and it is successful we call resolve when there is some kind of error and the promise can not be fulfilled we call reject. 
  
  //do some asynchronous task 
  setTimeout(()=>{
  
  console.log('asynchronous task complete') //2nd output 
  resolve() 

  },1000)  
  
  })
  
  //handle the promise 
  
  promiseVariable.then(()=>{ //takes in a callback function anything that we pass in to resolve ()=>{}
  
  console.log('promise consumed..')//3rd output 
  
  });
  
  console.log('Hello from global scope') //1st output immediately non-blocking did not have to wait for all the previous lines of code to run  in order to put out an ouput. The above happened in the background asynchronously it went through the microtask queue it does not go through the same task queue as most callbacks go through.



// Example 2 

const promiseVariable = new Promise((resolve, reject)=>{ 

setTimeout(()=>{
  
console.log('asynchronous task complete') 
resolve() 

},1000)  
  
})
  
//handle the promise option 1 
// can put it in a variable and call .then() on the variable:  
promiseVariable.then(()=>{ 

console.log('promise consumed..')
});
  


//handle the promise option 2
new Promise((resolve, reject)=>{ 

setTimeout(()=>{

console.log('asynchronous task 2 complete') 

resolve() 

},1000)  
    
}).then(()=> console.log('promise 2 consumed')) //can also alternatively put then() right on the promise itself 
    
console.log('Hello from global scope')
  

// Example 3 
// return some data from a promise

const promiseVariable = new Promise((resolve, reject)=>{ 

setTimeout(()=>{

console.log('asynchronous task complete') 
resolve() 
},1000)  
})

promiseVariable.then(()=>{ 

console.log('promise consumed..')

});

//handle the promise 
new Promise((resolve, reject)=>{ 

setTimeout(()=>{
  
// want to return some data from a promise to do that we pass that into resolve   
resolve({name:'bobby', age: 33}) 

},1000)  
  
// .then() we can take in name:'bobby', age: 33
}).then((user)=> console.log(user)) 
  

console.log('Hello from global scope')



// Example 4
// promise error handling 

const promiseVariable = new Promise((resolve, reject)=>{ 

setTimeout(()=>{

console.log('asynchronous task complete') 
resolve() 
},1000)  

})

//handle promise error  
const getUser = new Promise((resolve, reject)=>{ 
setTimeout(()=>{
    
let error = true;

if(!error){
      
resolve({name:'bobby', age: 33}) 

}else{

reject('Error: Something Went Wrong!')
// Uncaught (in promise) Error: Something Went Wrong! It is Uncaught so you can catch these errors by using catch()

}
  
},1000)  
  

})
  
.then((user)=> console.log(user)) 
.catch((error)=>console.log(error)) //error is whatever you passed into reject() which will get rid of that red Uncaught message in the console 
  

console.log('Hello from global scope')


// Example 5

// finally() will run no matter what whether the promise is resolved or rejected 

const promiseVariable = new Promise((resolve, reject)=>{ 

setTimeout(()=>{

console.log('asynchronous task complete') 
resolve() 
},1000)  

})


//handle promise error  
const getUser = new Promise((resolve, reject)=>{ 
setTimeout(()=>{
    
let error = true;

if(!error){
      
resolve({name:'bobby', age: 33}) 

}else{

reject('Error: Something Went Wrong!')
// Uncaught (in promise) Error: Something Went Wrong! To catch errors can use .catch()
}
},1000)  
  
})
  
.then((user)=> console.log(user)) 
.catch((error)=>console.log(error))

// finally() will run no matter what whether the promise is resolved or rejected 
.finally(()=> console.log('The promise has been resolved or rejected whether it is true or false'))  
  
console.log('Hello from global scope')


// ***Callback To Promise Refactor***

// We wrote this code a little while back when we learn't about callbacks. We have const posts array. Then we had a createPost() function that runs 2 seconds (2000) after the page loads and then a getPosts() function that gets the const posts array which runs 1 second (1000).

// What was happening before using callbacks we called createPost() then we called getPosts() however getPosts() only took 1 second (1000) and it added the two posts in the array. 

// When we ran createPosts() and added the third one the two posts in the array were already on the page so getPosts() had already run. 

// So what we did was implemented a callback (cb) so createPost(post, cb) takes in a callback and that function runs cb() immediately after we add the posts.push(post) and then we just added the getPosts as a callback into createPost({ title: 'Post Three', body: 'This is post' }, getPosts). 

// So this is how we can deal with asynchronous code. This uses callbacks but what we want to do is refactor createPost to use a `promise` instead of having to use a callback.   
    

// - Callback Example -

const posts = [
  { title: 'Post One', body: 'This is post one' },
  { title: 'Post Two', body: 'This is post two' },
];

function createPost(post, cb) {
  setTimeout(() => {
    posts.push(post);
    cb();
  }, 2000);
}

function getPosts() {
  setTimeout(() => {
    posts.forEach(function (post) {
      const div = document.createElement('div');
      div.innerHTML = `<strong>${post.title}</strong> - ${post.body}`;
      document.querySelector('#posts').appendChild(div);
    });
  }, 1000);
}

createPost({ title: 'Post Three', body: 'This is post' }, getPosts);




// - Promise (resolve) Example (Refactor change from a Callback to a Promise) -

const posts = [
  { title: 'Post One', body: 'This is post one' },
  { title: 'Post Two', body: 'This is post two' },
];

function createPost(post) { //get rid of cb

return new Promise((resolve, reject)=>{ //wrap everything in return new Promise(()=>{}) Promise takes in a function. It takes in two arguments resolve and reject.

  setTimeout(() => {
    posts.push(post);
    resolve(); //delete cb after we push the post call resolve()
  }, 2000);


}) 
}

function getPosts() {
  setTimeout(() => {
    posts.forEach(function (post) {
      const div = document.createElement('div');
      div.innerHTML = `<strong>${post.title}</strong> - ${post.body}`;
      document.querySelector('#posts').appendChild(div);
    });
  }, 1000);
}

createPost({ title: 'Post Three', body: 'This is post'}).then(getPosts); //.then now returns a promise and the way to handle a promise is with .then(getPosts) with getPosts added as a function.


// - Promise (error or reject) Example (Refactor change from a Callback to a Promise) -


// - Promise (error or reject) Example (Refactor change from a Callback to a Promise) -

const posts = [
  { title: 'Post One', body: 'This is post one' },
  { title: 'Post Two', body: 'This is post two' },
];

function createPost(post) { //get rid of cb

return new Promise((resolve, reject)=>{ //wrap everything in return new Promise(()=>{}) Promise takes in a function. It takes in two arguments resolve and reject.

  setTimeout(() => {


    let error = true;

    if(!error){

      posts.push(post);
      resolve(); 
    
    } else{
      
      reject('something went wrong');

    }   
  }, 2000);

}) 
};

function getPosts() {
  setTimeout(() => {
    posts.forEach(function (post) {
      const div = document.createElement('div');
      div.innerHTML = `<strong>${post.title}</strong> - ${post.body}`;
      document.querySelector('#posts').appendChild(div);
    });
  }, 1000);
}


function showError(error){

  const h3 = document.createElement('h3');
  h3.innerHTML = `<strong>${error}</strong>`
  document.getElementById('posts').appendChild(h3)  

}

createPost({ title: 'Post Three', body: 'This is post'})
.then(getPosts) 
.catch(showError)
//to catch a reject we need to use .catch()  



// ***Promise Chaining***

// This is used if you have a sequence of asynchronous task that you need to complete. If you have a promise that returns a value that you need to use in another promise.     

// - Example starting code 1 -

// new promise 
const promise = new Promise((resolve, reject) => { 
  setTimeout(() => {


    // we are mimicking an error with this boolean value
    let error = false;

    
    if (!error) {
      // We are resolving just a user object with a name or age
      resolve({ name: 'John', age: 30 });
    } else {
      reject('Error: Something went wrong');
    }
  }, 1000);
});

 // We are handling the promise with a .then() passing in the user because that is what is getting resolved at resolve({ name: 'John', age: 30 });
promise.then((user) => { 

    console.log(user); //logging the user in the console 
  })
  // If there is an error we are catching that error and then console.log that error
  .catch((error) => console.log(error))



// - Example starting code 2 (Promise Chaining) -

const promise = new Promise((resolve, reject) => { 
  setTimeout(() => {

    let error = false; 
    // let error = true; //will bypass .then and go to catch()
    
    if (!error) {

      resolve({ name: 'John', age: 30 });
    } else {
      reject('Error: Something went wrong');
    }
  }, 1000);
});

promise.then((user) => { 
    console.log(user); 
    return user.name //whatever you return from .then((user) i actually access another .then return user.name is going into .then((name)=>{} a chained .then and console logging name which gives John. We can do this as many time as we want... 
 
  })
  .then((name)=>{
  console.log(name)
  // let's say we want to get the user's name .length property. You can chain as many .then() as you want which is great is you have multiple asynchronous operations which will fix callback hell  
  return name.length
  })
  .then((nameLength)=>{
  console.log(nameLength)
  })

  .catch((error) => {
    
    console.log(error)
    return 12345; // x
  
  })
  .then((x)=>console.log('This will run no matter what', x)); //This will run no matter what 12345


// ***Promises vs Callback Hell***

// - Callback Example - 

function getData(endpoint, cb) {
  const xhr = new XMLHttpRequest();

  xhr.open('GET', endpoint);

  xhr.onreadystatechange = function () {
    if (this.readyState === 4 && this.status === 200) {
      cb(JSON.parse(this.responseText));
    }
  };

  setTimeout(() => {
    xhr.send();
  }, Math.floor(Math.random() * 3000) + 1000);
}

getData('./movies.json', (data) => {
  console.log(data);
  getData('./actors.json', (data) => {
    console.log(data);
    getData('./directors.json', (data) => {
      console.log(data);
    });
  });
});





// - Promise Example - 

function getData(endpoint) {

return new Promise((resolve, reject)=>{

  const xhr = new XMLHttpRequest();
  xhr.open('GET', endpoint);



  xhr.onreadystatechange = function () {

    if (this.readyState === 4 ) {

    if(this.status === 200){

  resolve(JSON.parse(this.responseText)); //resolve whatever the endpoint is getData(endpoint) e.g. movies, actors, directors

  }else{

  reject('something went wrong')
  }

  }
  };

  setTimeout(() => {
    xhr.send();
  }, Math.floor(Math.random() * 3000) + 1000);

});
}

// To use this function getData(endpoint) that returns a Promise(resolve, reject) we are going to call it and pass in the endpoint e.g. './movies.json' and instead of passing in a callback function we are going to add a .then() in that .then you can add an arrow function and have access to the movies and when you console the movies it will show the output anywhere between 1 and 4 seconds. 

getData('./movies.json')
.then((movies)=>{
console.log(movies)
return getData('./actors.json')
})
.then((actors)=>{
console.log(actors)
return getData('./directors.json')
})
.then((directors)=>{
console.log(directors)
})
.catch((error)=>{
console.log(error)
})



// ***promise.all()*** Handling Multiple Promises with promise.all()

function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText));
        } else {
          reject('Something went wrong');
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}

// I want to put the function getData(endpoint) with the return Promise(resolve, reject) => {} into a variable for the movies, actors and directors. All we are taking is the return Promise from the getData() function and putting it into const moviesPromise variable.

const moviesPromise = getData('./movies.json') 
const actorsPromise = getData('./actors.json') 
const directorsPromise = getData('./directors.json') 


// Also if you want to also add other promises you can do e.g.
const dummyPromise = new Promise((resolve, reject)=>{

resolve('Hello World');

}); 


// moviesPromise.then((movies)=> console.log(movies))  

// Promise.all() // method takes in an array [] of promises

Promise.all([moviesPromise, actorsPromise, directorsPromise, dummyPromise])
.then((data)=>{
console.log(data)
})
.catch((error)=>console.log(error));



// ***Fetch Basics***

// We been using the `XMLHttpRequest` object to make HTTP requests. A more modern simpler way that's been added to the browser to make HTTP requests is called the `Fetch API`. It is easier to use than the `XMLHttpRequest` object. It's also more powerful. 

// fetch() returns a promise. It provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP. 

// fetch() is a method that is available on the window object. Type in window in the console you'll see the fetch method and you can access it by window.fetch() but nobody does that and they just use fetch()

// The fetch() method only requires one argument, which is the URL or file path that you want to make the request to. It returns a `promise` that resolves to a `Response` object. The `Response` object contains the response from the server.


// - Example 1 (with notes) -

//returns a promise so can use the .then() 
fetch('./movies.json')
.then(response =>{ 
// with the fetch api the first promise you get back is a response object which gives us information in the console on the reponse itself. If there is an error with the file or api then in the reponse list you will see status: 404, ok is now false giving information in the response. 

console.log(response)

// We want the data the way we get the data in JSON like in most cases we use the JSON method. We have to return the response.json() method. Make sure you put your parenthesis ()

// Whatever we return from the first .then is what you're going to get as the next .then argument. 
return response.json();
})
.then((data)=>{

console.log(data)
})  


// - Example 1 (without notes) -
// Fetching a JSON file

fetch('./movies.json')
.then(response =>{ 

console.log(response)

return response.json();

})
.then((data)=>{

console.log(data)

})  


// There are other HTTP libraries that are seperate to the browser that you either have to install or include the cdnjs. A really good one is AXIOS e.g. axios.get().then(data) 

// - Implicit Return -
// You also do not have to spell out return you can use an implicit return which cleans it up the code.

// Fetching a JSON file (99% of time will be fetching from some sort of URL, server endpoint, API endpoint)
fetch('./movies.json')
.then(response => response.json())
.then((data)=> console.log(data))  


// test.txt file 

// Fetching a Text File
fetch('./test.txt')
.then(response => response.text())
.then((data)=> console.log(data)) 

 // Fetching from an API
//  With API's there are all types of endpoints when you are working with an API you really have to understand it as far as which endpoints are available what kind of data does it give you. Do you need authentication. When you need authorisation for an API you need a token or a key and then you need to send that key with your request it is not just open.          

 fetch('https://api.github.com/users/bradtraversy/repos')
.then(response => response.json())
.then((data)=> console.log(data)) 

// When you get the data you can do what you want with it..

fetch('https://api.github.com/users/bradtraversy/repos')
.then(response => response.json())
.then((data)=>  document.querySelector('h1').textContent = data.login ) 

// All of these are making GET requests if you don't specify which type of request then it is going to be a GET.




// ***Random User Mini-Project***

function fetchUser() {
  //fetch the data

  showSpinner();

  fetch('https://randomuser.me/api') //fetch the user takes in the api, url, endpoint
    //will give us a promise so we use .then() syntax and remember with the fetch api our first .then gives us the reponse object.

    .then((response) => response.json())

    // whatever is in the return response.JSON we can access it in the next .then() and that is where you want to get the data.

    .then((data) => {
      // console.log(data.results[0])

      hideSpinner();

      // pass the result in a function
      displayUser(data.results[0]);
    });
}

function displayUser(user) {
  const userDisplay = document.querySelector('#user');

  if (user.gender === 'female') {
    document.body.style.backgroundColor = 'rebeccapurple';
  } else {
    document.body.style.backgroundColor = 'steelblue';
  }

  userDisplay.innerHTML = `

  <div class="flex justify-between">
  <div class="flex">

  <img
  class="w-48 h-48 rounded-full mr-8"
  src="${user.picture.large}"
  />
  
  <div class="space-y-3">
  <p class="text-xl">
  <span class="font-bold">Name: </span>${user.name.first} ${user.name.last}
  </p>
  <p class="text-xl">
  <span class="font-bold">Email: </span> ${user.email}
  </p>
  <p class="text-xl">
  <span class="font-bold">Phone: </span> ${user.phone}
  </p>
  <p class="text-xl">
  <span class="font-bold">Location: </span> ${user.location.city} ${user.location.country}
  </p>
  <p class="text-xl"><span class="font-bold">Age: </span> ${user.dob.age}</p>
  </div>
  </div>
  </div>
  `;
}

function showSpinner() {
document.querySelector('.spinner').style.display = 'block';
}

function hideSpinner() {
document.querySelector('.spinner').style.display = 'none';
}

document.querySelector('#generate').addEventListener('click', fetchUser);

fetchUser(); //call this right away in the global scope because we want to fetch a user output right away. We also want an addEventListener on the button.




// *** Fetch Options - Method, Body Headers ***


// *** Fetch Options - Method, Body Headers - ***

// Method: HTTP method you want to use. Now we know how to make a simple GET request with the fetch API. The GET request is the default and you need to specify other requests e.g. if we want to put a POST or a PUT or a DELETE request we have to specify that as the method in the options. 

// Headers: Any HTTP headers you want to send. We have the headers option to send any custom HTTP headers that we want e.g. to specify the type of data you are sending in a POST request you would add the content type header and you can add custom headers as well. A lot of API's have authentication where you would authenticate and get some type of token that you would send in the headers to access protected pages or protected resources. 

// Body: Data you want to send. Usually to be put in a database, etc. so if you have a form e.g. recipe application and you want to add a new recipe you would make a POST request and you most likely have the data come through the form and you will put it to the body of the request to submit it to the database or whatever your backend API does or needs.           


// - Fetch Options -

// When we make a request with the fetch API, the first parameter is the URL, but we can also pass in an object as the second parameter to add options to the request.

// Some of the available options are:

// - method: The HTTP method to use, such as `GET`, `POST`, `PUT`, `DELETE`, etc. By default it is `GET`.
// - headers: An object containing any custom headers that you want to add to the request.
// - body: The data to send with the request. If you are submitting a form data for instance, you can send that data here. It can be a string, a `Blob`, a `BufferSource`, a `FormData`, a `URLSearchParams`, or a `USVString`.

// There are others as well such as `mode`, `credentials`, `cache`, `redirect`, `referrer`, `referrerPolicy`, `integrity`, and `keepalive`. You can read more about them here: (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).




// JSONPlaceholder API

// For this project and the next project, we will be using the [JSON Placeholder Fake REST API](https://jsonplaceholder.typicode.com/). This API gives us access to a bunch of different endpoints for resources like posts, users, todos, etc. 



// It is a REST API, which adheres to specific standards when it comes to HTTP methods and how the endpoint URLs are structured. REST API has CRUD functionality (Create, Read, Update and Delete). We have methods and endpoints (Create, Read, Update and Delete) /posts or from the /users or /todos or whatever resources are available in the API. We will be using the blog post resource for this. 


// For example these Methods are the REST API endpoints

- GET /posts  //**Fetch all posts**
- GET posts/1 // **Fetch a post with the ID of 1**

- POST /posts // **Add creating content we make a post request for whatever resource. So in this case a blog post and that would create a new post and you would send data along with this, we dont send data with a get request in most cases but with a POST request you are posting data to the server so you would send data to the body**

- PUT /posts/1 // **Update data in this case blog post with the id of 1 you can PUT request or a PATCH request you pass the id in the URL because you need to know which post you're updating**

- DELETE /posts/1 // **Delete request a blog post with the id of 1 and pass the id aswell**


// These methods and endpoints altogether gives CRUD functionality of (Create, Read, Update and Delete) and if you think of anything in application you have resources that have CRUD functionality e.g. facebook you can create it, read it, update it, delete it or if you submit a review on google about a company that review you can create it, read it, update it, delete it. CRUD is at the core of most applications. It's usually CRUD and authentication as in many cases you need to have an account and login and your post page is connected to that account in a relational database.  

// Now, we can make the requests, just know that the data does not actualy persist into any database. So for instance, when we make a post request, we get a successful response, however the data does not stick because it is not actually saved in the database. They can't let the pubic add any data they want. There is a tool called `JSON Server` from this developer that we can use to store data locally. We will look at that later. JSON Server is similar to JSON Placeholder made by the same developer but with JSON Server you install it on your system and run it locally, you intstall it with npm - node package manager - so this will allow the data to actually stick and have our own testing API.        





// Making a POST Request

// By default, when we pass a URL into `fetch()` it will make a `GET` request. This is what we use if we want to retrieve data from a server. But what if we want to send data to the server? We can do that by passing in an object as the second parameter to `fetch()`. This object can contain options for the request, including the `method` option.

// Let's make a POST request to the [JSON Placeholder](https://jsonplaceholder.typicode.com/) API. 

// Usually, when we make a `POST` request, we send some form data to the server to create some kind of resource like a blog post, user, etc.

// JSONPlaceholder has endpoints for creating posts, users, and comments. Let's make a `POST` request to create a new post.





// - Example POST request options of the Method, Body and Header -

// - Syntax 1 Example -

// GET /posts will get all the posts from the API and POST /posts creates one it is fine to have the same endpoint URL as long as the methods are different.

function createPost(post){

  fetch('https://jsonplaceholder.typicode.com/posts',{ // add an object
  method: 'POST', // POST request you are posting data to the server so we need to add the data in the body. We also want to stringify this because post passed in the argument of createPost(post) is a javascript object so we want to stringify it to a JSON string. You can just pass in - body: JSON.stringify (post) - but it is better to specify the exact fields that are going in.
  
  body: JSON.stringify({
    title: post.title,
    body: post.body,
  })
  })

} 




// - Syntax 2 Example -

function createPost({title, body}){

fetch('https://jsonplaceholder.typicode.com/posts',{ 
method: 'POST', 
body: JSON.stringify({
  // title: title,
  // body: body,
  // as it is the same key:value can write once. The data we want to send is usually put in a database.. 
  title,
  body

}),
// in HTTP we can send for instance the 'Content-Type' of the data we are sending using '' as there is a '- hyphen' the 'Content-Type' for JSON is application. This is the request I want to send in header. 
headers:{
  'Content-Type': 'application/json',
  token:  'abc123'  
} 
// The header will still return a promise the same way... 

}).then((reponse)=>reponse.json())
.then((data)=>console.log(data)) //the second .then has the data that it will give back to us. In most cases what you get back from a POST request is the newly created resource item blog post you usually get that back including the id that was created on the server.      
} 

// In many cases you will send a token. You will authenticate with the API, some how you send some login data if it passes, you get a token sent back and then you store that token in a local storage. Then you send that token with your request and the server can validate who you are and what you can access such as what pages, resources you can access.  

createPost({title: 'My post', body: 'This is my post'})

// So in the console we get back an object with the title and the body that we sent and also recieved in an additional id. The code gets sent to the server and the server sent this back to us in a promise. The id is 101 because in the API it has 100 posts and we added an extra blog 101. The thing is with JSON Placeholder whenever you make a POST request even if I make another one it will always be 101 because it doesn't actually get added to the database as the blog is stored on JSON Placeholder servers it doesn't just let anyone add to the database. However it does send us a response as if it was a real API only.            


// The `body` option is where we send the data to the server. We can send any kind of data here, but we need to make sure that the server know's what kind of data we are sending. We do this by setting the `Content-Type` header to the appropriate value. In this case, we are sending JSON data, so we set the `Content-Type` header to `application/json`. We also need to make sure that the data is in the correct format. In this case, we need to convert the data to a string using `JSON.stringify()`.

// We can also add any custom headers that we wanted. For instance, the API may require you to authenticate and get a token and then send that token with a request to access a protected route.

headers: {
    'Content-type': 'application/json; charset=UTF-8',
    'token': 'abc123'
  }

          
// The server will respond with the data that we sent, but it will also add an `id` property to the object. This is the ID of the new post that was created.

// Output in Console 

// {title: 'My post', body: 'This is my post', id: 101}
// body:"This is my post"
// id:101
// title:"My post"
// [[Prototype]]:Object


// - Syntax 3 Example (clean code notes above) -

function createPost({ title, body }) {
  fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({
      title,
      body,
    }),
    headers: {
      'Content-Type': 'application/json',
      token: 'abc123',
    },
  })
    .then((response) => response.json())
    .then((data) => console.log(data));
}

createPost({ title: 'My Post', body: 'This is my Post' });


// If you open your DevTools and go to the `Network` tab, you will see all of the info about the request and response including the headers, payload, status and response. When you click on the POST and status says 201. The 200 range means successful and 201 specifically means created. When clicking on the post you see it has headers there is response and request headers, response comes from the server and request is what we did in the code. When you scroll down to request headers you will see the content-type that we sent application.json and we should see our token abc123, it is in alphabetical order, so the server can use this and authenticate us. The server could be Node JS with express or it could be Python with Django. It will usually be some kind of framework that handles rest API.

// We can also view the Response tab that will show the data. The Preview tab will preview the data. The Payload tab is the data that we sent from our code which was the title and the body, the id is not showing in the Payload because this represents us sending a bundle of data from our code to the server that is known as Payload.   





// ***Typicode Todos Mini-Project - Part 1***

// - Example 1 Code -

//global as will use in multiple places.. 
const apiURL = 'https://jsonplaceholder.typicode.com/todos'

const getTodos = ()=>{

//?_limit=5 will only work for this API as there is an option oit will not work on other API's.

// fetch will give us a promise..
fetch(apiURL + '?_limit=5')
.then(response => response.json()) //return response.json()
.then((data) => { //get data from API
// console.log(data) // (remember this is an array of objects) 

// I want to put this into the DOM inside the HTML <div id="todo-list"></div> 

// loop forEach array of todo objects we are looping through each object
data.forEach((todo) => { 


const div = document.createElement('div');
div.appendChild(document.createTextNode(todo.title));

if(todo.completed){ //completed from the api will be a boolean if true then add class of done from HTML to change background color
div.classList.add('done') // there is also add(), remove(), toggle(), replace()
};

// Custom Attribute 

// Also want to add a custom attribute to each one that has the id so I can access that later on when I need ot remove it. A normal attribut would be written div.setAttribute('src') but for a custom attribute you should prefix it with data dash e.g. 'data-id' becuase later on we need to access it we can use a property called dataset.

// name of the attribute is 'data-id', the value is going to be todo.id 
div.setAttribute('data-id', todo.id)
// so if you go to the console and the elements tab and look at the output you will be able to see that they all have this data-id with the id as the attribute value e.g. <div data-id="1">delectus aut autem</div>

document.getElementById('todo-list').appendChild(div)


})
}) 
}
getTodos()



// So before we add the functionality to make a POST request and add a todo. I want to put all this into a function called addTodoToDOM because we are going to do the same thing when we create a new one. 

const div = document.createElement('div');
div.appendChild(document.createTextNode(todo.title));

if(todo.completed){ 
div.classList.add('done')
};

div.setAttribute('data-id', todo.id)
document.getElementById('todo-list').appendChil(div)





// - Example 2 (new code from the start with function addTodoToDOM) -

const apiURL = 'https://jsonplaceholder.typicode.com/todos'

const getTodos = ()=>{

fetch(apiURL + '?_limit=5')
.then(response => response.json()) 
.then((data) => { 

data.forEach((todo) =>  addTodoToDOM(todo)) //delete curly braces {} and just call addTodoToDOM(todo) and pass in the todo which should give is the same result
}) 
};


const addTodoToDOM = (todo) =>{ //add todo in parenthesis now we can use this function wherever we want..

  const div = document.createElement('div');
  div.appendChild(document.createTextNode(todo.title));
  
  if(todo.completed){ 
  div.classList.add('done') 
  };
  
  div.setAttribute('data-id', todo.id)
  
  document.getElementById('todo-list').appendChild(div)

}


// Now we want to create so addEventListener to that form. Make a function called init which will have our event listeners in there and our getTodos() and fire off init() when the page loads. 

const createTodo = (e)=>{ //pass in our event listener (e)
e.preventDefault() // stop the preventDefault behaviour

console.log(1) //we type in the input and click we get an output of 1 as a tester. We need to get the value of the input there is a few ways we could do that, we could select the input from the DOM and get .value of the input but as we have access to the form which is e.target. We click on the button and we get the form e.g. <form id="todo-form">…</form> so we want to get the first element in the form which is this input.  

// console.log(e.target.firstChild); //#text node remember firstChild is going to give us all of the nodes not just the elements and even if there is a line break in the HTML, like in this case, the line break will actually count as a text node so we want to use firstElementChild which will only look at element nodes. 

// HTML Example
// <form id="todo-form"> //line break counts as a text node
// <input type="text" id="title" placeholder="Add Todo..." /> //first child
// <button type="submit">Add</button>
// </form>


// now we get access to the input <input type="text" id="title" placeholder="Add Todo..."></input> we want the value so add .value now whatever you type in the input and click you will get the same output.

// we want this part of an object so we create a variable newTodo this is what we want to send to the server. The title: is whatever will be typed into the input text box.     

const newTodo = {

title: e.target.firstElementChild.value,
completed: false
//  The completed value is set to false so whenever we add a new todo it is automatically going to be false. 
}; 

// We need to make a POST request with const newTodo = {} as the body, examples and explanations in previous notes.  

fetch(apiURL, {  // it is /todos from the global url above because we are making a POST request you don't put any id because it doesn't exist yet we are creating it. 

//lets pass in our options ,{}
method: 'POST',
body: JSON.stringify(newTodo), //we want to send this as a JSON string and pass in the newTodo object and that will be sent to the body 

// header we are going to add an object of Content-Type  
headers: {
'Content-Type': 'application/json'  
},
})
.then(response => response.json())
.then(data => addTodoToDOM(data)) 

//first .then() takes in our response object and then returns response.json

//second .then() that's going to have the data return which is going to be the new object what we want to do is add it to addTodoToDOM function which pass in the data which returns the data that you added. 
};

const init = ()=>{
  // getTodos(); we can even put it in an addEventListener and call getTodos
  document.addEventListener('DOMContentLoaded', getTodos)
  // let's addEventListener to create a form from HTML id of #todo-form we then want to listen for a submit event to a function called createTodo which is made above..
  document.querySelector('#todo-form').addEventListener('submit', createTodo)
}

init();

// We are not just calling the function const newTodo = {} when we submit the form and then having that newTodo added to the DOM. What we are doing is making a request fetch(apiURL, {} sending it to the server where usually it gets added to a database and then when that is done and added to the server .then(data => addTodoToDOM(data)) we are adding it to the adding it to the DOM addTodoToDOM() 

// In the output when you type in the input anything e.g. MyToDO click on the button it gets added to the DOM. Also if you go to the Network tab you will be able to see that you made a request e.g. todos?_limit=5 this request is the GET that we fetched with a status of 200 the next is the 'POST' with a status of 201 if you click it and check the Headers tab you can see you made a 'POST' request in the Response tab was the object with the output. The id is 201 because there is 200 /todos exisitng in the API's and the next one we add is 201. It will always be 201 as it does not stick to the database. If it was a real API it will be 202 and so forth. In reality you will be working with your own API that you create in Node JS or you will be working with a public API where you can actually post items.  

// {
//   "title": "myTodo",
//   "completed": false,
//   "id": 201
// }    


// ***Typicode Todos Mini-Project - Part 2***
// We want to click on the text boxes and toggle the done class to make it darker and that will also make an update to the server to be completed true or completed false     

const apiURL = 'https://jsonplaceholder.typicode.com/todos'

const getTodos = ()=>{
fetch(apiURL + '?_limit=10')
.then(response => response.json()) 
.then((data) => { 
data.forEach((todo) =>  addTodoToDOM(todo)) 
}) 
};


const addTodoToDOM = (todo) =>{ 
  const div = document.createElement('div');

  div.classList.add('todo') //when you go to elements they should all have a class of todo whether it has done or not which means you can now target in toggleCompleted. 

  div.appendChild(document.createTextNode(todo.title));
  
  if(todo.completed){ 
  div.classList.add('done') 
  };
  
  div.setAttribute('data-id', todo.id)
  
  document.getElementById('todo-list').appendChild(div)
}


const createTodo = (e)=>{ 
e.preventDefault() 

console.log(1)     

const newTodo = {

title: e.target.firstElementChild.value,
completed: false
}; 


fetch(apiURL, { 

method: 'POST',
body: JSON.stringify(newTodo), 

headers: {
'Content-Type': 'application/json'  
},
})
.then(response => response.json())
.then(data => addTodoToDOM(data)) 
};


const toggleCompleted = (e) => {

if(e.target.classList.contains('todo')){
//contains() gives a true false value. Also we are clicking on one of the divs that has the class of todo from addTodoToDOM   div.classList.add('todo'). Then we want to toggle. So when we click on div text boxes it will toggle and when you click around it on the ul nothing now happens which is what we want.

e.target.classList.toggle('done') //done from div.classList.add('done') and color styled in css. Also since the event listener is on the ul it also changes color on the whole thing. We are not using an an unordered list so we can't use event delegation by targeting if the tag name is a list item because they are not list items, they are just divs. So where we addTodoToDOM I'm going to add a class that we can target.


// console.log(e.target.dataset.id); //item 1, 2, 3 etc. If you add a new item in the input and you click on it you will get 201

updateTodo(e.target.dataset.id, e.target.classList.contains('done'));
}
};


const updateTodo = (id, completed)=>{ //id because we want to know the id of the todo we are updating also if it is completed. The id we can get from ddTodoToDOM function div.setAttribute('data-id', todo.id). If you check in elements console output you will see it has a data-id. To get it you can updateToDo(e.target.dataset.id) which is the e.target item you click on which is the todo and you can get that data-id by using .dataset and whatever the attribute is which is .id;  

console.log(id, completed)

//url api backticks as we need to include the id 
fetch(`${apiURL}/${id}`, {
method:'PUT',
body: JSON.stringify({ completed }), 
headers: {
'Content-Type': 'applications/json' 
}

})
// .then(response => response.json()) //response object
// .then(data => console.log(data))
}


const deleteTodo = (e)=>{

  if(e.target.classList.contains('todo')){

    console.log('delete')

    const id = e.target.dataset.id 
    // dataset is a DOM property to access and set the data attribute using JavaScript elements. It is an interface to create, delete, handle, and maintain data of the application.

    // console.log(id) //delete id e.g. 1

    fetch(`${apiURL}/${id}`, {
      method: 'DELETE'
    })
    .then(response => response.JSON)
    .then(()=> e.target.remove()) //remove from the DOM. In response Network you see an empty object.   
    }
}


const init = ()=>{
 document.addEventListener('DOMContentLoaded', getTodos)
 document.querySelector('#todo-form').addEventListener('submit', createTodo)

 //  We are going to use event delegation meaning we are going to add the event listener to the todo list div in HTML <div id="todo-list"></div> as we are not going to add an event listener to every single text box.
 document.querySelector('#todo-list').addEventListener('click', toggleCompleted)
 document.querySelector('#todo-list').addEventListener('dblclick', deleteTodo)
}

init();



// ***Fetch API Error Handling***

// Sometimes the server will send back an error that is not a 200 status or a 404 not found or a 401 not authorised. We need to check for errors when it somes to the status codes. The website httpstat.us is great to hit urls to get whatever type of response we want. Tou can use it to test with and experiment with different status. 

// Success

fetch('http://httpstat.us/200') //endpoint
.then((response)=>{
return response
})
.then(()=>{
console.log('success')
})



// The issue here is that the 'success' shows and the .catch() does NOT run for an error status like 404 or 500. The issue here is that the 'success' shows and the .catch() does NOT run for an error status like 404 or 500. Have to check for the response yourself. There is third party library called AXIOS which does work if you hit an error that is not in the 200 range then your .catch does work. With the fetch API it is a little more manual you have to check for the error respoonse.

fetch('http://httpstat.us/404') 
.then((response)=>{
return response
})
.then(()=>{
console.log('success')
}).catch(error =>{
console.log(error)

})


// Catch ONLY runs on a Network Error

//fake url will not run we will not see a console.log success .catch will run with output of TypeError: Failed to fetch at script.js:syntax error line.

fetch('http://abc123.net') 
.then((response)=>{
return response
})
.then(()=>{
console.log('success')
}).catch(error =>{
console.log(error)
})


// Test with response.ok

// - option 1 - 

fetch('http://httpstat.us/404') 
.then((response)=>{
console.log(response.status) //404
console.log(response.ok) //false
console.log(response.statusText) //Not Found
return response
})
.then(()=>{
console.log('success')
}).catch(error =>{
console.log(error)
})

// - option 2 -

fetch('http://httpstat.us/404') 
.then((response)=>{

if(!response.ok){
//true or false anything outside of the 200 range
  
throw new Error('Request Failed')
// throw statement allows you to create a custom error
} 
return response
})
.then(()=>{
console.log('success') //we don't see success does not run code will halt
}).catch(error =>{
console.log(error) // catch does run throw new Error is passed into .catch(error)n which is Error('Request Failed')
})


// Check for specific code

fetch('http://httpstat.us/200') //change code 
.then((response)=>{

  if(response.status === 404){
  throw new Error('Not Found')

  }
  else if(response.status === 500){
  throw new Error('Server Error')
  }
  else if(response.status !== 200){
    throw new Error('Request Failed') 
  }

return response
})
.then(()=>{
console.log('success') 
}).catch(error =>{
console.log(error) 
})




// ***Async & Await***


// Alternate way to consume promises instead of the .then() syntax using Async & Await. It is up to you if you want to use Async & Await over the .then. Most developers use Async & Await. It is cleaner as it reads like synchronous code top to bottom you don't have .then and .catch which take in functions.

const promise = new Promise((resolve, reject) =>{

setTimeout(()=>{

resolve({name: 'John', age: 20})
}, 1000)
});

//we are not using fetch API so we are not getting the response first then the data we will get the data immedietly   

// promise.then(data=>console.log(data));

// Async & Await it has to be in a function that is asynchronous. We will normally be in a function unlikely it will be in a global scope like in promise.then(data=>console.log(data)).

async function getPromise(){
const response = await promise // we have to use await as it is an asynchronous operation os we have to await on it to be complete when it is it will be put into the response varaible const response = await promise. 

console.log(response)
}

// getPromise()


// fetch API (two promises one with the response object and then we return the response.json method and we get the data)

// Example 1 

async function getUser(){

  // We need to have await becuase fetch is a promise which does not execute right away so you need to wait for it.   
  const response = await fetch('https://jsonplaceholder.typicode.com/users'); 

  // There is no .then because we are using await at the fetch request when we get that response it will be store in the variable const reponse.
  
  // Also remember there is also another promise with the data..
  
  const data = await response.json();
  console.log(data);
}


getUser() 



// Example 2 (using .then())

function getUser(){ 
const response = fetch('https://jsonplaceholder.typicode.com/users').then(response => response.json().then(data => console.log(data))) 
console.log(data);
}

getUser() 



// Example 3 (arrow function)

const getPosts = async ()=>{


  const response = await fetch('https://jsonplaceholder.typicode.com/posts'); 
  
  const data = await response.json();
  console.log(data);
}

getPosts()





// ***Try...Catch Statements***


// syntax that allows us to write specific code if an error occurs and specific code if there is no error. It is usually how we handle errors with async & await. When we used .then() we could use the .catch()..you can also still use .catch() with async & await but it defeats the purpose so for async & await we use a try..catch statement.     

// console.log(x) 
// Uncaught ReferenceError: x is not defined


try{
console.log(x)
}catch(error){
console.log('Error' + error)
// ErrorReferenceError: x is not defined. It is no longer a Uncaught ReferenceError.  
}

// You don't want to just use fill your code with try catch blocks that you don't just need. Only should use if you are writing code that may result in an error and you want to handle that error.  

// we can throw out own errors, example:

function double(number){

if(isNaN(number)){
throw new Error(number + ' is not a number');

}

return number * 2;

}


try {
// const y = double(1); //2
const y = double('hello'); //Error: hello is not a number
console.log(y);
} catch (error) {

console.log(error)

}


// ***Error Handling With Async & Await***


// Example 1 

const getUsers = async ()=>{

try {
  
const response = await fetch('https://jsonplaceholder.typicode.com/users')

const data = await response.json();

console.log(data)

} catch (error) {
  console.log(error)
  // ReferenceError: response is not defined. If it was not within the try catch it will say Uncaught ReferenceError.
}
}

getUsers()


// Example 2 

const getUsers = async ()=>{

try {
  
// An error does not get thrown automatically if you hit a status 404 or 500 so you hav to handle that yourself.

const response = await fetch('http://httpstat.us/404')

if(!response.ok){

throw new Error('Request Failed')

}

const data = await response.text(); // It gives a text file instead of response.json(). It is just what is in the text file the code still runs even though it is an error so you normally do not want to run the rest of your code if you hit a 404 or 500. You want to throw an error so this is where you handle this yourself by if(!response.ok){throw new Error('Request Failed')} which no longer displays the text await response.text() console.log(data) it is going right to the catch and logging Error('Request Failed')

console.log(data)

} catch (error) {
  console.log(error)
  // ReferenceError: response is not defined. If it was not within the try catch it will say Uncaught ReferenceError.
}
}

getUsers()


// Example 3 (not a preferred option)

const getPosts = async ()=>{
    
// const response = await fetch('https://jsonplaceholder.typicode.com/posts')
const response = await fetch('http://httpstat.us/500')

if(!response.ok){
throw new Error('Request Failed')
}

const data = await response.text(); 
console.log(data)
}

// getPosts()
// Uncaught (in promise) Error: Request Failed does not pick up if(!response.ok){throw new Error('Request Failed')} as there was no catch() where you have to handle the 404 or 500 by yourself. 
    
getPosts().catch(error => console.log(error)) 
// Error: Request Failed picks up if(!response.ok){throw new Error('Request Failed')}












// ***Multiple Promises With Async & Await***

// Example 1 

function getData(endpoint) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', endpoint);

    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText));
        } else {
          reject('Error: Something went wrong');
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}

// getData('./movies.json')
//   .then((movies) => {
//     console.log(movies);
//     return getData('./actors.json');
//   })
//   .then((actors) => {
//     console.log(actors);
//     return getData('./directors.json');
//   })
//   .then((directors) => {
//     console.log(directors);
//   })
//   .catch((error) => console.log(error));


async function getAllData() { //asynchronous
const movies = await getData('./movies.json'); //getAllData() function returns a promise  
// console.log(movies)

const actors = await getData('./actors.json'); 
// console.log(actors)

const directors = await getData('./directors.json'); 
// console.log(directors)


console.log(movies, actors, directors) //all pop in the console all together when waiting until the end to console.log

console.log(123) // Here it is synchronous as you will have to wait for await getData('./movies.json'), await getData('./actors.json') and await getData('./directors.json') to run first before you see console.log(123). 

}
getAllData()

// console.log(123) // Here outside of the getAllData() function the console.log(123) is  will run and show an output first before the getAllData() because getAllData() is asynchronous and is going through that process of a callback through the micotask queue then into the call stack but any code after e.g.console.log(123) will run..  


// - Example 2 - 
// (fetch data by using async & await using fetch API and skip using the getData function with xhr)

function getData(endpoint) {
return new Promise((resolve, reject) => {
const xhr = new XMLHttpRequest();
xhr.open('GET', endpoint);

xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(JSON.parse(this.responseText));
        } else {
          reject('Error: Something went wrong');
        }
      }
    };

    setTimeout(() => {
      xhr.send();
    }, Math.floor(Math.random() * 3000) + 1000);
  });
}

// getData('./movies.json')
//   .then((movies) => {
//     console.log(movies);
//     return getData('./actors.json');
//   })
//   .then((actors) => {
//     console.log(actors);
//     return getData('./directors.json');
//   })
//   .then((directors) => {
//     console.log(directors);
//   })
//   .catch((error) => console.log(error));


// (Start Here: fetch data by using async & await using fetch API and skip using the getData function with xhr)


async function getAllData() { 
const movies = await getData('./movies.json'); 
const actors = await getData('./actors.json'); 
const directors = await getData('./directors.json'); 

console.log(movies, actors, directors) 
}



async function getAllDataWithFetch(){

  const moviesResponse = await fetch('./movies.json')
  const movies = await moviesResponse.json()

  const actorsResponse = await fetch('./actors.json')
  const actors = await actorsResponse.json()

  const directorsResponse = await fetch('./directors.json')
  const directors = await directorsResponse.json()

console.log(movies, actors, directors)
}




async function getAllDataPromiseAll(){ // promise all (with fetch)

const [moviesResponse, actorsResponse, directorsResponse] = await Promise.all([
// takes in an array of promises you want to execute. What we did before we put in our get data calls in the array and used .then and then you get an array of promises that you get back as the data. With fetch it is a little different we have to get the response then we get the data. So we pass in the array each fetch call. 

//promise with the response object
fetch('./movies.json'), 
fetch('./actors.json'),
fetch('./directors.json'),

// const [moviesResponse, actorsResponse, directorsResponse] pulls out the promise that the fetch('/movies.json') gives us which is the response. So we have the response object fetch('/movies.json') from the fetch requests in the variables const [moviesResponse, actorsResponse, directorsResponse].
]);

// without await it is a promise if you want to actually get the data from it then we have to await or do a .then() either works. 
const movies = await moviesResponse.json();
const actors = await actorsResponse.json();
const directors = await directorsResponse.json();

console.log(movies, actors, directors);
}

// getAllData()
// getAllDataWithFetch();
getAllDataPromiseAll();





// - .then Example 3- 

async function getAllDataPromiseAll2(){

const [movies, actors, directors] = await Promise.all([

fetch('./movies.json').then(response => response.json()), 
fetch('./actors.json').then(response => response.json()),
fetch('./directors.json').then(response => response.json()),

]);
 
console.log(movies, actors, directors);
}


// getAllData()
// getAllDataWithFetch();
// getAllDataPromiseAll();
getAllDataPromiseAll2();




// ***github***

// Github Setup 
// Download
// https://git-scm.com/download/win
// Will host your repository remotely.

// Github version control system allows you back up code, version your code, go back in time and revert back changes, collaborate with other developers. Other developers can clone your code or pull merge requests. Needed for both storage, versioning and collaboration in development.

// Git Bash 
// https://support.atlassian.com/bitbucket-cloud/docs/configure-your-dvcs-username-for-commits/

// New Setup
// git config --global user.name "osman ijaz"
// $ git config --global user.email osmanijaz@outlook.com
// git config --list



// https://github.com/osmanijaz/reactjs_boilerplate
// git init
// git add README.md
// git commit -m "first commit"
// git branch -M main
// git remote add origin https://github.com/osmanijaz/reactjs_boilerplate.git
// git push -u origin main


// Initialise your project as a git repository because you will have local repository that resides on your machine.


// Terminal:
// Type: local repository
// git innit (creates hidden folder called .git)
// ls -a (LS list the content of the folder -a shows all files) 
// git add . (. represents all files does not commit to the repository just yet it holds it in a staging area, can also add individual files: git add style.css index.html)
// git status (show you what is in your staging area not yet committed)
// git commit -m ‘ ‘ (simple comment to represent what this commit is e.g. ‘initial commit’ now it is in the repository)
// git status (nothing to commit working tree clean nothing in the staging area)

// remote repo
// The next step now that it is in the local repository is to push it to a remote repo like github. Create an account login:
// new repository 
// enter repository name (also your url)
// description
// public or private
// read me file 
// .getignore file (specify which files and folders you don’t want in the repository e.g. if you have a file that has passwords you would not want that in a public repo)
// create repository button


// Terminal
// ssh-keygen (enter will create two files id_rsa and public one .pub can customise name by copying full path)
// users/osmanijaz/.ssh/id_rsa_anynamehere
// passphrase enter if do not want a passphrase then enter again and will generate ssh keygen
// ls ~/ssh (will show your new created files also .pub one which is the one you want to put on github)

// cat (may not work in terminal windows but will work in bash) 
// cat ~/ssh/id_rsa_anynamehere.pub (show up in your terminal copy it correctly starting from ssh-rsa and ends with .local) 

// once copied go to github settings SSH and GPG keys
// New SSH Key
// Title
// Key (paste in key)
// Add SSH Key

// Can NOW push your code to github:
// paste in: 
// git remote add origin git@github.com:osmanijaz/anynamehere.git
// git branch -M main (git you have branches the main master branch you can create different branches e.g. separate functionality like a login and then create a branch called login work on it and when you are ready it is done you can merge it with the main branch)

// git push -u origin main (command for first push specify -u origin to github after you will use git push)
// check if it loaded output

// If it says public key denied you can check by:
// eval `ssh-agent` (agent pid)
// ssh-add ~/  .ssh/id_rsa_anynamehere (location of your private key, should say your identity is added so you can try to push it again) 
// git push -u origin main

// once you have done your initial push you can just use:
// git push (you do have to of course add your code or whatever you are adding to the staging area then commit it and then push it)

// adding readme.md (md – markdown - extension) file in vs studio code
// extention: Markdown Preview Enhanced Extension 
// readme.md (markdown language to format text) # (header)
// git status (show the readme.md file)
// git add . (add to the staging area use . for all files)
// git commit -m ‘added readme’ 
// git push 
// check output in repository 

// how much you want to commit (can be after every functionality up to you)

// - Flixx Move App gitbub Setup Project -

// go to https://github.com/ > your repositories > new > Owner/ Repository name * anynamehere e.g. filxx-app > Description e.g. Vanilla JS Movies & TV Shows Application > public or private > click button create repository

// Go to VS Code integrated terminal type:

// git init > 
// git add . > 
// git commit -m 'anyname' e.g. 'initial commit and theme' > 
// from github copy: git remote add origin https://github.com/osmanijaz/flixx-app.git > 
// from github copy: git branch -M main > 
// from github copy: git push -u origin main >
// refresh page in github and you should see the repository files (you can Add a README file if required) 
// make commit as you go along: git commit -m "git commit message example"


// - update file to github -
// git branch 
// git status
// git add . (if not on git)
// git status (check status) 
// git commit -m 'anyname update file'
// git push origin main (main name of file tells you bottom of vs code left hand side)





// ***Flixx Move App Project***


// ***Page Router & Active Link***

// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);


// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
console.log('Home');
break; 
case '/shows.html':
console.log('Shows');
break;
case '/movie-details.html':
console.log('Movie Details');
break;
case '/tv-details.html':
console.log('TV Details');
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);





// ***Display Popular Movies***

// To get the popular movies by making a fetch request to the movie database get the popular movies and display them on the page. Lets create a function that we can use from within other functions to fetch data rather than calling fetch from every function where we need it.


// console.log(window.location.pathname) // url file name e.g. shows.html
const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);



// 2. Display Movies in DOM
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card'); //delete <div class="card"></div> as now created here in javascript
div.innerHTML = 
          `
          <a href="movie-details.html?id=${movie.id}">
          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            :`<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})
}


// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
// Register your key at https://www.themoviedb.org/settings/api and enter here. 
// Only use this for development or very small projets. You should store your key and make requests from a server.
const API_KEY = 'd96b5b45e8d9fb560bbbc147b6150838'; 
const API_URL = 'https://api.themoviedb.org/3/'; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

return data; //call this from a function to get the popular movies from the homepage  
}




// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displayPopularMovies(); //calling the function here to display movies in the DOM
break; 
case '/shows.html':
console.log('Shows');
break;
case '/movie-details.html':
console.log('Movie Details');
break;
case '/tv-details.html':
console.log('TV Details');
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);






// ***Spinner & Popular TV Shows***
// Also the ability to show and hide the spinner so need to create two additional functions.
// Add the TV Shows. 

// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`


          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})
}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
  
  
            <a href="tv-details.html?id=${show.id}">
  
            ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            
            }
           
            </a>
  
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = 'd96b5b45e8d9fb560bbbc147b6150838'; 
const API_URL = 'https://api.themoviedb.org/3/'; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM
break;
case '/movie-details.html':
console.log('Movie Details');
break;
case '/tv-details.html':
console.log('TV Details');
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()

}

// init()
document.addEventListener('DOMContentLoaded',  init);




// ***Movie Details Page***


// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`
<a href="movie-details.html?id=${movie.id}">
${movie.poster_path
  ?`
  <img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
  />` 
  }
         
  </a>
  <div class="card-body">
  <h5 class="card-title">${movie.title}</h5>
  <p class="card-text">
  <small class="text-muted">Release: ${movie.release_date}</small>
  </p>
  </div>
  </div>
  `;

  document.querySelector('#popular-movies').appendChild(div)

})
}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
  <a href="tv-details.html?id=${show.id}">
  ${show.poster_path
    ?`
    <img
    src="https://image.tmdb.org/t/p/w500${show.poster_path}"
    class="card-img-top"
    alt="${show.name}"
    />`
    : `<img
    src="images/no-image.jpg"
    class="card-img-top"
    alt="${show.name}"
    />` 
    }
           
    </a>
    <div class="card-body">
    <h5 class="card-title">${show.name}</h5>
    <p class="card-text">
    <small class="text-muted">Air Date: ${show.first_air_date}</small>
    </p>
    </div>
    </div>
    `;
  
    document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);

const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 




// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = 'd96b5b45e8d9fb560bbbc147b6150838'; 
const API_URL = 'https://api.themoviedb.org/3/'; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}


// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM

break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
console.log('TV Details');
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);






// ***Details Page Backdrop***


// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`


          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})
}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
  
  
            <a href="tv-details.html?id=${show.id}">
  
            ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            
            }
           
            </a>
  
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);


// 8.
// Overlay for background image.
// The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  

displayBackgroundImage('movie', movie.backdrop_path);


const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 


// 8.
// Display Backdrop on Details Pages for Movies and TV Shows

function displayBackgroundImage(type, backgroundPath){
const overlayDiv = document.createElement('div')
// we need the image set to a specific URL
 overlayDiv.style.backgroundImage = `url(https://image.tmdb.org/t/p/original/${backgroundPath})`;
 overlayDiv.style.backgroundSize = 'cover';
 overlayDiv.style.backgroundPosition = 'center';
 overlayDiv.style.backgroundRepeat = 'no-repeat';
 overlayDiv.style.height = '100vh';
 overlayDiv.style.width = '100vw';
 overlayDiv.style.position = 'absolute';
 overlayDiv.style.top = '0';
 overlayDiv.style.left = '0';
 overlayDiv.style.zIndex = '-1';
 overlayDiv.style.opacity = '0.1';

//  check what the type is becuase we need to knwo where to put this. If it is a movie then we want it to go into the movie details id element, if it is a show then we want it to go into the show details   

if(type === 'movie'){
document.querySelector('#movie-details').appendChild(overlayDiv)
}else{
document.querySelector('#show-details').appendChild(overlayDiv)
}

}



// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = 'd96b5b45e8d9fb560bbbc147b6150838'; 
const API_URL = 'https://api.themoviedb.org/3/'; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}

// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM

break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
console.log('TV Details');
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);












// ***TV Show Details Page***




// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`


          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})
}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
  
  
            <a href="tv-details.html?id=${show.id}">
  
            ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            
            }
           
            </a>
  
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);


// 8.
// Overlay for background image.
// The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  

displayBackgroundImage('movie', movie.backdrop_path);

const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 


// 9.
// Display Show Details 

async function displayShowDetails(){
  // on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.
  
  // const showId = window.location.search;
  
  
  // console.log(showId); //?id=603692 
  
  
  const showId = window.location.search.split('=')[1]
  // ['?id', '603692']
  // console.log(showId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  
  
  console.log(showId); // 603692
  
  // get the show now
  
  const show = await fetchAPIData(`tv/${showId}`);


  // console.log(show) // check output 

   
  // 10.
  // Overlay for background image for TV Shows.
  // The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  
  

  displayBackgroundImage('tv', show.backdrop_path); // from const show = await fetchAPIData(`tv/${showId}`);
  
  const div = document.createElement('div');
  
  div.innerHTML = 
  
  `<div class="details-top">
  <div>
  ${
    show.poster_path
    ?`<img
    src="https://image.tmdb.org/t/p/w500${show.poster_path}"
    class="card-img-top"
    alt="${show.name}"
    />`
    : `<img
    src="images/no-image.jpg"
    class="card-img-top"
    alt="${show.name}"
  />` 
  
  }
  </div>
  
  <div>
  <h2>${show.name}</h2>
  <p>
  <i class="fas fa-star text-primary"></i>
  ${show.vote_average.toFixed(1)} / 10
  </p>
  <p class="text-muted">Last Air Date: ${show.last_air_date}</p>
  <p>
  ${show.overview}
  </p>
  
  <h5>Genres</h5>
  <ul class="list-group">
  
  ${show.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}
  
  </ul>
              
  <a href="${show.homepage}" target="_blank" class="btn">Visit show Homepage</a>
  </div>
  
  </div>
  <div class="details-bottom">
  <h2>Show Info</h2>
  <ul>
  <li><span class="text-secondary">Number of Episodes:</span> ${show.number_of_episodes}</li>
  <li><span class="text-secondary">Last Episode To Air:</span> ${show.last_episode_to_air.name}</li>

  <li><span class="text-secondary">Status:</span> ${show.status}</li>
  </ul>
  <h4>Production Companies</h4>
  <div class="list-group"> ${show.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
  </div>
  `
  document.querySelector('#show-details').appendChild(div);
  
  } 

// 8.
// Display Backdrop on Details Pages for Movies and TV Shows

function displayBackgroundImage(type, backgroundPath){
const overlayDiv = document.createElement('div')
// we need the image set to a specific URL
 overlayDiv.style.backgroundImage = `url(https://image.tmdb.org/t/p/original/${backgroundPath})`;
 overlayDiv.style.backgroundSize = 'cover';
 overlayDiv.style.backgroundPosition = 'center';
 overlayDiv.style.backgroundRepeat = 'no-repeat';
 overlayDiv.style.height = '100vh';
 overlayDiv.style.width = '100vw';
 overlayDiv.style.position = 'absolute';
 overlayDiv.style.top = '0';
 overlayDiv.style.left = '0';
 overlayDiv.style.zIndex = '-1';
 overlayDiv.style.opacity = '0.1';

//  check what the type is becuase we need to knwo where to put this. If it is a movie then we want it to go into the movie details id element, if it is a show then we want it to go into the show details   

if(type === 'movie'){
document.querySelector('#movie-details').appendChild(overlayDiv)
}else{
document.querySelector('#show-details').appendChild(overlayDiv)
}

}


// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = 'd96b5b45e8d9fb560bbbc147b6150838'; 
const API_URL = 'https://api.themoviedb.org/3/'; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}

// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM

break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
// console.log('TV Details');
displayShowDetails();
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);







// ***Swiper Slider*** 
// https://swiperjs.com/


// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`
          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})
}


// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
             <a href="tv-details.html?id=${show.id}">
              ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            }
           
            </a>
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);


// 8.
// Overlay for background image.
// The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  

displayBackgroundImage('movie', movie.backdrop_path);

const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 


// 9.
// Display Show Details 

async function displayShowDetails(){
  // on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.
  
  // const showId = window.location.search;
  
  
  // console.log(showId); //?id=603692 
  
  
  const showId = window.location.search.split('=')[1]
  // ['?id', '603692']
  // console.log(showId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  
  
  console.log(showId); // 603692
  
  // get the show now
  
  const show = await fetchAPIData(`tv/${showId}`);


  // console.log(show) // check output 

   
  // 10.
  // Overlay for background image for TV Shows.
  // The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  
  

  displayBackgroundImage('tv', show.backdrop_path); // from const show = await fetchAPIData(`tv/${showId}`);
  
  const div = document.createElement('div');
  
  div.innerHTML = 
  
  `<div class="details-top">
  <div>
  ${
    show.poster_path
    ?`<img
    src="https://image.tmdb.org/t/p/w500${show.poster_path}"
    class="card-img-top"
    alt="${show.name}"
    />`
    : `<img
    src="images/no-image.jpg"
    class="card-img-top"
    alt="${show.name}"
  />` 
  
  }
  </div>
  
  <div>
  <h2>${show.name}</h2>
  <p>
  <i class="fas fa-star text-primary"></i>
  ${show.vote_average.toFixed(1)} / 10
  </p>
  <p class="text-muted">Last Air Date: ${show.last_air_date}</p>
  <p>
  ${show.overview}
  </p>
  
  <h5>Genres</h5>
  <ul class="list-group">
  
  ${show.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}
  
  </ul>
              
  <a href="${show.homepage}" target="_blank" class="btn">Visit show Homepage</a>
  </div>
  
  </div>
  <div class="details-bottom">
  <h2>Show Info</h2>
  <ul>
  <li><span class="text-secondary">Number of Episodes:</span> ${show.number_of_episodes}</li>
  <li><span class="text-secondary">Last Episode To Air:</span> ${show.last_episode_to_air.name}</li>

  <li><span class="text-secondary">Status:</span> ${show.status}</li>
  </ul>
  <h4>Production Companies</h4>
  <div class="list-group"> ${show.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
  </div>
  `
  document.querySelector('#show-details').appendChild(div);
  
  } 

// 8.
// Display Backdrop on Details Pages for Movies and TV Shows

function displayBackgroundImage(type, backgroundPath){
const overlayDiv = document.createElement('div')
// we need the image set to a specific URL
 overlayDiv.style.backgroundImage = `url(https://image.tmdb.org/t/p/original/${backgroundPath})`;
 overlayDiv.style.backgroundSize = 'cover';
 overlayDiv.style.backgroundPosition = 'center';
 overlayDiv.style.backgroundRepeat = 'no-repeat';
 overlayDiv.style.height = '100vh';
 overlayDiv.style.width = '100vw';
 overlayDiv.style.position = 'absolute';
 overlayDiv.style.top = '0';
 overlayDiv.style.left = '0';
 overlayDiv.style.zIndex = '-1';
 overlayDiv.style.opacity = '0.1';

//  check what the type is becuase we need to knwo where to put this. If it is a movie then we want it to go into the movie details id element, if it is a show then we want it to go into the show details   

if(type === 'movie'){
document.querySelector('#movie-details').appendChild(overlayDiv)
}else{
document.querySelector('#show-details').appendChild(overlayDiv)
}

}


// 11.
// Display Slider Swiper Movies (New Releases)
// we want to make asyn as we will be fetching from the api
async function displaySlider(){
// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/now_playing');

// console.log(results)
results.forEach((movie)=>{
const div = document.createElement('div')
div.classList.add('swiper-slide')

div.innerHTML = `
<a href="movie-details.html?id=${movie.id}">
  <img src="https://image.tmdb.org/t/p/w500${movie.poster_path}" alt="${movie.title}" />
</a>
<h4 class="swiper-rating">
  <i class="fas fa-star text-secondary"></i> ${movie.vote_average} / 10
</h4>
`;

document.querySelector('.swiper-wrapper').appendChild(div)



initSwiper()

})


}

// 12.
// Swiper (we do need to initialise this and we can add options we do this by new swiper object).
function initSwiper(){
const swiper = new Swiper('.swiper', {
// pass in the class of .swiper the element to target and for the options we can pass in an object

// - all options available in documentation from: https://swiperjs.com/swiper-api

slidesPerView: 1, //we can specify breakpoints set to 1 movie initially but say if the viewport width is 500px and up we will set it to 2 if it is 700px and up we will set it to 3 and if it is 1200px or up we will set it to 4.   
spaceBetween: 30, //in pixels px 
freeMode: true, //click and drag it yourself 
loop: true, 
autoplay: {
delay: 4000, //delay between slides 4 secs
disableOnInteraction: false, // if you hover over it it will stop 
},
breakpoints: {
500: {
slidesPerView: 2
},
700: {
slidesPerView: 3
},
1200: {
slidesPerView: 4
},
}
})  
}



// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = 'd96b5b45e8d9fb560bbbc147b6150838'; 
const API_URL = 'https://api.themoviedb.org/3/'; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}

// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displaySlider();
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM

break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
// console.log('TV Details');
displayShowDetails();
break;
case 'search.html':
console.log('Search');
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);








// ***Search Functionality***
// In the tmdb api we can make a GET request for /search/tv to get tv shows and there is a seperate one for movies. You can also search companies, people, collections. If we want movies then we want to GET /search/movie. We need to send our api_Key we also need to send query that will be the text that we need to search for. Also after we will have pagination so we will need to work with the page, query string.

// Instead of having a submit event listener on this form we will have it submit to the search.html page and soon as we hit that page we are going to fire off a search function that will set everything out like to fetch to get the request, to put the data in the DOM.

// If you type in the search e.g. goodefellas because of the way the form is set up in search.html you will see the type which is movie and we get the search-term which is goofellas in the URL.

// html 
// <input
// type="text"
// name="search-term"
// id="search-term"
// placeholder="Enter search term"
// />

// So if you make a GET request with a <form></form> (it is not a POST request) it is going to put whatever the name="search-term" is here in the URL search-term=goodfellas (=value) for that form input. 

// We also have the two radio buttons that have the name="type" and value="movie" and value="tv" that is why in the URL we have name type and value movie type=movie

// http://127.0.0.1:5500/search.html?type=movie&search-term=goodfellas

// If I do TV shows it will be type=tv 
// So we need this data to do what we want..


// HTML in search.html

// <form action="/search.html" class="search-form">

// <div class="search-radio">

// <input type="radio" id="movie" name="type" value="movie" checked />
// <label for="movies">Movies</label>

// <input type="radio" id="tv" name="type" value="tv" />
// <label for="shows">TV Shows</label>

// </div>

// <div class="search-flex">
// <input
// type="text"
// name="search-term"
// id="search-term"
// placeholder="Enter search term"
// />

// <button class="btn" type="submit">
// <i class="fas fa-search"></i>
// </button>
// </div>

// </form>


// - JavaScript for Search Functionality -


const global = {
currentPage: window.location.pathname,
search: {
term: '', 
type: '',
page: 1,
totalPages: 1 
},
api:{
apiKey:'d96b5b45e8d9fb560bbbc147b6150838',
apiUrl:'https://api.themoviedb.org/3/',
}
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`


          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})
}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
              <a href="tv-details.html?id=${show.id}">
  
            ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            
            }
           
            </a>
  
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);


// 8.
// Overlay for background image.
// The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  

displayBackgroundImage('movie', movie.backdrop_path);

const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 


// 9.
// Display Show Details 

async function displayShowDetails(){
  // on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.
  
  // const showId = window.location.search;
  
  
  // console.log(showId); //?id=603692 
  
  
  const showId = window.location.search.split('=')[1]
  // ['?id', '603692']
  // console.log(showId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  
  
  console.log(showId); // 603692
  
  // get the show now
  
  const show = await fetchAPIData(`tv/${showId}`);


  // console.log(show) // check output 

   
  // 10.
  // Overlay for background image for TV Shows.
  // The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  
  

  displayBackgroundImage('tv', show.backdrop_path); // from const show = await fetchAPIData(`tv/${showId}`);
  
  const div = document.createElement('div');
  
  div.innerHTML = 
  
  `<div class="details-top">
  <div>
  ${
    show.poster_path
    ?`<img
    src="https://image.tmdb.org/t/p/w500${show.poster_path}"
    class="card-img-top"
    alt="${show.name}"
    />`
    : `<img
    src="images/no-image.jpg"
    class="card-img-top"
    alt="${show.name}"
  />` 
  
  }
  </div>
  
  <div>
  <h2>${show.name}</h2>
  <p>
  <i class="fas fa-star text-primary"></i>
  ${show.vote_average.toFixed(1)} / 10
  </p>
  <p class="text-muted">Last Air Date: ${show.last_air_date}</p>
  <p>
  ${show.overview}
  </p>
  
  <h5>Genres</h5>
  <ul class="list-group">
  
  ${show.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}
  
  </ul>
              
  <a href="${show.homepage}" target="_blank" class="btn">Visit show Homepage</a>
  </div>
  
  </div>
  <div class="details-bottom">
  <h2>Show Info</h2>
  <ul>
  <li><span class="text-secondary">Number of Episodes:</span> ${show.number_of_episodes}</li>
  <li><span class="text-secondary">Last Episode To Air:</span> ${show.last_episode_to_air.name}</li>

  <li><span class="text-secondary">Status:</span> ${show.status}</li>
  </ul>
  <h4>Production Companies</h4>
  <div class="list-group"> ${show.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
  </div>
  `
  document.querySelector('#show-details').appendChild(div);
  
  } 


// 8.
// Display Backdrop on Details Pages for Movies and TV Shows

function displayBackgroundImage(type, backgroundPath){
const overlayDiv = document.createElement('div')
// we need the image set to a specific URL
 overlayDiv.style.backgroundImage = `url(https://image.tmdb.org/t/p/original/${backgroundPath})`;
 overlayDiv.style.backgroundSize = 'cover';
 overlayDiv.style.backgroundPosition = 'center';
 overlayDiv.style.backgroundRepeat = 'no-repeat';
 overlayDiv.style.height = '100vh';
 overlayDiv.style.width = '100vw';
 overlayDiv.style.position = 'absolute';
 overlayDiv.style.top = '0';
 overlayDiv.style.left = '0';
 overlayDiv.style.zIndex = '-1';
 overlayDiv.style.opacity = '0.1';

//  check what the type is becuase we need to knwo where to put this. If it is a movie then we want it to go into the movie details id element, if it is a show then we want it to go into the show details   

if(type === 'movie'){
document.querySelector('#movie-details').appendChild(overlayDiv)
}else{
document.querySelector('#show-details').appendChild(overlayDiv)
}

}

// 13. Search Movies/Shows

// first we want to get the data from the url 
// http://127.0.0.1:5500/search.html?type=movie&search-term=goodfellas
// Anything from the ? question mark over including the ? is considered the queryString() then you have the query parameters which is each piece of data

async function search(){

  const queryString = window.location.search;
  // console.log(queryString) //?type=movie&search-term=goodfellas

  // to seperate out to get the data we can use an object called url search params 
  const urlParams = new URLSearchParams(queryString) //pass in queryString

    // console.log(urlParams.get('type')); 

    //urlParams methods on the Prototype that we can use e.g. .get() and put what we want to get like the query params 'type'. So when you click on the radio button movies and then click the button submit in the console you will see movie and same process for clicking on radio button for tv remember to click and press submit. We want to use it in other places so a solution is to add it in the global.

    // search: {
    //   term: '', 
    //   type: '',
    //   page: 1,
    //   totalPages: 1 
    //   }

    global.search.type = urlParams.get('type');
    global.search.term = urlParams.get('search-term'); //look back at form in search.html in the input we have name="search-term"

    //custom alert styled in css class .alert {}

    // not equal to empty string also not null
    if(global.search.term !== '' && global.search.term !== null){
    // make request and display result. If we pass validation we want to make the request and display results.  

    const results = await searchAPIData(); //searchAPIData() we do not have to pass anything in because the endpoint i8s going to be constructed from within the function.

    console.log(results)

    }else{
    //  alert('Please Enter Search Term')
    showAlert('Please enter a search term');


    }

  }

  search()
  
 


// 11.
// Display Slider Swiper Movies (New Releases)
// we want to make asyn as we will be fetching from the api
async function displaySlider(){
// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/now_playing');

// console.log(results)
results.forEach((movie)=>{
const div = document.createElement('div')
div.classList.add('swiper-slide')

div.innerHTML = `
<a href="movie-details.html?id=${movie.id}">
  <img src="https://image.tmdb.org/t/p/w500${movie.poster_path}" alt="${movie.title}" />
</a>
<h4 class="swiper-rating">
  <i class="fas fa-star text-secondary"></i> ${movie.vote_average} / 10
</h4>
`;

document.querySelector('.swiper-wrapper').appendChild(div)



initSwiper()

})


}

// 12.
// Swiper (we do need to initialise this and we can add options we do this by new swiper object).
function initSwiper(){
const swiper = new Swiper('.swiper', {
// pass in the class of .swiper the element to target and for the options we can pass in an object

// - all options available in documentation from: https://swiperjs.com/swiper-api

slidesPerView: 1, //we can specify breakpoints set to 1 movie initially but say if the viewport width is 500px and up we will set it to 2 if it is 700px and up we will set it to 3 and if it is 1200px or up we will set it to 4.   
spaceBetween: 30, //in pixels px 
freeMode: true, //click and drag it yourself 
loop: true, 
autoplay: {
delay: 4000, //delay between slides 4 secs
disableOnInteraction: false, // if you hover over it it will stop 
},
breakpoints: {
500: {
slidesPerView: 2
},
700: {
slidesPerView: 3
},
1200: {
slidesPerView: 4
},
}
})  
}



// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = global.api.apiKey; 
const API_URL = global.api.apiUrl; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 15. 
// Make Request To Search  
async function searchAPIData(){
  const API_KEY = global.api.apiKey; 
  const API_URL = global.api.apiUrl; 
  

  showSpinner(); 
  const response = await fetch(`${API_URL}search/${global.search.type}?api_key=${API_KEY}&language=en-US&query=${global.search.term}`) 
  
  const data = await response.json()
  

  hideSpinner() 
  
  return data;  
  }


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 14. 
// Show Alert (Customised)

function showAlert(message, className) {
  const alertEl = document.createElement('div');
  alertEl.classList.add('alert', className);
  // text will be the message that come's in from the function
  alertEl.appendChild(document.createTextNode(message));
  //add it to the DOM we do have an id of alert
  document.querySelector('#alert').appendChild(alertEl);


  //alert goes away after a certain amount of time

  setTimeout(()=> alertEl.remove(), 3000);
}


// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}

// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displaySlider();
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM
break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
// console.log('TV Details');
displayShowDetails();
break;
case 'search.html':
search(); // 13.
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);









// ***Display Search Results***

// console.log(window.location.pathname) // url file name e.g. shows.html

const global = {
currentPage: window.location.pathname,
search: {
term: '', 
type: '',
page: 1,
totalPages: 1 
},
api:{
apiKey:'d96b5b45e8d9fb560bbbc147b6150838',
apiUrl:'https://api.themoviedb.org/3/',
}
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`


          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})


}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
  
  
            <a href="tv-details.html?id=${show.id}">
  
            ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            
            }
           
            </a>
  
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);


// 8.
// Overlay for background image.
// The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  

displayBackgroundImage('movie', movie.backdrop_path);

const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 


// 9.
// Display Show Details 

async function displayShowDetails(){
  // on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.
  
  // const showId = window.location.search;
  
  
  // console.log(showId); //?id=603692 
  
  
  const showId = window.location.search.split('=')[1]
  // ['?id', '603692']
  // console.log(showId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  
  
  console.log(showId); // 603692
  
  // get the show now
  
  const show = await fetchAPIData(`tv/${showId}`);


  // console.log(show) // check output 

   
  // 10.
  // Overlay for background image for TV Shows.
  // The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  
  

  displayBackgroundImage('tv', show.backdrop_path); // from const show = await fetchAPIData(`tv/${showId}`);
  
  const div = document.createElement('div');
  
  div.innerHTML = 
  
  `<div class="details-top">
  <div>
  ${
    show.poster_path
    ?`<img
    src="https://image.tmdb.org/t/p/w500${show.poster_path}"
    class="card-img-top"
    alt="${show.name}"
    />`
    : `<img
    src="images/no-image.jpg"
    class="card-img-top"
    alt="${show.name}"
  />` 
  
  }
  </div>
  
  <div>
  <h2>${show.name}</h2>
  <p>
  <i class="fas fa-star text-primary"></i>
  ${show.vote_average.toFixed(1)} / 10
  </p>
  <p class="text-muted">Last Air Date: ${show.last_air_date}</p>
  <p>
  ${show.overview}
  </p>
  
  <h5>Genres</h5>
  <ul class="list-group">
  
  ${show.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}
  
  </ul>
              
  <a href="${show.homepage}" target="_blank" class="btn">Visit show Homepage</a>
  </div>
  
  </div>
  <div class="details-bottom">
  <h2>Show Info</h2>
  <ul>
  <li><span class="text-secondary">Number of Episodes:</span> ${show.number_of_episodes}</li>
  <li><span class="text-secondary">Last Episode To Air:</span> ${show.last_episode_to_air.name}</li>

  <li><span class="text-secondary">Status:</span> ${show.status}</li>
  </ul>
  <h4>Production Companies</h4>
  <div class="list-group"> ${show.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
  </div>
  `
  document.querySelector('#show-details').appendChild(div);
  
  } 

// 8.
// Display Backdrop on Details Pages for Movies and TV Shows

function displayBackgroundImage(type, backgroundPath){
const overlayDiv = document.createElement('div')
// we need the image set to a specific URL
 overlayDiv.style.backgroundImage = `url(https://image.tmdb.org/t/p/original/${backgroundPath})`;
 overlayDiv.style.backgroundSize = 'cover';
 overlayDiv.style.backgroundPosition = 'center';
 overlayDiv.style.backgroundRepeat = 'no-repeat';
 overlayDiv.style.height = '100vh';
 overlayDiv.style.width = '100vw';
 overlayDiv.style.position = 'absolute';
 overlayDiv.style.top = '0';
 overlayDiv.style.left = '0';
 overlayDiv.style.zIndex = '-1';
 overlayDiv.style.opacity = '0.1';

//  check what the type is becuase we need to knwo where to put this. If it is a movie then we want it to go into the movie details id element, if it is a show then we want it to go into the show details   

if(type === 'movie'){
document.querySelector('#movie-details').appendChild(overlayDiv)
}else{
document.querySelector('#show-details').appendChild(overlayDiv)
}

}

// 13. Search Movies/Shows

// first we want to get the data from the url 
// http://127.0.0.1:5500/search.html?type=movie&search-term=goodfellas
// Anything from the ? question mark over including the ? is considered the queryString() then you have the query parameters which is each piece of data

async function search(){

  const queryString = window.location.search;
  // console.log(queryString) //?type=movie&search-term=goodfellas

  // to seperate out to get the data we can use an object called url search params 
  const urlParams = new URLSearchParams(queryString) //pass in queryString

    // console.log(urlParams.get('type')); 

    //urlParams methods on the Prototype that we can use e.g. .get() and put what we want to get like the query params 'type'. So when you click on the radio button movies and then click the button submit in the console you will see movie and same process for clicking on radio button for tv remember to click and press submit. We want to use it in other places so a solution is to add it in the global.

    // search: {
    //   term: '', 
    //   type: '',
    //   page: 1,
    //   totalPages: 1 
    //   }

    global.search.type = urlParams.get('type');
    global.search.term = urlParams.get('search-term'); //look back at form in search.html in the input we have name="search-term"

    //custom alert styled in css class .alert {}

    // not equal to empty string also not null
    if(global.search.term !== '' && global.search.term !== null){
    // make request and display result. If we pass validation we want to make the request and display results.  


    // const { results } to display in the DOM we put curly brackets around {results} as it is an object that has an array called results. We also want the total_pages, and page numbers page.
    const { results, total_pages, page } = await searchAPIData(); //searchAPIData() we do not have to pass anything in because the endpoint i8s going to be constructed from within the function.

    console.log(results)

    // check if there is results 

    if(results.length === 0){
      showAlert('No results found')
    return 
    }

    // if there are results we want to add them to the DOM. So have another function
    
    displaySearchResults(results)

    // clear the input 
    document.querySelector('#search-term').value ='';

    }else{
    //  alert('Please Enter Search Term')
    showAlert('Please enter a search term');
    }
  }

  search()

  // 16. 

  function displaySearchResults(results){
    // results is an array that is being passed in we want to loop through it and show it in the output

    // it needs to be dynamic an handle both movies and shows 
    results.forEach((result) => {
      const div = document.createElement('div');
      div.classList.add('card');
      div.innerHTML = `
            <a href="${global.search.type}-details.html?id=${result.id}">
              ${
                result.poster_path
                  ? `<img
                src="https://image.tmdb.org/t/p/w500/${result.poster_path}"
                class="card-img-top"
                alt="${
                  global.search.type === 'movie' ? result.title : result.name
                }"
              />`
                  : `<img
              src="../images/no-image.jpg"
              class="card-img-top"
               alt="${
                 global.search.type === 'movie' ? result.title : result.name
               }"
            />`
              }
            </a>
            <div class="card-body">
              <h5 class="card-title">${
                global.search.type === 'movie' ? result.title : result.name
              }</h5>
              <p class="card-text">
                <small class="text-muted">Release: ${
                  global.search.type === 'movie'
                    ? result.release_date
                    : result.first_air_date
                }</small>
              </p>
            </div>
          `;
  
      document.querySelector('#search-results').appendChild(div);
    });
  }
  
 

// 11.
// Display Slider Swiper Movies (New Releases)
// we want to make asyn as we will be fetching from the api
async function displaySlider(){
// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/now_playing');

// console.log(results)
results.forEach((movie)=>{
const div = document.createElement('div')
div.classList.add('swiper-slide')

div.innerHTML = `
<a href="movie-details.html?id=${movie.id}">
  <img src="https://image.tmdb.org/t/p/w500${movie.poster_path}" alt="${movie.title}" />
</a>
<h4 class="swiper-rating">
  <i class="fas fa-star text-secondary"></i> ${movie.vote_average} / 10
</h4>
`;

document.querySelector('.swiper-wrapper').appendChild(div)



initSwiper()

})
}

// 12.
// Swiper (we do need to initialise this and we can add options we do this by new swiper object).
function initSwiper(){
const swiper = new Swiper('.swiper', {
// pass in the class of .swiper the element to target and for the options we can pass in an object

// - all options available in documentation from: https://swiperjs.com/swiper-api

slidesPerView: 1, //we can specify breakpoints set to 1 movie initially but say if the viewport width is 500px and up we will set it to 2 if it is 700px and up we will set it to 3 and if it is 1200px or up we will set it to 4.   
spaceBetween: 30, //in pixels px 
freeMode: true, //click and drag it yourself 
loop: true, 
autoplay: {
delay: 4000, //delay between slides 4 secs
disableOnInteraction: false, // if you hover over it it will stop 
},
breakpoints: {
500: {
slidesPerView: 2
},
700: {
slidesPerView: 3
},
1200: {
slidesPerView: 4
},
}
})  
}


// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = global.api.apiKey; 
const API_URL = global.api.apiUrl; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 15. 
// Make Request To Search  
async function searchAPIData(){
  const API_KEY = global.api.apiKey; 
  const API_URL = global.api.apiUrl; 
  

  showSpinner(); 
  const response = await fetch(`${API_URL}search/${global.search.type}?api_key=${API_KEY}&language=en-US&query=${global.search.term}`) 
  
  const data = await response.json()
  

  hideSpinner() 
  
  return data;  
  }


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 14. 
// Show Alert (Customised)

function showAlert(message, className = 'error') {
  const alertEl = document.createElement('div');
  alertEl.classList.add('alert', className);
  // text will be the message that come's in from the function
  alertEl.appendChild(document.createTextNode(message));
  //add it to the DOM we do have an id of alert
  document.querySelector('#alert').appendChild(alertEl);


  //alert goes away after a certain amount of time

  setTimeout(()=> alertEl.remove(), 3000);
}




// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}

// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displaySlider();
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM
break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
// console.log('TV Details');
displayShowDetails();
break;
case 'search.html':
search(); // 13.
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);










// ***Add Pagination For Search***


const global = {
currentPage: window.location.pathname,
search: {
term: '', 
type: '',
page: 1,
totalPages: 1, 
totalResults: 0
},
api:{
apiKey:'d96b5b45e8d9fb560bbbc147b6150838',
apiUrl:'https://api.themoviedb.org/3/',
}
};
// console.log(global.currentPage);



// 2. 
async function displayPopularMovies(){

// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint movie/popular.

// console.log(results)

results.forEach(movie =>{

const div = document.createElement('div')
div.classList.add('card');  
div.innerHTML = 
`


          <a href="movie-details.html?id=${movie.id}">

          ${
            movie.poster_path
            ?`
            <img
            src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
            class="card-img-top"
            alt="${movie.title}"
            />`
            : `<img
            src="images/no-image.jpg"
            class="card-img-top"
            alt="${movie.title}"
          />` 
          
          }
         
          </a>

          <div class="card-body">
            <h5 class="card-title">${movie.title}</h5>
            <p class="card-text">
              <small class="text-muted">Release: ${movie.release_date}</small>
            </p>
          </div>
        </div>
`;

document.querySelector('#popular-movies').appendChild(div)

})


}



// 5. Display 20 most popular TV shows

async function displayPopularShows(){

  // results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
  const { results } = await fetchAPIData('tv/popular'); //any time we need to get data fromn the API we call this function and we will pass in the endpoint tv/popular.
  
  // console.log(results)
  
  results.forEach(show =>{
  
  const div = document.createElement('div')
  div.classList.add('card');  
  div.innerHTML = 
  `
  
  
            <a href="tv-details.html?id=${show.id}">
  
            ${
              show.poster_path
              ?`
              <img
              src="https://image.tmdb.org/t/p/w500${show.poster_path}"
              class="card-img-top"
              alt="${show.name}"
              />`
              : `<img
              src="images/no-image.jpg"
              class="card-img-top"
              alt="${show.name}"
            />` 
            
            }
           
            </a>
  
            <div class="card-body">
              <h5 class="card-title">${show.name}</h5>
              <p class="card-text">
                <small class="text-muted">Air Date: ${show.first_air_date}</small>
              </p>
            </div>
          </div>
  `;
  
  document.querySelector('#popular-shows').appendChild(div)
  
  })
  }
  

// 6.
// Display Movie Details 

async function displayMovieDetails(){
// on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.

// const movieId = window.location.search;


// console.log(movieId); //?id=603692 


const movieId = window.location.search.split('=')[1]
// ['?id', '603692']
// console.log(movieId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  

console.log(movieId); // 603692

// get the movie now

const movie = await fetchAPIData(`movie/${movieId}`);


// 8.
// Overlay for background image.
// The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  

displayBackgroundImage('movie', movie.backdrop_path);

const div = document.createElement('div');

div.innerHTML = 

`<div class="details-top">
<div>
${
  movie.poster_path
  ?`<img
  src="https://image.tmdb.org/t/p/w500${movie.poster_path}"
  class="card-img-top"
  alt="${movie.title}"
  />`
  : `<img
  src="images/no-image.jpg"
  class="card-img-top"
  alt="${movie.title}"
/>` 

}
</div>

<div>
<h2>${movie.title}</h2>
<p>
<i class="fas fa-star text-primary"></i>
${movie.vote_average.toFixed(1)} / 10
</p>
<p class="text-muted">Release Date: ${movie.release_date}</p>
<p>
${movie.overview}
</p>

<h5>Genres</h5>
<ul class="list-group">

${movie.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}

</ul>
            
<a href="${movie.homepage}" target="_blank" class="btn">Visit Movie Homepage</a>
</div>

</div>
<div class="details-bottom">
<h2>Movie Info</h2>
<ul>
<li><span class="text-secondary">Budget:</span> $${addCommasToNumber(movie.budget)}</li>
<li><span class="text-secondary">Revenue:</span> $${addCommasToNumber(movie.revenue)}</li>
<li><span class="text-secondary">Runtime:</span> ${movie.runtime} minutes</li>
<li><span class="text-secondary">Status:</span> ${movie.status}</li>
</ul>
<h4>Production Companies</h4>
<div class="list-group"> ${movie.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
</div>
`
document.querySelector('#movie-details').appendChild(div);

} 


// 9.
// Display Show Details 

async function displayShowDetails(){
  // on the window object there is a location api or object that has a search property that we can get all the query string anything after the ? question mark.
  
  // const showId = window.location.search;
  
  
  // console.log(showId); //?id=603692 
  
  
  const showId = window.location.search.split('=')[1]
  // ['?id', '603692']
  // console.log(showId); //?id=603692 we need the number so we use the split method which will turn it into an array. We can split it anywhere we want.  
  
  console.log(showId); // 603692
  
  // get the show now
  
  const show = await fetchAPIData(`tv/${showId}`);


  // console.log(show) // check output 

   
  // 10.
  // Overlay for background image for TV Shows.
  // The function will take in two things the type 'movie' the reason why we pass the type in is because we are going to do this for movies and shows and we need to know which element to put it in movie details or show TV details. We also need the backdrop path from the api movie.backdrop_path  
  

  displayBackgroundImage('tv', show.backdrop_path); // from const show = await fetchAPIData(`tv/${showId}`);
  
  const div = document.createElement('div');
  
  div.innerHTML = 
  
  `<div class="details-top">
  <div>
  ${
    show.poster_path
    ?`<img
    src="https://image.tmdb.org/t/p/w500${show.poster_path}"
    class="card-img-top"
    alt="${show.name}"
    />`
    : `<img
    src="images/no-image.jpg"
    class="card-img-top"
    alt="${show.name}"
  />` 
  
  }
  </div>
  
  <div>
  <h2>${show.name}</h2>
  <p>
  <i class="fas fa-star text-primary"></i>
  ${show.vote_average.toFixed(1)} / 10
  </p>
  <p class="text-muted">Last Air Date: ${show.last_air_date}</p>
  <p>
  ${show.overview}
  </p>
  
  <h5>Genres</h5>
  <ul class="list-group">
  
  ${show.genres.map((genre)=> `<li>${genre.name}<li/>`).join('')}
  
  </ul>
              
  <a href="${show.homepage}" target="_blank" class="btn">Visit show Homepage</a>
  </div>
  
  </div>
  <div class="details-bottom">
  <h2>Show Info</h2>
  <ul>
  <li><span class="text-secondary">Number of Episodes:</span> ${show.number_of_episodes}</li>
  <li><span class="text-secondary">Last Episode To Air:</span> ${show.last_episode_to_air.name}</li>

  <li><span class="text-secondary">Status:</span> ${show.status}</li>
  </ul>
  <h4>Production Companies</h4>
  <div class="list-group"> ${show.production_companies.map((company)=> `<span> ${company.name}<span/>`).join(', ')} </div>
  </div>
  `
  document.querySelector('#show-details').appendChild(div);
  
  } 

// 8.
// Display Backdrop on Details Pages for Movies and TV Shows

function displayBackgroundImage(type, backgroundPath){
const overlayDiv = document.createElement('div')
// we need the image set to a specific URL
 overlayDiv.style.backgroundImage = `url(https://image.tmdb.org/t/p/original/${backgroundPath})`;
 overlayDiv.style.backgroundSize = 'cover';
 overlayDiv.style.backgroundPosition = 'center';
 overlayDiv.style.backgroundRepeat = 'no-repeat';
 overlayDiv.style.height = '100vh';
 overlayDiv.style.width = '100vw';
 overlayDiv.style.position = 'absolute';
 overlayDiv.style.top = '0';
 overlayDiv.style.left = '0';
 overlayDiv.style.zIndex = '-1';
 overlayDiv.style.opacity = '0.1';

//  check what the type is becuase we need to knwo where to put this. If it is a movie then we want it to go into the movie details id element, if it is a show then we want it to go into the show details   

if(type === 'movie'){
document.querySelector('#movie-details').appendChild(overlayDiv)
}else{
document.querySelector('#show-details').appendChild(overlayDiv)
}

}

// 13. Search Movies/Shows

// first we want to get the data from the url 
// http://127.0.0.1:5500/search.html?type=movie&search-term=goodfellas
// Anything from the ? question mark over including the ? is considered the queryString() then you have the query parameters which is each piece of data

async function search(){

  const queryString = window.location.search;
  // console.log(queryString) //?type=movie&search-term=goodfellas

  // to seperate out to get the data we can use an object called url search params 
  const urlParams = new URLSearchParams(queryString) //pass in queryString

    // console.log(urlParams.get('type')); 

    //urlParams methods on the Prototype that we can use e.g. .get() and put what we want to get like the query params 'type'. So when you click on the radio button movies and then click the button submit in the console you will see movie and same process for clicking on radio button for tv remember to click and press submit. We want to use it in other places so a solution is to add it in the global.

    // search: {
    //   term: '', 
    //   type: '',
    //   page: 1,
    //   totalPages: 1 
    //   }

    global.search.type = urlParams.get('type');
    global.search.term = urlParams.get('search-term'); //look back at form in search.html in the input we have name="search-term"

    //custom alert styled in css class .alert {}

    // not equal to empty string also not null
    if(global.search.term !== '' && global.search.term !== null){
    // make request and display result. If we pass validation we want to make the request and display results.  



    // const { results } to display in the DOM we put curly brackets around {results} as it is an object that has an array called results. We also want the total_pages, and page numbers page.
    const { results, total_pages, page, total_results } = await searchAPIData(); //searchAPIData() we do not have to pass anything in because the endpoint i8s going to be constructed from within the function.

    console.log(results)


    // add total results
    global.search.page = page;
    global.search.totalPages = total_pages;
    global.search.totalResults = total_results;

    

    // check if there is results 

    if(results.length === 0){
      showAlert('No results found')
    return 
    }

    // if there are results we want to add them to the DOM. So have another function
    
    displaySearchResults(results)

    // clear the input 
    document.querySelector('#search-term').value ='';

    }else{
    //  alert('Please Enter Search Term')
    showAlert('Please enter a search term');
    }
  }

  search()

  // 16. 

  function displaySearchResults(results){
    // results is an array that is being passed in we want to loop through it and show it in the output


    // clear previous results 

    document.querySelector('#search-results').innerHTML='';
    document.querySelector('#search-results-heading').innerHTML='';
    document.querySelector('#pagination').innerHTML='';


    // it needs to be dynamic an handle both movies and shows 
    results.forEach((result) => {
      const div = document.createElement('div');
      div.classList.add('card');
      div.innerHTML = `
            <a href="${global.search.type}-details.html?id=${result.id}">
              ${
                result.poster_path
                  ? `<img
                src="https://image.tmdb.org/t/p/w500/${result.poster_path}"
                class="card-img-top"
                alt="${
                  global.search.type === 'movie' ? result.title : result.name
                }"
              />`
                  : `<img
              src="../images/no-image.jpg"
              class="card-img-top"
               alt="${
                 global.search.type === 'movie' ? result.title : result.name
               }"
            />`
              }
            </a>
            <div class="card-body">
              <h5 class="card-title">${
                global.search.type === 'movie' ? result.title : result.name
              }</h5>
              <p class="card-text">
                <small class="text-muted">Release: ${
                  global.search.type === 'movie'
                    ? result.release_date
                    : result.first_air_date
                }</small>
              </p>
            </div>
          `;


        // add total reults in heading

        document.querySelector('#search-results-heading').innerHTML =`<h2>${results.length} of ${global.search.totalResults} Results for ${global.search.term}</h2>`

  
      document.querySelector('#search-results').appendChild(div);
    });

displayPagination();

  }
  

// 17.
// Create & Display Pagination for Search

function displayPagination(){

const div = document.createElement('div')
div.classList.add('pagination');
div.innerHTML =`
<button class="btn btn-primary" id="prev">Prev</button>
<button class="btn btn-primary" id="next">Next</button>
<div class="page-counter">Page ${global.search.page} of ${global.search.totalPages}</div>
`

document.querySelector('#pagination').appendChild(div)

// disable prev next if on first page 

if(global.search.page === 1){
document.querySelector('#prev').disabled = true
}


// disable next button if on last page 
if(global.search.page === global.search.totalPages){
  document.querySelector('#next').disabled = true
  }



// next page. We need to add an event listener so we can actually change the page. When we change the page we need to make another request to the api with the particular page we want to get otherwise we will get the same results all the time 

document.querySelector('#next').addEventListener('click', async ()=>{

  // increment the global search page 

  global.search.page++
  
  
  const { results, total_pages } = await searchAPIData();
  displaySearchResults(results)

});


// prev button page 

document.querySelector('#prev').addEventListener('click', async ()=>{

  // decrement the global search page 

  global.search.page--
  
  
  const { results, total_pages } = await searchAPIData();
  displaySearchResults(results)

});

}



// 11.
// Display Slider Swiper Movies (New Releases)
// we want to make asyn as we will be fetching from the api
async function displaySlider(){
// results gives an object with a results array so an array called results. If you put curly braces around { results } you will get the straight array which is what you want.
const { results } = await fetchAPIData('movie/now_playing');

// console.log(results)
results.forEach((movie)=>{
const div = document.createElement('div')
div.classList.add('swiper-slide')

div.innerHTML = `
<a href="movie-details.html?id=${movie.id}">
  <img src="https://image.tmdb.org/t/p/w500${movie.poster_path}" alt="${movie.title}" />
</a>
<h4 class="swiper-rating">
  <i class="fas fa-star text-secondary"></i> ${movie.vote_average} / 10
</h4>
`;

document.querySelector('.swiper-wrapper').appendChild(div)

initSwiper()

})

}


// 12.
// Swiper (we do need to initialise this and we can add options we do this by new swiper object).
function initSwiper(){
const swiper = new Swiper('.swiper', {
// pass in the class of .swiper the element to target and for the options we can pass in an object

// - all options available in documentation from: https://swiperjs.com/swiper-api

slidesPerView: 1, //we can specify breakpoints set to 1 movie initially but say if the viewport width is 500px and up we will set it to 2 if it is 700px and up we will set it to 3 and if it is 1200px or up we will set it to 4.   
spaceBetween: 30, //in pixels px 
freeMode: true, //click and drag it yourself 
loop: true, 
autoplay: {
delay: 4000, //delay between slides 4 secs
disableOnInteraction: false, // if you hover over it it will stop 
},
breakpoints: {
500: {
slidesPerView: 2
},
700: {
slidesPerView: 3
},
1200: {
slidesPerView: 4
},
}
})  
}



// 1. Fetch data from TMDB API 

async function fetchAPIData(endpoint){
const API_KEY = global.api.apiKey; 
const API_URL = global.api.apiUrl; // we put a forward slash / at the end of 3 here .org/3/ so need to put a slash ${API_UTL}/ here otherwise we will end up with two slashes.

// 3.
showSpinner(); //just before we make our request showSPinner()

const response = await fetch(`${API_URL}${endpoint}?api_key=${API_KEY}&language=en-US`) 

const data = await response.json()

// 4.
hideSpinner() // once the data is actually fetched before we return it we are going to call hideSpinner()


return data; //call this from a function to get the popular movies from the homepage  
}


// 15. 
// Make Request To Search  
async function searchAPIData(){
  const API_KEY = global.api.apiKey; 
  const API_URL = global.api.apiUrl; 
  

  showSpinner(); 
  const response = await fetch(`${API_URL}search/${global.search.type}?api_key=${API_KEY}&language=en-US&query=${global.search.term}&page=${global.search.page}`) 
  
  const data = await response.json()
  

  hideSpinner() 
  
  return data;  
  }


// 3. 
function showSpinner(){
  document.querySelector('.spinner').classList.add('show')

}

// 4. 
function hideSpinner(){
  document.querySelector('.spinner').classList.remove('show')
}



// highlight active link yellow when clicked and then turns off after clicking to another link text button.

function highlightActiveLink(){
const links = document.querySelectorAll('.nav-link')

links.forEach((link)=>{

  if(link.getAttribute('href')=== global.currentPage ){

  link.classList.add('active')
  }

}) 

}


// 14. 
// Show Alert (Customised)

function showAlert(message, className = 'error') {
  const alertEl = document.createElement('div');
  alertEl.classList.add('alert', className);
  // text will be the message that come's in from the function
  alertEl.appendChild(document.createTextNode(message));
  //add it to the DOM we do have an id of alert
  document.querySelector('#alert').appendChild(alertEl);


  //alert goes away after a certain amount of time

  setTimeout(()=> alertEl.remove(), 3000);

}


// 7. 
function addCommasToNumber(number){
// regular expression search stack overflow for javascript functions to add commas to a number..add a comma after every 3 zeros e.g. 000,000.

return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

}

// Init App (very simple router to check which page we are on)

function init(){
switch(global.currentPage){
case '/':
case '/index.html':
// console.log('Home');
displaySlider();
displayPopularMovies();
break; 
case '/shows.html':
// console.log('Shows');
displayPopularShows() //calling the function here to display TV shows in the DOM
break;
case '/movie-details.html':
// console.log('Movie Details');
displayMovieDetails();
break;
case '/tv-details.html':
// console.log('TV Details');
displayShowDetails();
break;
case 'search.html':
search(); // 13.
break;
}

highlightActiveLink()


}

// init()
document.addEventListener('DOMContentLoaded',  init);



// ***Web Browser API's***

// Can use without any third party library's because it is available in the browser. We already looked at fetch, local storage even the console which is a web api. We will look at:

// Geolocation API (user location coordinates we can also plot it on a map using leaflet js, a mobile friendly interactive map) 
// Canvas (draw in the browser and we can animate it)
// requestAnimationFrame() on the window object to create and animate. 
// Web Audio
// Web Video
// Web Animation API (create animations in pure javascript without css and you can also control them with a play, pause, make it go faster, slower)
// Speech API (two parts with Recognition and Synthesis)






// ***GeoLocation API***
// (allows us to get a user's location with their permission available on the global window object. There is an object called navigator thats where we can use geolocation it is not a third party library)

// There is two main methods:
geolocation.getCurrentPosition(); // retrieve your devices location

geolocation.watchPosition() //register a handler function that calls as your position updates. If you have a mobile device and you are moving and you can track that location e.g. your location to the nearest hotel or weather api anything location specific .

// In the window object you can see navigator and the geolocation which has getCurrentPosition, watchPosition and clearWatch. 


navigator.geolocation.getCurrentPosition();

// This will take in three possible arguments a success callback and the location is received, error is something goes wrong that will be a function and a options object.




 // code for getCurrentPosition()

 function curSuccess(position){
  console.log(position)

  const coords = position.coords 

  console.log(`Latitude: ${coords.latitude}`)
  console.log(`Longitude: ${coords.longitude}`)
  console.log(`Accuracy within: ${coords.accuracy} Meters`)
}


function curError(error){
console.log(`Error: ${error.code} - ${error.message}`)
}

const curOptions = {
enableHighAccuracy: true, //Use GPS if available
timeout: 5000, //time to wait to stop trying for location
maximumAge: 0, //Do not use a cached position 
} 

navigator.geolocation.getCurrentPosition(curSuccess, curError, curOptions);




// code for watchPosition() 
//fires off when our location changes:

const target = {
  latitude: 41.3874387,
  longitude: -71.394839,
}


 function watchSuccess(position){
  // console.log(position)

  const coords = position.coords 
  console.log(coords)

  if(target.latitude === coords.latitude && target.longitude === coords.longitude){

    console.log('You have reached your destination')
    navigator.geolocation.clearWatch(id);  
  }

}


function watchError(error){
console.log(`Error: ${error.code} - ${error.message}`)
}

const watchOptions = {
enableHighAccuracy: true, //Use GPS if available
timeout: 5000, //time to wait to stop trying for location
maximumAge: 0, //Do not use a cached position 
} 


// there is a method called clearWatch() what we need to do is that watchPosition will return an id that we can use to stop it from watching    
const id = navigator.geolocation.watchPosition(
  watchSuccess, 
  watchError, 
  watchOptions
  );




  
  // ***Show Location on a Map***
  // https://leafletjs.com/download.html

  // <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  
  // <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  // <style>
  // #map {
  // width: 600px;
  // height: 600px;
  // }
  // </style>

  // <body>
  // <div id="map"></div>
  // </body>


// Javascript Show Location on a Map (Example)
  
// https://leafletjs.com/index.html
// cut and past code in the overview tab 

const map = L.map('map').setView([0, 0], 2);

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

// L.marker([51.5, -0.09]).addTo(map)
//     .bindPopup('A pretty CSS popup.<br> Easily customizable.')
//     .openPopup();



// start coding here:

// marker location 
const marker = L.marker([0, 0]).addTo(map);

// get location then change the marker coordinates to our location 

navigator.geolocation.getCurrentPosition(function(position){

    const latitude = position.coords.latitude;
    const longitude = position.coords.longitude;


    // library methods from leafletjs setLatLng update() addTo() marker()
    marker.setLatLng([latitude, longitude]).update();

    map.setView([latitude, longitude], 13);

    marker.bindPopup('<strong>Hello World</strong> <br> This is my location').openPopup();;


});


// ***Canvas Element & API***

// draw graphics via javascript html5 specification imported on all modern browsers. It is used alot for animations, data visualisation, phot manipulation. It is a 2D rendering context and this context is created by the canvas element. 

// We have a HTML tag called canvas which you an set a width and a height. 
// <canvas id="my-canvas" width="600" height="600"></canvas> 

// we need to bring the element in and then we are going to create a context for our canvas.

const canvas = document.getElementById('my-canvas') 

// create our context and we use this context object to do pretty much everything to draw, fill in colors etc. 

// canvas element there is a getContext() method and we pass in a string of '2d' so now we have a 2d context to work with. 
const ctx = canvas.getContext('2d')

//start with drawing a simple triangle

//fillStyle is if you want to fill something in, there is also strokeStyle which is more the color of the line or the border, color you can use rgb or hexadecimal e.g. #f5f5f5


// Draw Rectangle 

ctx.fillStyle = 'green'
// x, y position e.g. x = 10px, y = 10px (10px out from the x and y border) 
// ctx.fillRect(x, y, width, height)
ctx.fillRect(10, 10, 150, 100);


// Draw Circle (circles use the arc() method)

ctx.fillStyle = 'red';
// ctx.arc(x, y, radius, start angle, end angle)
ctx.arc(300, 300, 100, 0, Math.PI * 2);
// end angle is Math.PI and multiply * 2. This is because we are using radian. One complete revolution around a circle is equal to two times pi radian so that should give us a full circle with 100 radius.

// radian meaning a unit of plane angular measurement that is equal to the angle at the center of a circle subtended by an arc equal in length to the radius.

ctx.fill(); 
// if we only use fill() and do not use fillStyle it will use the last ctx.fillStyle = 'green'. To change the color ctx.fillStyle = 'red' which has to be above ctx.fill() for the styling to work.

// We can save fillStyle, strokeStyle and restore it at a later point.  


// Draw lines

ctx.beginPath(); //starts 0 
ctx.strokeStyle = 'orange' //uses strokeStyle not fillStyle for lines
ctx.moveTo(10, 10) //x, y (start position wont draw output)
ctx.lineTo(300, 300) //x, y (end position WILL draw output)
ctx.lineWidth = 5
ctx.stroke() //call stroke draws it on the page



// Draw text

ctx.font = '30px Arial' // size and style of font
ctx.fillStyle = 'blue'
// ctx.fillText('text', x, y, max-width-text)
ctx.fillText('Hello World', 300, 100, 300)



// ctx.strokeText('Hello World', 300, 500, 300) //outline border text with no fill.

// The fillStyle doesn't apply because it is strokeStyle 
ctx.strokeStyle = 'blue'
// was using the last ctx.lineWidth = 5 
ctx.lineWidth = 1
ctx.strokeText('Hello World', 300, 500, 300) //outline border text with no fill.



// Draw Image into the Canvas


// HTML 
// <img src="ball.png" width="100" height="100" alt=""/>

const image = document.querySelector('img');
image.style.display = 'none' 
// with images because we are using an external resource we want to wait until it loads until we put the image on.


// ctx.drawImage(image, x, y, width, height)
image.addEventListener('load', () => ctx.drawImage(image, 250, 250, 100, 100));







// ***requestAnimationFrame() Method***


// window.requestAnimationFrame()

// It tells the browser that you wish to perform an animation and request that the browser call a specific function to update an animation before the next repaint. Each step in the animation the browser or the screen is getting repainted. It takes a callback to be invoked before the repaint.



const image = document.querySelector('img') 
let start;
let done = false; //when we want to stop the animation then done should be set to true


// takes in a timestamp from the time when it starts and counts up as it goes in milliseconds.
function step(timestamp){

  if(start === undefined){
    start = timestamp;
  }

  const elapsed = timestamp - start;
  // console.log(elapsed, 'elapsed')

  if(elapsed > 5000){
    done = true;
  };

  if(done){
    return;
  };


  // console.log('Hello');
  // call the request animation frame method and pass in the step function as an argument and this will tell the browser to call the step function before the next repaint 
  
  // console.log(timestamp, 'timestamp');

  // console.log(elapsed, 'elapsed') 

  image.style.transform = `translateX(${elapsed / 10}px) rotate(${elapsed / 10}deg)`

  // 2.
  // can call the requestAnimationFrame in here aswell calling this recursively calling step again so what will happen it it is going to keep repainting it keeps console logging so in here we can do some cool animations. 
  requestAnimationFrame(step) 

} 

  // 1.
  requestAnimationFrame(step)
  // we request the browser to call the step function before the next repaint and there was one repaint in the console called Hello.  





// ***Animated Clock - Part 1***

// HTML 
<body>
<canvas id="canvas" width="500" height="500"></canvas>
</body>


// Javascript 

function clock() {

const now = new Date()
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d');

// setup canvas 

// start (all of our code goes between ctx.save() at the start and to the end ctx.restore()) 
ctx.save(); // save the default state

//each thing we do e.g. draw the clock face, draw the hour or minute marks we will save and restore before and after that functionality because we are using animation and the screen keeps getting repainted so we have to restore the default state before the next repaint or we are going to have 500 second hands, we basically want to wipe it clean and restore the default state before and after everything and before and after we draw certain aspects of the clock.

// we want to wipe everything clean so we can do that with a method called clearRect() it will clear a rectangle the size that we specify.


// remember everything we put in the clock function is going to run on every single repaint of the screen so we need to clear the whole rectangle.

// ctx.clearRect(x, y, width, height)
ctx.clearRect(0, 0, 500, 500)

// we want the clock in the middle on the canvas
ctx.translate(250, 250) //it will make the x of 0 and y of 0 in the middle of the page

// rotate the clock negative -90 degrees otherwise it is not going to tell the correct time otherwise it will be in a weird rotation and not tell the time properly

ctx.rotate(-Math.PI / 2) //rotate clock -90deg


// set default style strokeStyle, fillStyle, lineWidth etc.

ctx.strokeStyle = '#000000';
ctx.fillStyle = '#f4f4f4';
ctx.lineWidth = '5';
ctx.lineCap = 'round'; //rounded line end



// draw clock face border 
ctx.save() //when you call save it will save the state everything before it

ctx.beginPath() 
ctx.lineWidth = 14

ctx.strokeStyle = '#800000' // this will only apply within save() above and the first restore() below, if I do a strokeStyle outside the default will apply.  

// ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise)
ctx.arc(0, 0, 142, 0, Math.PI * 2, true);
ctx.stroke() // to draw output
ctx.fill();
ctx.restore(); //need to restore() the state because we will be changing the strokeStyle, fillStyle, lineWidth etc. However it is not going to change the default above the save()


// draw hour marks lines  

ctx.save()
for (let i=0; i<12; i++){

  ctx.beginPath()
  ctx.rotate(Math.PI / 6) //gives double output 12 if just Math.PI it will give 2 instead of 1
  ctx.moveTo(100, 0) //x, y
  ctx.lineTo(120, 0) //x, y   
  ctx.stroke()
  // the dot is in the center becuae of above the translate ctx.translate(250, 250) also we rotate(-Math.PI / 2) the clock -90deg so the x axis is now the y axis.  
}
ctx.restore()



// draw minute marks lines  
ctx.save()
ctx.lineWidth = 4
for (let i=0; i<60; i++){

//no minute line where there is an hour line
  if(i % 5 !== 0){ 
    ctx.beginPath()
    ctx.moveTo(117, 0) //x, y
    ctx.lineTo(120, 0) //x, y   
    ctx.stroke()
    // the dot is in the center becuae of above the translate ctx.translate(250, 250) also we rotate(-Math.PI / 2) the clock -90deg so the x axis is now the y axis.  
  }

  ctx.rotate(Math.PI / 30) //we still want it to rotate on every iteration so by putting it outside the if statement will still hit all lines including the hour ine  


}
ctx.restore()


// get current time 

const hours = now.getHours() % 12;
const minutes = now.getMinutes();
const seconds = now.getSeconds();

console.log(`${hours}:${minutes}:${seconds}`)



// draw hour hand 
ctx.save()

// will always be in a different position depending on the hour to get the specific position need to put it in an equation

ctx.rotate((Math.PI / 6) * hours + (Math.PI / 360) * minutes + (Math.PI / 21600) * seconds);
// 21600 number of seconds in a day

ctx.strokeStyle = '#800000';
ctx.lineWidth = 14
ctx.beginPath()
ctx.moveTo(-20, 0)
ctx.lineTo(80, 0)
ctx.stroke()
ctx.restore()



// draw minutes hand 
ctx.save()

// will always be in a different position depending on the minutes to get the specific position need to put it in an equation

ctx.rotate((Math.PI / 30) * minutes + (Math.PI /1800) * seconds);


ctx.strokeStyle = '#800000';
ctx.lineWidth = 10
ctx.beginPath()
ctx.moveTo(-28, 0)
ctx.lineTo(100, 0)
ctx.stroke()
ctx.restore()



// draw seconds hand 
ctx.save()

// will always be in a different position depending on the minutes to get the specific position need to put it in an equation

ctx.rotate((seconds * Math.PI / 30));
ctx.strokeStyle = '#FF7F50';
ctx.fillStyle = '#FF7F50'
ctx.lineWidth = 6
ctx.beginPath()
ctx.moveTo(-30, 0)
ctx.lineTo(100, 0)
ctx.stroke()
ctx.beginPath()
ctx.arc(0, 0, 10, 0, Math.PI * 2, true)
ctx.fill()
ctx.restore()


ctx.restore(); // restore default state
// end

requestAnimationFrame(clock)
}

// clock();
requestAnimationFrame(clock)





// ***Animated Clock - Part 2***
// change colors and download


const canvas = document.getElementById('canvas')

const faceColor = document.getElementById('face-color')
const borderColor = document.getElementById('border-color')
const lineColor = document.getElementById('line-color')
const largeHandColor = document.getElementById('large-hand-color')
const secondHandColor = document.getElementById('second-hand-color')

function clock() {

  const now = new Date()
  const ctx = canvas.getContext('2d');
  
  // setup canvas 
  
  
  ctx.save(); 
  
  // ctx.clearRect(x, y, width, height)
  ctx.clearRect(0, 0, 500, 500)
  
  ctx.translate(250, 250) 
  
  ctx.rotate(-Math.PI / 2) //rotate clock -90deg
  
  
  // set default style strokeStyle, fillStyle, lineWidth etc.
  ctx.strokeStyle = '#000000';
  ctx.fillStyle = '#f4f4f4';
  ctx.lineWidth = '5';
  ctx.lineCap = 'round'; //rounded line end
  
  
  
  // draw clock face border 
  ctx.save() //when you call save it will save the state everything before it
  
  ctx.beginPath() 
  ctx.lineWidth = 14

  //change border color
  ctx.strokeStyle = borderColor.value 
  
  //change face color
  ctx.fillStyle = faceColor.value 
  
  // ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise)
  ctx.arc(0, 0, 142, 0, Math.PI * 2, true);
  ctx.stroke() // to draw output
  ctx.fill();
  ctx.restore(); 
  
  
  // draw hour marks lines  
  ctx.save()

  // change hour marks lines
  ctx.strokeStyle = lineColor.value

  for (let i=0; i<12; i++){
  
    ctx.beginPath()
    ctx.rotate(Math.PI / 6) //gives double output 12 if just Math.PI it will give 2 instead of 1
    ctx.moveTo(100, 0) //x, y
    ctx.lineTo(120, 0) //x, y   
    ctx.stroke()
    // the dot is in the center becuase of above the translate ctx.translate(250, 250) also we rotate(-Math.PI / 2) the clock -90deg so the x axis is now the y axis.  
  }
  ctx.restore()
  
  
  
  // draw minute marks lines  
  ctx.save()
  ctx.strokeStyle = lineColor.value

  ctx.lineWidth = 4
  for (let i=0; i<60; i++){
  
  //no minute line where there is an hour line
    if(i % 5 !== 0){ 
      ctx.beginPath()
      ctx.moveTo(117, 0) //x, y
      ctx.lineTo(120, 0) //x, y   
      ctx.stroke()
      
    }
  
    ctx.rotate(Math.PI / 30) //we still want it to rotate on every iteration so by putting it outside the if statement will still hit all lines including the hour ine  
  
  
  }
  ctx.restore()
  
  // get current time 
  
  const hours = now.getHours() % 12;
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  
  // console.log(`${hours}:${minutes}:${seconds}`)
  
  
  // draw hour hand 
  ctx.save()
  
  // will always be in a different position depending on the hour to get the specific position need to put it in an equation
  
  ctx.rotate((Math.PI / 6) * hours + (Math.PI / 360) * minutes + (Math.PI / 21600) * seconds);
  // 21600 number of seconds in a day
  
  // change hour hand color 
  ctx.strokeStyle = largeHandColor.value;
  ctx.lineWidth = 14
  ctx.beginPath()
  ctx.moveTo(-20, 0)
  ctx.lineTo(80, 0)
  ctx.stroke()
  ctx.restore()
  
  
  
  // draw minutes hand 
  ctx.save()
  
  // will always be in a different position depending on the minutes to get the specific position need to put it in an equation
  
  ctx.rotate((Math.PI / 30) * minutes + (Math.PI /1800) * seconds);
  
  // change minutes hand color 
  ctx.strokeStyle = largeHandColor.value;
  ctx.lineWidth = 10
  ctx.beginPath()
  ctx.moveTo(-28, 0)
  ctx.lineTo(100, 0)
  ctx.stroke()
  ctx.restore()
  
  
  
  // draw seconds hand 
  ctx.save()
  
  // will always be in a different position depending on the minutes to get the specific position need to put it in an equation
  
  ctx.rotate((seconds * Math.PI / 30));

  // change second hand color 
  ctx.strokeStyle = secondHandColor.value
  ctx.fillStyle =  secondHandColor.value
  ctx.lineWidth = 6
  ctx.beginPath()
  ctx.moveTo(-30, 0)
  ctx.lineTo(100, 0)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(0, 0, 10, 0, Math.PI * 2, true)
  ctx.fill()
  ctx.restore()
  
  
  ctx.restore(); // restore default state
  // end
  
  requestAnimationFrame(clock)
  }
  
  // clock();
  requestAnimationFrame(clock)




//  ***Download Image (toDataURL() method)***

  document.getElementById('save-btn').addEventListener('click', ()=>{

    const dataURL = canvas.toDataURL('image/jpeg') // what type of image or date we want this to be when we download
    const link = document.createElement('a'); // create a link and click that link when we click the button
    link.download = 'clock.jpeg' // set link.download window object to what we want to call the name file when we download.
    link.href = dataURL //the href of that link is equal to the dataURL that we created for the toDataURL('image/jpeg') on the canvas
    link.click(); //click that link we can fire off events we are calling click on this link
  });


  // ***Web Audio API***
  // HTML5 has an audio element we can use and there is a javascript api that allows us to control that audio, play pause stop. We can get the timestamp change the volume. You can also create an audio context and add filters, create oscillators.
  

  // HTML 
  // if you want to embed music 
  <audio src="summer.mp3" controls"></audio>


  // <body>
  <audio src="summer.mp3" id="audio"></audio>
  <button id="play">Play</button>
  <button id="pause">Pause</button>
  <button id="stop">Stop</button>
  <div id="current-time"></div>

  // set between 0 and 1 
  <input type="range" id="volume" min="0" max="1" step="0.01" value="'1" /> 
  // </body>

  // javascript 

  
const audio = document.getElementById('audio')
const play = document.getElementById('play')
const pause = document.getElementById('pause')
const stop = document.getElementById('stop')
const currentTime = document.getElementById('current-time')
const volume = document.getElementById('volume')

play.addEventListener('click', ()=> audio.play())
pause.addEventListener('click', ()=> audio.pause())
stop.addEventListener('click', ()=> { //no stop method
  audio.pause();
  audio.currentTime = 0  
})

// current time 
audio.addEventListener('timeupdate', ()=>{
  currentTime.innerText = audio.currentTime
});

// volume 
volume.addEventListener('change', ()=>audio.volume = volume.value) //volume value between 0 and 1






// ***Music Player Project***


const musicContainer = document.getElementById('music-container');
const playBtn = document.getElementById('play');
const prevBtn = document.getElementById('prev');
const nextBtn = document.getElementById('next');
const audio = document.getElementById('audio');
const progress = document.getElementById('progress');
const progressContainer = document.getElementById('progress-container');
const title = document.getElementById('title');
const cover = document.getElementById('cover');

// create arrays of song titles
// const songs = ['0', '1', '2']; //index
const songs = ['hey', 'summer', 'ukulele'];

// keep track of song
let songIndex = 2; //ukulele set as default

//initially load song details including the image, name, audio.

//create a function called loadSong while calling the (songs) array with the [songIndex] set from above which is ukulele as default.

loadSong(songs[songIndex]);

function loadSong(song) {
  // update the title
  title.innerText = song;

  // html <audio src="music/ukulele.mp3" id="audio"></audio> located in the music folders
  audio.src = `music/${song}.mp3`;

  // html <img src="images/ukulele.jpg" alt="music-cover" id="cover" /> located in the images folder
  cover.src = `images/${song}.jpg`;
}

function playSong() {
  //take the music container add the class of play
  musicContainer.classList.add('play');

  // remove play add pause icon
  playBtn.querySelector('i.fas').classList.remove('fa-play');
  playBtn.querySelector('i.fas').classList.add('fa-pause');

  // play audio
  audio.play();
}

function pauseSong() {
  //take the music container remove the class of play
  musicContainer.classList.remove('play');

  // remove pause add play icon
  playBtn.querySelector('i.fas').classList.remove('fa-pause');
  playBtn.querySelector('i.fas').classList.add('fa-play');

  // pause audio
  audio.pause();
}

function prevSong(){

songIndex--;

//if first song want to go the last song 
if(songIndex < 0){
  songIndex = songs.length -1 //arrays are 0 based and we want 3 
}
loadSong(songs[songIndex])

playSong()
}


function nextSong(){

  songIndex++;
  
  //if last song want to go the first song 
  if(songIndex > songs.length - 1){
    songIndex = 0
  }
  loadSong(songs[songIndex])
  
  playSong()
  }

  function updateProgress(e){
  // <audio src="music/ukulele.mp3" id="audio"></audio> 

  // e.srcElement //gives the src element of the audio we want to get from that or destructure from that the duration of the audio song and the current time, duration is entire time the song takes the current time is at the specific point we are at in the song. We need to get a percentage of how much of the song is done because that is what we set the progress bar with to in the output.  
  
  const { duration, currentTime } = e.srcElement;
  const progressPercent = (currentTime / duration) * 100;
  progress.style.width = `${progressPercent}%`
  }

//want to go to the progress bar and click on it and change the time

function setProgress(e){
const width = this.clientWidth 
const clickX = e.offsetX;
const duration = audio.duration

audio.currentTime = (clickX / width) * duration
}



playBtn.addEventListener('click', () => {
  // check to see if playing to see if the id of play is on the music container div
  const isPlaying = musicContainer.classList.contains('play'); //if it true it is playing

  if (isPlaying) {
    pauseSong();
  } else {
    playSong();
  }
});


prevBtn.addEventListener('click', prevSong)
nextBtn.addEventListener('click', nextSong)

// progress bar 
// timeupdate event is fired when the time indicated by the currentTime attribute has been updated. This event is not cancelable and does not bubble. These examples add an event listener for the HTMLMediaElements.

audio.addEventListener('timeupdate', updateProgress) //show how much time the song has played

progressContainer.addEventListener('click', setProgress)





// ***Drum Machine Project***

// HTML Drum Machine Project

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
  
    
    <script src="./script.js" defer></script>
    <title>Drum Machine</title>
  </head>
  <body>

    
    <header>
      <h1>Drum Machine</h1>
    </header>
    
    <div class="keys">

      <div data-key="65" class="key">
        <kbd>A</kbd>
        <span class="sound">clap</span>
      </div>


      <div data-key="83" class="key">
        <kbd>S</kbd>
        <span class="sound">hihat</span>
      </div>


      <div data-key="68" class="key">
        <kbd>D</kbd>
        <span class="sound">kick</span>
      </div>
      
      <div data-key="70" class="key">
        <kbd>F</kbd>
        <span class="sound">openhat</span>
      </div>

      <div data-key="71" class="key">
        <kbd>G</kbd>
        <span class="sound">boom</span>
      </div>

      <div data-key="72" class="key">
        <kbd>H</kbd>
        <span class="sound">ride</span>
      </div>

      <div data-key="74" class="key">
        <kbd>J</kbd>
        <span class="sound">snare</span>
      </div>

      <div data-key="75" class="key">
        <kbd>K</kbd>
        <span class="sound">tom</span>
      </div>

    </div>

    <audio data-key="65" src="sounds/clap.wav"></audio>
    <audio data-key="83" src="sounds/hihat.wav"></audio>
    <audio data-key="68" src="sounds/kick.wav"></audio>
    <audio data-key="70" src="sounds/openhat.wav"></audio>
    <audio data-key="71" src="sounds/boom.wav"></audio>
    <audio data-key="72" src="sounds/ride.wav"></audio>
    <audio data-key="74" src="sounds/snare.wav"></audio>
    <audio data-key="75" src="sounds/tom.wav"></audio>
  </body>
</html>


// Javascript Drum Machine Project

window.addEventListener('keydown', playSound);

function playSound(e) {

  console.log(e.keyCode)

  const audio = document.querySelector(`audio[data-key="${e.keyCode}"]`);
  
  const key = document.querySelector(`.key[data-key="${e.keyCode}"]`);

  // console.log(audio, key)

  if (!audio) return;

  audio.currentTime = 0;

  audio.play();

  key.classList.add('playing');

  setTimeout(() => {
    key.classList.remove('playing');
  }, 100);

   
}


// ***Video API***
// HTML Video API

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Video API</title>

    <script src="script.js" defer></script>
  </head>
  <body>
    
    <video
      id="video"
      src="media/clouds.mov"
      width="500"
      poster="media/poster.png"
      // controls
      // autoplay 
      // muted
      // loop
    ></video>

    <div>
      <button id="play">Play</button>
      <button id="pause">Pause</button>
      <button id="stop">Stop</button>
      <div id="current-time"></div>
    </div>
  </body>
</html>

// Javascript Video API

const video = document.getElementById('video')
const play = document.getElementById('play')
const pause = document.getElementById('pause')
const stop = document.getElementById('stop')
const currentTime = document.getElementById('current-time')


play.addEventListener('click', ()=> video.play());
pause.addEventListener('click', ()=> video.pause());
stop.addEventListener('click', ()=> {
video.pause()
video.currentTime = 0;  
});

// get the time 
video.addEventListener('timeupdate', () => (currentTime.innerText = video.currentTime));


// ***Video Player Project***
// HTML Video Player Project

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Custom Video Player</title>
    <link
      href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
      rel="stylesheet"
      integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="style.css" />

    <script src="script.js" defer></script>
  </head>
  <body>

    <video
      src="media/clouds.mov"
      poster="media/poster.png"
      id="video"
      class="screen"
    ></video>

    <div class="controls">
      <button class="btn" id="play">
        <i class="fa fa-play fa-2x"></i>
      </button>

      <button class="btn" id="stop">
        <i class="fa fa-stop fa-2x"></i>
      </button>

      <input
        type="range"
        id="progress"
        class="progress"
        min="0"
        max="100"
        step="0.1"
        value="0"
      />

      <span class="timestamp" id="timestamp">00:00</span>
    </div>

  </body>
</html>

// Javascript Video Player Project


const video = document.getElementById('video');
const play = document.getElementById('play');
const stop = document.getElementById('stop');
const progress = document.getElementById('progress');
const timestamp = document.getElementById('timestamp');


function playPause(){
if(video.paused){ //property called paused
video.play()
}else{
video.pause();
}
}


function updateIcon(){
if(video.paused){ //property called paused
play.innerHTML = '<i class="fa fa-play fa-2x"></i>'

}else{
  play.innerHTML = '<i class="fa fa-pause fa-2x"></i>'
}
}

function stopVideo(){
video.currentTime = 0
video.pause() 


}

function updateProgress(){ //range input previous audio project it was a div
progress.value = (video.currentTime / video.duration) * 100

//get time
//get minutes

let minutes = Math.floor(video.currentTime / 60)
// by default it is not going to have a 00:00 if it is from 1 to 9

if(minutes < 10){ //will not have the 0's
minutes = '0' + String(minutes) //miuntes set to a string of 0 and concatenate + a String(minutes) of whatever minutes is...   
}

let seconds = Math.floor(video.currentTime % 60)
if(seconds < 10){ //will not have the 0's
seconds = '0' + String(seconds) //seconds set to a string of 0 and concatenate + a String(seconds) of whatever seconds is...
}

timestamp.innerHTML = `${minutes}:${seconds}`
}


function setProgress(){

  video.currentTime = (+progress.value * video.duration) / 100 //progress.value is coming in as a string so want it as a number so can multiply it with video.duration
}

video.addEventListener('click', playPause)
play.addEventListener('click', playPause)
video.addEventListener('pause', updateIcon) // there is an event called pause

video.addEventListener('timeupdate', updateProgress)

video.addEventListener('play', updateIcon)
stop.addEventListener('click', stopVideo) 
progress.addEventListener('click', setProgress) 






// ***Web Animations API - Ball Project***


const ball = document.getElementById('ball')
const play = document.getElementById('play')
const pause = document.getElementById('pause')
const reverse = document.getElementById('reverse')
const speedUp = document.getElementById('speed-up')
const slowDown = document.getElementById('slow-down')


// array of animation 

const rollAnimation = [
{
transform: 'rotate(0) translate3D(-50%, -50%, 0)',
color: 'white',
},
{
color: 'blue',
offset: 0.3,
},
{
transform: 'rotate(360deg) translate3D(-50%, -50%, 0)',
color: 'white',
}
]


const rollOptions = {
duration: 3000,
iterations: Infinity
}


const roll = ball.animate(rollAnimation, rollOptions)

play.addEventListener('click', ()=>{
  roll.playbackRate = 1 //can press play when in reverse
  roll.play()

})


pause.addEventListener('click', ()=>roll.pause())
reverse.addEventListener('click', ()=>roll.reverse()) //reverse will go as many times that it went forward can toggle the reverse button

speedUp.addEventListener('click', ()=> roll.playbackRate = roll.playbackRate * 2)
slowDown.addEventListener('click', ()=> roll.playbackRate = roll.playbackRate * 0.5)




// ***Speech Recognition API - Color Say Project***

const SpeechRecognition =
  window.SpeechRecognition || window.webkitSpeechRecognition;

const rec = new SpeechRecognition();

rec.lang = 'en-GB';

rec.continuous = true; //false it listens and then stops, true listen but keep listening 


rec.onresult = function(e){
  // console.log(e.results)
  // console.log(e.results[0][0].transcript)


  const acceptedColors = [
    'red',
    'blue',
    'green',
    'yellow',
    'pink',
    'brown',
    'purple',
    'orange',
    'black',
    'white',
  ];


  // resultIndex SpeechRecognitionEvent 
  for(let i = e.resultIndex; i < e.results.length; i++){
    const script = e.results[i][0].transcript.toLowerCase().trim() 
    //[i] dynamic whatever that i variable is going to be and the second [0] is the first element in there it is an object that has a transcript on it and that is what we say. toLowerCase() in case the text has upper cases and trim to get rid of any whitespace. The reason why is because they have to be colors that match a color in the accepted colors array  
    
    // console.log(script)

    if(acceptedColors.includes(script)){
      document.body.style.backgroundColor = script;
    }else{
      alert('Please say a color?')
    }
  }
}

rec.start()





// ***Speech Synthesis API - Text To Speech***


// voice select in both functions
const voiceSelect = document.getElementById('voice-select')

const synth = window.speechSynthesis;

let voices; 

// two functions submit to have it speak and the other is to fill select box with voices.


// 2
function addVoicesToSelect(){

  // getVoices() returns a list of SpeechSynthesisVoice objects representing all the available voices.
  voices = synth.getVoices()

  // loop through the voices fill the select box with options

  for(let i = 0; i < voices.length; i++){
    const option = document.createElement('option');

    option.textContent = `${voices[i].name} ${voices[i].lang}`;

    if(voices[i].default){
      option.textContent += ' -DEFAULT';
    }

    option.setAttribute('data-lang', voices[i].lang)
    option.setAttribute('data-name', voices[i].name)

    voiceSelect.appendChild(option)

  }
}

// 1
function onSubmit(e){
  e.preventDefault();

  const textInput = document.getElementById('text-input') //could add set it to the .value usually like to set it to the element and use the value where you need it.

  // console.log(textInput.value) //we need to pass it into our constructor function called speech synthesis utterance

  const utterThis = new SpeechSynthesisUtterance(textInput.value)


  // 3. add the names in list to the different voices

  const selectOption = voiceSelect.selectedOptions[0].getAttribute('data-name'); 
  // selectedOptions contains a list of the <option> elements contained within the <select> element that are currently selected. The list of selected options is an HTMLCollection object with one entry per currently selected option, selectedOptions is a HTMLSelectElement other examples of HTMLSelectElement: https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement

  // loop through the voices 
  for(let i = 0; i < voices.length; i++){

    if(voices[i].name === selectOption){
      utterThis.voice = voices[i];
    }

  }

synth.speak(utterThis)

}

addVoicesToSelect()

if(speechSynthesis.onvoiceschanged !== undefined){
  speechSynthesis.onvoiceschanged = addVoicesToSelect;
}

document.getElementById('form').addEventListener('submit', onSubmit)











// *** OOP - Constructors & Prototypes***

// -Section Intro-

// Object Oriented Programming or `OOP` used in JavaScript is a **programming paradigm**. A programming paradigm is a way of thinking about programming, and a way of structuring your code, dumb it down to the word "style". There are different programming paradigms most common are `procedural`, `object-oriented` and `functional`. You can read more about paradigms (https://www.freecodecamp.org/news/what-exactly-is-a-programming-paradigm/)

// What we have been doing so far is mostly `procedural` programming, although, we have definitely used some elements of `OOP` and even `functional` programming. JavaScript is an extremely flexible language and you can do things in many different ways.

// In `procedural` programming, we write functions that perform actions, and we call those functions to perform those actions.

// In `object-oriented` programming, we write objects that contain both data and functions or methods and we interact with those objects to perform actions. Some languages force you to write all of your code within objects.

// - What Is An Object? -

// An object is a 'self-contained' piece of code and is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method. So, essentially, an object is a **collection of properties and methods**. Objects are used as building blocks and can interact with one another.

// We have already had some experience working with objects such as `Math` and `Date`. In fact, just about everything in JavaScript is an object. 

// Primitive data types like strings and numbers are not objects, however they are treated like objects when we use methods like `toUpperCase()`. When we use a method like that on a string, JavaScript is actually creating a temporary object behind the scenes to perform the action. This is called a `wrapper object`.

// JavaScript has many ways to create objects including object literals, constructor functions, which we'll be covering soon, classes, factories, etc.

// Any entity in your application could be an object. For example, if you are building a blog, you might use objects like `users` and `posts`. Just to give you a better idea of what would we look at as an object, here is a list of random objects:

// - `user`
// - `post`
// - `comment`
// - `UI component`
// - `product`
// - `order`
// - `cart`
// - `customer`
// - `employee`
// - `message`
// - `book`

// - Why Use OOP? -

// It makes your code easier to understand and easier to maintain. It helps prevent what we call 'Spaghetti Code`. OOP is also very flexible and can be used to build complex applications. It is also very easy to reuse code in OOP.

// - When To Use OOP -

// When building a complex application and will need multiple instances of an object. It's also helpful if youre working on a team. If you are building a relatively simple application, you probably should not use OOP. When I say I would not use OOP, I mean I wouldn't create custom classes or constructor functions. In JavaScript, we're always using objects, so we're always using some aspect of OOP.

// - Components of OOP -

// We have been using `object literals`. However, I wouldn't call that `OOP`. To create a single object and structure data into key/value pairs. With OOP, we create blueprints to create multiple instances of an object. 

// OOP within JavaScript is a bit different than most languages. A lot of that has to do with the inner mechanics and the browser environment.

// In JavaScript, we use something called `constructor functions` as well as `prototypes`. With these we can create blueprints to create objects. Most languages use `classes`. JavaScript doesn't use classes in the core language, however, the ES6 update gave us the class syntax, called `syntactic sugar`. It makes it easier to write class syntax, but it's really using constructors and prototypes under the hood. 

// Some important components of OOP in JavaScript are:

// - `Constructor Functions` Are the way that JavaScript creates a blueprint for an object.

// - `Prototypes` A way for objects to inherit properties and methods from one another.

// - `Classes` Another way to create a blueprint for an object. They are not a part of the core JavaScript language, but they are a part of the `ES6` specification. So we can use classes as a type of syntactic sugar to make our code easier to read and write. Classes are a core part of many other languages.

// - `Instances` Objects are instantiated new objects from a blueprint like a constructor or a class. This way we can create multiple objects that all have their own property values and can share the same methods. 

// The class alone is just the blueprint. It's useless in our code if we don't use it. You can think of it just like a blueprint for a house. The blueprint is just a piece of paper, it's not a house. We have to use the blueprint to build the house. In this case, the blueprint is for a user and each user is the actual object. We can create as many users as we want using the blueprint.

// Now like I said, JavaScript doesn't actually have classes in the core language, it uses something called`constructor functions` and `prototypes`, but we can still write our code using classes and it get's transpiled into regular JavaScript. We will talk about both constructors, prototypes and classes in more detail later.





// ***4 Basic Principles of OOP***


// These principles are the foundation of OOP and are used in almost every OOP language.

// There are 4 basic principles of OOP that you should know about.

// - Abstraction
// - Encapsulation
// - Inheritance
// - Polymorphism


// - Abstraction - 

// Abstraction is where we hide all but the relevant parts of an object in order to reduce complexity and increase efficiency.

// The easiest way to explain and understand abstraction is to look at something like your car. As a user, do you really need to understand the details of what happens when you start your car? No, that's not your job. You don't need to know how it works. You just need to know how to use it. So you need to know about the ignition, gas, brakes, etc. You don't need to know how the fuel pump works to drive a car. That's abstraction. It's the process of hiding the details of how something works and only showing the the important parts.

// Since objects can get pretty large and complex, it's not usually possible to show the user all the details of how the object works. There also is no reason to. The user of the object should only see and access what they need.

// We deal with abstraction everywhere in programming. There are 100 things that I can think of that we have already done in this course that have used abstraction. For example, when we create an event listener, we use the `fetch()` method. We don't need to know exactly how it works. We just need to know how to use it. Even the public APIs that we have used also have a lot of abstraction. We just hit an endpoint. We have no clue what goes on behind the scenes. Another example is when we're working with events and call `addEventListener()` method. We don't need to know how the event listener works. We just need to know how to use it. As a programmer, you'll both use and create abstractions.

// One of the most useful things about abstraction is that is reduces the complexity of our code and the impact of change.

// If we have a class of `User` and we want to add a new property, we don't have to change the code everywhere that we use the `User` class. We can just add the new property to the class and it will be available everywhere.


// - Encapsulation - 

// Encapsulation is the process of wrapping up or bundling data and methods into a single unit such as a class or function.

// This concept is also often used to hide the properties or state of an object from the outside. This is called information hiding or data hiding. 

// When we create a class for example, the properties and methods are 'encapsulated' into that specific class. This is a way to keep our code organized and easy to understand. It also means that certain properties and methods are only accessible from within the class.

// Some languages have access modifiers like `private` and `public` keywords to indicate which properties and methods are accessible from the outside. JavaScript doesn't have those keywords, but the latest ES2022 update does include private fields using a `#` symbol. We'll look at that later.


// javascript using encapsulation e.g.

class Circle {
#radius;
constructor(value) {
this.#radius = value;
}
get area() {
return Math.PI * Math.pow(this.#radius, 2);
}
}

// The `radius` property is encapsulated into the `Circle` class. We can't access the `radius` property from outside the `Circle` class. So it's hidden from the outside world. We can access the `area` property from outside the class with what we call a `getter`. 

// Another example of encapsulation that you should already understand is the scope chain. When we create a variable within a function, it's encapsulated in that functions scope. We can't access it from the global or any higher level scope.




// -Inheritance-

// Inheritance is the process of inheriting the properties and methods from a parent class.

// This is a way to reuse code and reduce redundancy. We can create a parent class with some properties and methods, and then create child classes that inherit those properties and methods as well as have their own.

// Even when we work with elements in the DOM, all HTML elements share some common properties and methods. For example, all HTML elements have a `style` property and a `addEventListener()` method. We can create a parent class of `HTMLElement` that has those properties and methods. Then we can create child classes of `HTMLButtonElement`, `HTMLDivElement`, etc. that inherit those properties and methods. Now, we can create instances of the `HTMLButtonElement` class and use the `style` property and the `addEventListener()` method.


// javascript using inheritance e.g.
class User {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

class Admin extends User {
  deleteUser(user) {
    users = users.filter((u) => u.name !== user.name);
  }
}

// We have a class of `User` that has a property of `name` and a method of `sayHello()`. We can create a child class called `Admin` that inherits the `name` property and the `sayHello()` method. We can then add a new method to the `Admin` class called `deleteUser()`. Now, we can create an instance of the `Admin` class and use the `name` property, the `sayHello()` method, and the `deleteUser()` method.


// - Polymorphism - 

// The word `poly` means `many` and `morph` means `form`. SO it describes situations in which something occurs in several different forms. 

// This is a way to reuse code. It allows us to do away with long `if/else` or `switch` statements and use a single method that will work for different types of objects. A very common example of polymorphism is when we use the same method name for different types of objects.

// javascript using polymorphism e.g.
class User {
  constructor(name) {
    this.name = name;
  }index.
  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}
class Admin extends User {
  sayHello() {
    console.log(`Hello, my name is ${this.name}. I am an admin.`);
  }
}

// For instance, we have a `User` object with a `sayHello` method. Then we have an `Admin` class that extends the `User` class and also has a sayHello method that does something different. We could have 10 more classes with a `sayHello` and they all do something different. So we're using **many forms** of `sayHello` (poly morph)


// ***More on Object Literals & this Keyword*** 


// We have been working with `object literals` throughout this course. They are the simplest form of an object and great when you only need one instance of an object, which is usually the case when building simple applications. But what if you need to create multiple instances of an object? 

// That's where `constructor functions` comes in. But first, let's look at `object literals` a little closer. I also want to talk about the `this` keyword, which is used a lot in object oriented programming.

// Let's say that we have a program that works with shapes, for whatever reason. I want to create a `Rectangle` object. So I'll use an object literal in this case. Let's give it some properties.

// javascript example 
const rect = {
  name: 'Rectangle 1',
  width: 10,
  height: 10,
};


// We can easily access properties with dot notation
console.log(rect.name); // Rectangle 1

// This is nothing new right? We've been doing stuff like this all along. 

// One thing that we haven't done is adding a method to an object literal. Let's add a method to our `Rectangle` object that calculates the area of the rectangle.

const rect = {
name: 'Rectangle 1',
width: 10,
height: 10,
area: function () {
console.log('Show area');
},
};

// We can call the method like this:

rect.area(); // Show area


// - `this` keyword
// The `this` keyword is used to refer to the current object. Let's have our `area` method return the area of the rectangle, which would be `width * height`.

const rectangle = {
  name: 'Rectangle 1',
  width: 20,
  height: 10,
  // We can add methods to an object and use this keyword to access the properties of the object
  // area: () => { } //arrow function
  area: function(){
  return this.width * this.height; 
  },
};

console.log(rectangle.area()) // area() have to add parenthesis because method is a function

// We can access the properties of the object using `this`. Useful when you have multiple objects that have the same properties and methods. You can use the `this` keyword to access the properties of the current object.

// If you are in a method, it refers to the object that the method is part of. If you are in a function or the global scope, it refers to the global object, which is the `window` object in the browser.

// Let's go outside of the object literal and try to access the `this` keyword.

console.log(this); // Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}

// It gives us the window object. Remember, when we run our script, the first thing that the `execution context` does is create the `global object`, which is the `window` object in the browser. So `this` refers to the `window` object.


// - Object Literal Drawbacks -

// There are a few drawbacks to using object literals. The first is that you can't create multiple instances of the same object. Let's say that we want to create another rect object. We can't do this with an object literal. We need to basically just create a new one from scratch.


// Will have to recreate if you want to get another rectangle.
const rectangle2 = {
  name: 'Rectangle 2',
  width: 30,
  height: 20,
  // area: () => { } //arrow function
  area: function(){
  return this.width * this.height; 
  },
};

console.log(rectangle2.area()) // area() have to add parenthesis because method is a function

// Imagine if we needed to create 100 rects. We would have to create 100 different object literals. This is not very efficient. We need a way to create multiple instances of the same object. This is where `constructor functions` come in.



// ***Constructor Functions***

// If you need a way to create multiple instances of the same object? This is where constructor functions come in. You have classes but underneath classes you have constructor functions.

// Constructor functions are functions that are essentially blueprints to create new objects. They define properties and behaviors that will belong to the new object. 

// We have used constructor functions many times already. For instance, when we created a new `Date` object, we used the `Date` constructor function.

// const now = new Date();

// Date() is a constructor function wherever you see the word 'new' we are basically initialising a constructor function. We are initialising the now variable to hold a new Date() object. 


// We want to create our own constructor function. Let's create a constructor function for a `Rectangle` object.

// Whenever you make a constructor function you want the first letter uppercase e.g. Rectangle()
function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
  // We can also hardcode properties
  this.type = 'Rectangle';
}

// We use the `function` keyword to create a function. We give it a name, which is `Rectangle`.
// We use the `this` keyword to set the properties of the object.


// What is returned from the constructor function is the new object that is created. We could actually do this:

function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;

  return this;
}

// But there is no need to because the `this` keyword is implicitly returned by default.

// We can now create a new `Rectangle` object like this:


// instantiate our object from (name, width, height) to ('Rectangle 1', 10, 10) which give us an object with these values.

// if we do not use new we will get undefined
const rect1 = new Rectangle('Rectangle 1', 10, 10);
console.log(rect1); // object 
// Rectangle {name: "Rectangle 1", width: 10, height: 10}



// So as you can see, when we log the rectangle, it is an object and it is prefixed with `Rectangle`. This is because we used the `Rectangle` constructor function to create the object.

// You'll also notice the `prototype` object. Inside of that is the constructor function. We can actually add methods to the `prototype` and we're going to get into that soon.



// - Multiple Instances - 

// The main advantage of using a constructor function is that we can create multiple instances of the same object. Let's create another `Rectangle` object.

const rect2 = new Rectangle('Rectangle 2', 20, 20);
console.log(rect2); // Rectangle {name: "Rectangle 2", width: 20, height: 20}


// We can now access the properties of the object like this:

console.log(rect1.name, rect2.name); // Rectangle 1, Rectangle 
//if you just want ot grab only just one e.g. just the name 

console.log(rect1.area(), rect2.area());

// When we use the `new` keyword, the following things happen:

// 1. A new empty object is created.
// 2. The constructor function is called with the arguments that we passed in.
// 3. The `this` keyword is set to the new empty object.
// 4. The new object is returned from the constructor function.



// So you see, we did not need to create an entirely new constructor function to create a new `Rectangle` object. We just used the same constructor function and passed in different arguments. This is much more efficient than creating a new object literal every time we want to create a new object.



// - Methods - 

// We can also add methods to our constructor function. Let's add an `area` method to our `Rectangle` constructor function. Those of you that are a little more advanced may say we should add this to the `prototype` object. We will get into that later.

function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;

  this.area = function () {
    return this.width * this.height;
  
  };
}

console.log(rect1.area()); //need to paranthesis area() 



// - constructor Property - 

// Every object has a `constructor` property. This property is a reference to the constructor function that was used to create the object. Let's log the `constructor` property of the `rect1` object.


// We can access the constructor function with the `constructor` property

console.log(rect1.constructor); // ƒ Rectangle(name, width, height) { this.name = name; this.width = width; this.height = height; this.area = function () { return this.width * this.height; }; }


// - `instanceof` Operator -
// Check to see if an object is an instance of a constructor. Let's check if the `rect1` object was created by the `Rectangle` constructor function.

console.log(rect1 instanceof Rectangle); // true

// We can use the `instanceof` operator to check if an object was created by a constructor function. 


// Encapsulation & Abstraction In Practice

// This brings use to the first of the four principles of object-oriented programming, which is `encapsulation`. Encapsulation is the idea that we should group related variables and functions together. We should also hide the implementation details from the outside world. This is what we have done with the `Rectangle` constructor function. We have encapsulated the properties and methods that belong to the `Rectangle` object.

// One of the benefits of encapsulation is that we can change the implementation details without affecting the outside world. For instance, we could change the name of the `area` method to `calculateArea` without affecting the outside world.


function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
  this.calculateArea = function () {
    return this.width * this.height;
  };
}


// Another advantage is when we call `rect1.calculateArea()` we don't have to pass in any arguments. This is because the `this` keyword is set to the `rect1` object. We can access the properties of the `rect1` object inside of the `calculateArea` method.

// - Abstraction -

// Abstraction is the idea that we should only expose the necessary details to the outside world. We should hide the implementation details. We have already seen this with the `Rectangle` constructor function. We have hidden the implementation details of the `Rectangle` object. We have only exposed the properties and methods that we want the outside world to use.

// In the next lesson, we will look more at `literals` and `constructors` as well as `boxing` and `unboxing`.







// ***Literals vs Built-in Constructors***
// Boxing vs Unboxing


// JavaScript has the primitive data types:
// null.
// undefined.
// boolean.
// number.
// string.
// symbol – available from ES2015.
// bigint – available from ES2020.

const strLit = 'Hello';

// constructor function 
const strObj = new String('Hello'); 


console.log(strLit, typeof strLit) //Hello string

console.log(strObj, typeof strObj)
// String {'Hello'}
// 0: "H
// 1: "e"
// 2: "l"
// 3: "l"
// 4: "o"
// length: 5
// [[Prototype]]: String //object
// [[PrimitiveValue]]: "Hello" 


// boxing
console.log(strLit.toUpperCase()) //we can not use a method on a primitive data type behind the scenes Javascript adds a wrapper object to the literal and turns it into new String('Hello') and it is called boxing same if you use an index of a literal.

console.log(strLit[0]) //H


// Unboxing 
// This is when an object is turned back into a literal. There is a valueOf method we can use. We started with an object here and went back to a literal called unboxing.

console.log(strObj.valueOf(), typeof strObj.valueOf()) 
// The reason we can use this method valueOf() you can see it is not on the string object there is no valueOf here but if you go into Prototype think of it as an extra space that can hold other properties and methods and can be inherited and so on.     
// String {'Hello'}
// 0: "H
// 1: "e"
// 2: "l"
// 3: "l"
// 4: "o"
// length: 5
// [[Prototype]]: String //object
// [[PrimitiveValue]]: "Hello" 

// If you look in the console [[Prototype]]: String it will show all the methods you can use for string e.g. length, match, slice, search and these can all be used in on string.

// If you scroll further down it also inherits a [[Prototype]]:Object and if you look in there that is where the valueOf method is so when you use a property or method on an object it first looks directly at the the object property strObj then it looks at its Prototype and it will keep looking at the inherited prototype which this object base [[Prototype]]:Object is one if its inherited prototypes.  

// Also because of boxing there is still a constructor property on a literal.

console.log(strLit.constructor) 
//ƒ String() { [native code] } we get the constructor of the string object boxing is going on behind the scenes. 

console.log(strObj.constructor) //you get the same ƒ String() { [native code] }

// We can also use the instancesOf operator to check if an object is an instancesOf a constructor function the literal will return false because it is a literal. We are checking to see if it is a instanceof string constructor.  

console.log(strLit instanceof String) // false
console.log(strObj instanceof String) // true

// It is true because it is an instanceof string const strObj = new String('Hello'); because we created an instanceof string object strObj by using new a constructor by using the new keyword.


// We have constructors for others like number, boolean, array, functions and objects  

// other types 

const numLit = 20; 
const numObj = new Number(20);

console.log(numLit, typeof numLit); //20 'number'
console.log(numObj, typeof numObj); //Number {20} 'object' created from the constructor const numObj = new Number(20)

// If on the number literal const numLit = 20 if we were to use toFixed() or some kind of method on the literal then javascript will do the boxing and add the wrapper object   

const boolLit = true; //true 'boolean'
const boolObj = new Boolean(true); //Boolean {true} 'object' as the type

console.log(boolLit, typeof boolLit);
console.log(boolObj, typeof boolObj);


//arrays are not a primitive value they are objects weather we use the literal syntax or the constructor syntax they are both the same thing. They are both same value and they are both objects.  
const arrLit = [1, 2, 3, 4, 5];
const arrObj = new Array(1, 2, 3, 4, 5);

console.log(arrLit, typeof arrLit); //[1, 2, 3, 4, 5] 'object'
console.log(arrObj, typeof arrObj); //[1, 2, 3, 4, 5] 'object'



// function and the object constructors 

// function constructors

const funcLit = function(x){

  return x * x
};

console.log(funcLit, typeof funcLit) 
// We get the function it is not going to execute or evoke the function it is just logging the actual function and for typeof we get function which is still an object it is confusing as it is still an object it is just a certain typeof object     


// ƒ (x){
// return x * x
// } 'function'

console.log(funcLit(5)) //25 because it returns something e.g. return x * x

// You can also create a function using the function contructor. With a function constructor I can pass in two arguments.

// Function('firstly actual argument that gets passed into the function it get's passed in as a string', 'secondly the function body e.g. return x * x')

const funcObj = new Function('x', 'return x * x');

// We can execute the function created with the Function constructor
console.log(funcObj(3)) //9

// object constructors

const obj1 = {} //empty object
// so behind the scenes the object literal syntax behind the scenes javascript is adding the new keyword and using the Object() constructor 

const obj2 = new Object() // object constructor

// literal syntax same results as new object constructor 
console.log(obj1, typeof obj1) //{} 'object'
console.log(obj2, typeof obj2) //{} 'object'



// ***Working With Object Properties***

// Want to go over dealing with object properties. So we want to instantiate a new rectangle object we have a constructor function here with name, width, height and the area function. It is the same syntax we use for an object literal but with some new.      



function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
  this.area = function () {
    return this.width * this.height;
  };
}

const rect1 = new Rectangle('Rectangle 1', 20, 20);
const rect2 = new Rectangle('Rectangle 2', 20, 30);

// call the property
console.log(rect1.name, rect2.width); //Rectangle 1 20
console.log(rect1['width']); //20

// add a new property
rect1.color = 'red';

console.log(rect1) 

// Rectangle {name: 'Rectangle 1', width: 20, height: 20, color: 'red', area: ƒ}
// area:ƒ()
// color:"red"
// height:20
// name:"Rectangle 1"
// width:20
// [[Prototype]]:Object

// can also add functions 

// can not use this because we are not within the constructor so just take the instance of rect2 get the .width 
rect2.perimeter = () => 2 * (rect2.width + rect1.height)

console.log(rect2.perimeter())


// remove delete a property 

console.log(rect2)
// Rectangle {name: 'Rectangle 2', width: 20, height: 30, area: ƒ, perimeter: ƒ}
// area:ƒ()
// height:30
// name:"Rectangle 2"
// perimeter:() => 2 * (rect2.width + rect1.height)
// width:20
// [[Prototype]]: Object

delete rect2.perimeter // now no perimeter function
console.log(rect2)


// check for specific property
// hasOwnProperty

console.log(rect2.hasOwnProperty('color')) //false
console.log(rect1.hasOwnProperty('color')) //true


// some of the functions we have on objects e.g. keys, values, entries  

// get the keys of object (incl. methods and properties e.g. name, width, height) can put those in an array.

// get keys of object 

console.log(Object.keys(rect1)) 
// (5) ['name', 'width', 'height', 'area', 'color']
// 0:"name"
// 1:"width"
// 2:"height"
// 3:"area"
// 4:"color"
// length:5
// [[Prototype]]:Array(0)


// get values of object 
console.log(Object.values(rect2))
// (4) ['Rectangle 2', 20, 30, ƒ]
// 0:"Rectangle 2"
// 1:20
// 2:30
// 3:ƒ()
// length:4
// [[Prototype]]:Array(0)


// get entries of object 
// it gives us an array of an array and each array has two elements a key and value 
console.log(Object.entries(rect1))
// (5) [Array(2), Array(2), Array(2), Array(2), Array(2)]
// 0:(2) ['name', 'Rectangle 1']
// 1:(2) ['width', 20]
// 2:(2) ['height', 20]
// 3:(2) ['area', ƒ]
// 4:(2) ['color', 'red']
// length:5
// [[Prototype]]:Array(0)

// loop through some of these entries

for(let [key, value] of Object.entries(rect1)){
console.log(`${key}:${value}`)


// name:Rectangle 1
// width:20
// 104 height:20
// 104 area:function () {
// return this.width * this.height;
// }
// color:red


// if you just wanted to get the properties and not the function or method we can use an if statement and check for the type e.g. if typeof value not equal to function, function is a function object and if it is not equal then we are only going to log properties name, width, height, color.

if(typeof value !== 'function'){
console.log(`${key}:${value}`)

// name:Rectangle 1
// width:20
// height:20
// color:red

}
}


// ***Prototypes & The Prototype Chain***

// - What Are Prototypes? - 

// Prototypes are a special type of enumerable object where additional methods and properties can be attached and shared across all of the instances of it's constructor function.

// In JavaScript, every function and object has a prototype. The prototype itself is an object. When we try to access a property on an object, JavaScript will first look for that property on the object. If it doesn't find it, it will look at the object's `prototype`. If it still doesn't find it, it will look at the prototype's prototype. This continues until it finds the property or it reaches the end of what we call the `prototype chain`, which is null. 

// So the dumbed down version is that prototypes are an extra space to hold properties and methods that we can use on our objects. We can add properties and methods to the prototype and they will be available to all objects that inherit from that prototype. This is called `prototypical inheritance`.

// We've used many prototype methods in the previous lessons. For instance, when we have an array and we call the `map()` method, JavaScript will look for the `map()` method on the array. If it doesn't find it, it will look at the array's prototype. It will find the `map()` method and execute it.

// - Viewing Prototypes - 
  
// Open your browser console and create an object. It can be empty. Then type the variable name and hit `enter`

// You will see that it has a `Prototype` property. This is the prototype of the object. If you create an array or a function, it will also have a `Prototype` property. Everything in JS is an object and every object has a prototype (which is also an objct).

// Notice in the object's prototype, there is a `constructor`. The `constructor` property is a reference to the function that was used to create the object.

// There are some other familiar properties in the prototype, like `toString()`, `valueOf()` and `hasOwnProperty()`. These are all methods that are inherited from the `Object.prototype` also called `objectBase`.

// - Prototype Chain & Prototypical Inheritance - 

// Let's create an array in the console. You'll see the `Array.prototype` or the `arrayBase` with some very familiar methods like `push()`, `pop()` as well as high order array methods that we have used such as map(), filter() and forEach().

// If we scroll down, you will see another `prototype` object.
// [[Prototype]]:Object 

// This is because the `Array.prototype` inherits from the `Object.prototype`. This is inheritance in what we call the prototype chain. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.

// Let's use our `Rectangle` object from the previous lesson and create an object and look at the prototype in the console.

function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;

  // cut area function and put it into the prototype: 
  // this.area = function () {
  // return this.width * this.height;
  // };
}

// ***notes below
// add to prototype
Rectangle.prototype.area = function () {
  return this.width * this.height;
  };

// calling the prototype below* 
// console.log(rect.area())


const rect = new Rectangle('Rect', 10, 10);

// all it has right now is our constructor function
console.log(rect)

// Rectangle {name: 'Rect', width: 10, height: 10, area: ƒ}
// area:ƒ ()
// height:10
// name:"Rect"
// width:10
// [[Prototype]]:Object
// constructor: ƒ Rectangle(name, width, height)
// [[Prototype]]:Object

// we can store methods in the prototype. It would be a perfect oportunity to put the area function in there:

// this.area = function () {
// return this.width * this.height;
// };

// ***syntax above (notes)
// It is clear that when we create a new rectangle we need to pass in a name, width, height but the area will always going to stay the same. It is alway going to be whatever the height * width. So instead of it going on the function we can make it more efficient and put it in the prototype and that any rectangle we create will have access to it. 

// *calling the prototype 
console.log(rect.area()) //100
// const rect = new Rectangle('Rect', 10, 10)  
// Rectangle.prototype.area = function () {return this.width * this.height;}; 
// 10 * 10 = 100 to give you the area.

// If you look in the Rectangle object itself there is no area function. It is now located in the prototype. 



// - more examples of prototype - 

function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
}

Rectangle.prototype.area = function () {
return this.width * this.height;
};

Rectangle.prototype.perimeter = function () {
return 2 * (this.width + this.height);
};

Rectangle.prototype.isSquare = function () {
return this.width === this.height;
};


// We can also pass in arguments to the `prototype` methods. Let's add a method to change the name. It will take in a `newName` argument.

Rectangle.prototype.changeName = function (newName) {
return this.name = newName;
};
  

const rect = new Rectangle('Rect', 10, 10);
const rect2 = new Rectangle('Rect2', 30, 40);

console.log(rect)
// Rectangle {name: 'Rect', width: 10, height: 10}
// height:10
// name:"Rect"
// width:10
// [[Prototype]]:Object
// area:ƒ ()
// changeName:ƒ (newName)
// isSquare:ƒ ()
// perimeter:ƒ ()
// constructor:ƒ Rectangle(name, width, height)
// [[Prototype]]:Object

 
console.log(rect.area()) //100
console.log(rect.perimeter()) //40
console.log(rect.isSquare()) //true

rect.changeName('Test')
console.log(rect.name) //Test


// since we used the Rectangle constructor can log directly as any object that you instatiate from the constructor function I have access to all of the prototype methods. 

console.log(rect2.area()) //1200



// - Object.getPrototypeOf() -

// `Object.getPrototypeOf()` is a method that returns the prototype of an object. Let's use it to get the prototype of the `rect1` object.

function Rectangle(name, width, height) {
  this.name = name;
  this.width = width;
  this.height = height;
  this.area = function () {
    return this.width * this.height;
  };
}

const rect1 = new Rectangle('Rectangle 1', 10, 10);
console.log(rect1);

// Object.getPrototypeOf()
console.log(Object.getPrototypeOf(rect1));
// {constructor: ƒ}
// constructor:ƒ Rectangle(name, width, height)
// [[Prototype]]:Object





// ***Using Object.create()***

// Creating a constructor function from previous lecture.

function Rectangle(height, width) {
  this.height = height;
  this.width = width;
}

Rectangle.prototype.area = function () {
  return this.height * this.width;
};

Rectangle.prototype.perimeter = function () {
  return 2 * (this.height + this.width);
};

Rectangle.prototype.isSquare = function () {
  return this.height === this.width;
};

const rectangle1 = new Rectangle(4, 4);
console.log(rectangle1.isSquare(), rectangle1.area());




// - Object.create() -

// An alternative way to create constructor function using the Object.create() method 

// creating just an object literal with our protoype functions   
const rectanglePrototypes = { 
  // set to an object literal = {} 
  
  area: function(){
  return this.width * this.height 
  },
  perimeter: function(){
  return 2 * (this.width + this.height) 
  },
  isSquare: function(){
  return this.height === this.width
  }
  } 
  
  
  // using the Object.create() method going to put this into a function called create rectangle so that whenever we want to create a new rectangle object we can just use the function and this is going to take in a height and a width. So this will be an alternative way to create rectangles.
  
  function createRectangle(height, width){
  
    // object constructor's prototype method of create and that is going to take in an object firstly with our prototypes what we created above e.g. rectanglePrototypes and secondly we then pass in an object {} with any properties that we want.  
  
    return Object.create(rectanglePrototypes, {

      // we have the name of the property and then we set the value to whatever we want, in this case we are setting to the height that is passed into the createRectangle(height, width).

      height:{
        value: height
      },
      width:{
        value: width
      },
    });
  }
  
     // So now whenever we want to create a rectangle object we can call createRectangle and pass in a value width and height

     const rect = createRectangle(10, 20)
     console.log(rect)

    //  If we look at the output in prototype you will notice there is no constructor because we did not use a constructor function but we do have our area, perimeter and isSquare. Then this inherits the object base or the standard object constructor [[Prototype]]:Object 

    //  {height: 10, width: 20}
    //  height:10
    //  width:20
    //  [[Prototype]]:Object
    //  area:ƒ ()
    //  isSquare:ƒ ()
    //  perimeter:ƒ ()
    //  [[Prototype]]:Object

    // Now if I want to call one of those methods I can simply do the name of the object or name of the instance rect and then the function e.g. .area() 

    console.log(rect.area()) //200

    // So I don't even have to rect.prototype.area() because we used a custome prototype object.

    console.log(rect.isSquare()) //false

    // Can make as many rectangles as you want e.g.

    const rect2 = createRectangle(20, 20);
    console.log(rect2.area()) //400

    // It is an alternative way of creating multiple objects using Object.create() which takes in an object of methods or an object of prototypes and then an object of your properties and you will be able to then use that to create new objects.  





    // ***Prototypical Inheritance & call()***


    // - Teacher Notes Start for Prototypical Inheritance & call()- 

    // - Prototypical Inheritance & the `call()` Method

    // I've already talked about prototypical inheritance. We saw that the `Rectangle` constructor function as well as any array as well as many other things inherits from the `Object.prototype` or `objectBase`. This is why we can use the `toString()` method on our `Rectangle` object or on an array.

    // What I want to do now is show you how we can use inheritance with our own objects. I want to create a `Shape` constructor function that will be the base for other shapes. So we can create a `Circle`, `Square`, etc and have them all inherit from the `Shape` constructor function as well as any prototype methods we add to the `Shape` constructor function.

    // Let's create a very simple constructor function for a `Shape`:

    function Shape(name) {
    this.name = name;
    }


    // The only property I am going to add to the `Shape` constructor function is the `name` property.

    // call()

    // The call() method allows us to call a function with a given `this` value and arguments provided individually. The `call()` method is a predefined JavaScript method. It can be used for a variety of purposes. We will use it to call the `Shape` constructor function from the `Rectangle` constructor function.


    function Rectangle(name, height, width) {
    Shape.call(this, name);

    this.height = height;
    this.width = width;
    }


    const rect1 = new Rectangle('Rectangle 1', 10, 10);
    console.log(rect1); // Rectangle { name: 'Rectangle 1', height: 10, width: 10 }

    // As you can see, we are calling the `Shape` constructor function from the `Rectangle` constructor function using `call()`. We are passing in the `this` value and the `name` property. This will set the `name` property on the `Rectangle` object. Then we can add the `height` and `width` properties to the `Rectangle` object.

    // Why use `call()`?

    // If we did not use the `call()` method, we would get an error that says **Uncaught TypeError: Shape is not a constructor**. This is because the `Shape` constructor function would be called as a regular function and in a regular function, the `this` value is the `window` object. We need to use the `call()` method to set the `this` value to the `Rectangle` object.

    // Let's do the same with a `Circle` constructor function:


    function Circle(name, radius) {
    Shape.call(this, name);

    this.radius = radius;
    }



    const circle1 = new Circle('Circle 1', 10);
    console.log(circle1); // Circle { name: 'Circle 1', radius: 10 }


    // Inheriting Prototype Methods

    // Let's add a `logName()` method to the `Shape` constructor function and try to use it on the `Rectangle` object

    Shape.prototype.logName = function () {
    console.log(`Shape name is: ${this.name}`);
    };

    rect1.logName();

    // This will throw an error: **Uncaught TypeError: rect1.logName is not a function**. The prototype methods are not inherited automatically from the `Shape` constructor function.

    // We can fix this by using the `Object.create()` method. We're going to set the `Rectangle.prototype` to the `Shape.prototype` using the `Object.create()` method.


Rectangle.prototype = Object.create(Shape.prototype);


// We have to use the `Object.create()` method because if you just set the `Rectangle.prototype` to the `Shape.prototype`, the `constructor` property and the prototype chain will be broken.

// Now, let's try to call the `logName()` method on the `Rectangle` object:


rect1.logName(); // Shape name is: Rectangle 1


// It works! We can also call the `logName()` method on the `Circle` object:


circle1.logName(); // Shape name is: Circle 1


// So again, JavaScript will look for `logName()` directly on the `Rectangle` or `Circle` object. It will not find it, so it will look at the object's prototype which is the `Shape.prototype`. It will find the `logName()` method and will use it.

// Set constructor property

// Right now, if we log the constructor of the `Rectangle` object, we will get the `Shape` constructor function:


console.log(rect1.constructor); // [Function: Shape]

// This may cause some unexpected results in the future, so you probably want to set the `constructor` property on the `Rectangle.prototype` to the `Rectangle` constructor function.


Rectangle.prototype.constructor = Rectangle;

console.log(rect1.constructor); // [Function: Rectangle]

// We can do the same for the `Circle` constructor function:


Circle.prototype.constructor = Circle;


// Polymorphism - Overwriting Prototype Methods

// You should also be able to overwrite prototype methods. Let's add a `logName()` method to the `Rectangle` constructor function:


Rectangle.prototype.logName = function () {
  console.log(`Rectangle name is: ${this.name}`);
};

rect1.logName(); // Rectangle name is: Rectangle 1


// This is an example of polymorphism. We are able to have the same method name on different objects and have different results. We could have 100 different objects and all of them could have a `logName()` method and they would all do something different.

// - Teacher Notes End for Prototypical Inheritance & call()- 



// - *Prototypical Inheritance & call() Code Practice* -


// 1.
function Shape(name) {
  this.name = name;
}

 // What I want to do is have other shapes that will inherit the shape constructor above. If we put prototype on Shape, then the circles, rectangles, or whatever shapes we create should be able to access those prototype methods. The syntax for this is a little tricky, Classes makes this alot easier with just using 'extends' and using subclasses which will do later. If you are creating a large project and you are using object-orientated programming and you want to have inheritance you will go with CLasses. There is a lot more steps to do inheritance with prototype that there is with Classes.


//  10.
// one of the reasons that you use inheritance is to inherit prototypes, Prototypical Inheritance, so I want to be able to have a prototype method on Shape. I want to be able to use it whether it is a rectangle, circle etc. So let's make a method called logName set it to a function and we are going to log from the function.
// cont 10.   
Shape.prototype.logName = function () {
  console.log(`Shape Name: ${this.name}`);
};


//2. 
function Rectangle(name, height, width) {
  
  //4.
  Shape.call(this, name);

  // 3.
  this.height = height;
  this.width = width;

   // I want to inherit the Shape constructor so you can call the Shape function. We do not just want to call it like this Shape() because in 1. Shape we are saying this.name = name in a regular function this pertains to the window object which obviously we do not want. We want it to pertain to the object's instance that uses the constructor function and that is fine when we are saying 'new' e.g. something new Shape but we are not doing that here so we can use the 'call()' method. If we use call() it will still call the function but it allows us to pass in call(this) whatever the context of this, which in this case will be the object. We also want to pass in name call(this, name) because we are assigning name.  
}



// 12.
// Inherits Shape prototypes

  // There is an additional step we need to take if we want to inherit prototypes so we need to set the rectangle.prototype and set it to the Shape.prototype but we do not want to set it directly we want to use Object.create(Shape.prototype) and we can pass in the Shape.prototype remember it takes in an object of prototypes.
// cont. 12.
Rectangle.prototype = Object.create(Shape.prototype); //output nos 11. rect.logName(); 



// 18. 
// Polymorphism - Overwriting Prototype Methods
// overide prototype method from number 10. 
Rectangle.prototype.logName = function () {
  console.log(`Rectangle Name: ${this.name}`);
};


// 7. 
// We want to create other shapes 
// circle only common with shape is name
function Circle(name, radius) {
  Shape.call(this, name);

  this.radius = radius;
}


// 13.
// Inherits Shape prototypes
Circle.prototype = Object.create(Shape.prototype);

// 17.
// Set prototype constructors
Rectangle.prototype.constructor = Rectangle;
Circle.prototype.constructor = Circle;


// 5.
// Now able to create a rectangle object
const rect = new Rectangle('Rectangle 1', 20, 20);

// 6. 
// console.log(rect)

// 8.
// Now able to create a circle object
const cir = new Circle('Circle 1', 30);

// 9. & .15(comment on) & 22 (comment out)
// console.log(rect, cir); 

// 14. & 20
cir.logName();

// 11. & 21
rect.logName(); //will give false until you do step 12 then will give output of Shape Name: Rectangle 1.
// logic step A: 
  // use on the rectangle object 
  // const rect = new Rectangle('Rectangle 1', 20, 20) which uses the rectangle constructor.
  
  // logic step B: 
  // rectangle constructor inherits from the Shape function 
  // Shape(name){
  // this.name = name
  // } 
  
  // logic step C: 
  // rectangle constructor also inherits the prototypes 
  // Rectangle.prototype = Object.create(Shape.prototype)
  
  // logic step D: 
  // we can now use log name or any other prototype method that we add to the shape:
  // Shape.prototype.logName = function(){
  // console.log(`Shape Name: ${this.name}`)
  // }

  // 16. & (19 comment out)
  console.log(rect.constructor);




  // ***OOP Game Challenge***

  
function Player(name){

this.name = name;
this.level = 1;
this.points = 0;
}

Player.prototype.gainXp = function (xp) {
this.points += xp; 

if(this.points >= 10){
this.level ++
this.points -= 10; 
}

console.log(this.describe())
}

Player.prototype.describe = function (){
return `${this.name} is level ${this.level} with ${this.points} experience points`
}

const Player1 = new Player('Osman'); 
const Player2 = new Player('Sophia');  


Player1.gainXp(4)
Player2.gainXp(7)
Player1.gainXp(5)
Player2.gainXp(1)
Player1.gainXp(7)
Player2.gainXp(9)
Player1.gainXp(5)
Player2.gainXp(2)


// console.log(Player1.describe())
// console.log(Player2.describe())




// OOP - Classes, Getters, Setters & Private Properties

// ***Classes***

// We have talked about OOP quite a bit and as I've said before, JavaScript does not have classes at its core. However, The ES6 spec does have classes and they are very similar to classes in other languages. I would say that most OOP languages use classes, including Java, C#, C++, PHP and Objective-C. If you have worked with a language that uses classes, then this should be pretty familiar to you.

// What I mean when I say JavaScript does not have classes at it's core is that the code that is actually being run looks like what we have already learned. Constructor functions, prototypes, etc. However, ES6 gave us what is called a "syntactic sugar" for classes. This means that we can write code that looks like classes, but it is actually just constructor functions and prototypes under the hood.

// It has become pretty popular to use classes in JavaScript. Many people think that it is a much easier and less confusing syntax. Also, a lot of people are coming from class-based languages. So, it is nice to have a syntax that is similar to what they are used to. What you use is completely up to you. We saw the basics of constructors/prototypes, now let's get into classes.


// The old way as from above let's recreate this by using Class & Class methods:

// constructor function
function Rectangle(name, height, width) {
  this.name = name;
  this.height = height;
  this.width = width;
}

// prototype methods
Rectangle.prototype.area = function () {
  return this.height * this.width;
};

Rectangle.prototype.perimeter = function () {
  return 2 * (this.height + this.width);
};

Rectangle.prototype.isSquare = function () {
  return this.height === this.width;
};

Rectangle.prototype.logArea = function () {
  console.log('Rectangle Area: ' + this.area());
};

// instantiation
const square = new Rectangle('Square', 20, 30);
console.log(square)


// Creating a Class

// To create a class, we use the `class` keyword. We then give it a name. The name should be capitalized. This is just a convention. It is not required. We then use the `constructor` keyword to create a constructor function. This is the function that will be called when we create a new instance of the class. We can then add properties to `this` just like we would in a constructor function. We can also add methods to the prototype just like we would in a constructor function. Here is an example:


// class keyword
class Rectangle {
// constructor method function will always run everytime you instantiate a 'new' object 
constructor(name, width, height){
// console.log('run')

this.name = name; 
this.width = width; 
this.height = height; 
}

// add a method within the class

// function area() //do not write the function keyword when using a class method

area(){
// within the class method have access to 'this' 
return this.height * this.width
}

perimeter(){
  return 2 * (this.width + this.height)  
}

isSquare(){
return this.width === this.height
}



// in addition to using the 'this' keyword to access properties you can also use it to access other methods. There will be times where you will be using methods that are internal to the class that you do not need the user to know about e.g. abstraction  

logArea(){
console.log('Rectangle Area: ' + this.area())

}

}

const square = new Rectangle('Square', 20, 20);


// console.log(square);
console.log(square.area());

// check if area is on the prototype 
console.log(square);
// also write like this if area is on the prototype 
console.log(Object.getPrototypeOf(square))


console.log(square.perimeter());
console.log(square.isSquare());


square.logArea()




// ***Class Inheritance***
// easier than using constructors and prototypes alot of things are abstracted with classes

// We looked at the ES6 class syntax in the previous lesson. In this lesson, we will look at inheritance in classes.

// Inheritance is the ability to create a new class from an existing class. The new class will inherit all the properties and methods of the existing class. This is called a `subclass` or `child class`. The existing class is called a `superclass` or `parent class`.

// Let's create a parent class of `Shape`. This class will have a constructor that takes in a name. It will also have a `logName` method that will log the name to the console. Here is an example:


// parent class 
class Shape{
constructor(name){
this.name = name;
}

// log name on shape and be able to use it on any sub child class 

logName(){
console.log('shape Name: ' + this.name)
}
} 


// if we want to inherit a class we need to extend it..

// sub child class 
class Rectangle extends Shape {
// need a constructor here for the rectangle because it needs a name, height and width
constructor(name, width, height){

// we have a name that we are extending so we can call a method called super() it calls the constructor of the parent class 

super(name)

this.width = width;
this.height = height;
}
}

// sub child class 
class Circle extends Shape {

  constructor(name, radius){
 
  super(name)

  this.radius = radius
  }

  // can overwrite logNames methods we have in the parent class example of polymorphism. Instead of Shape Name we say Circle Name. 

  logName(){
    console.log('Circle Name: ' + this.name)
  }
  }
  
const rect = new Rectangle('Rect 1', 20, 20)
console.log(rect)
rect.logName()

const circle = new Circle('Circle 1', 30)
circle.logName()

// if we use instance of both rectangle and shape wil be true 

console.log(rect instanceof Rectangle) //true 
console.log(rect instanceof Shape) //true, this is because we extend shape it is also an instance of shape 




// ***Static Methods***

class Rectangle {
  constructor(name, height, width) {
    this.name = name;
    this.height = height;
    this.width = width;
  }

  area() {
    return this.height * this.width;
  }


  // we can call directly on the class Rectangle. You couldn't have a static area() because you need the instance of height and the width. If it is for static data if you just want to just return class Rectangle you can use it. 
  static getClass() {
    return 'Rectangle';
  }
}

const rect = new Rectangle('Rect', 10, 10);
console.log(rect.area());
console.log(Rectangle.getClass()); //use the class itself with capital Rectangle to use the static


// - Static Methods - 

// Static methods are methods that are available on the class itself. They are not available on the instances of the class. Static methods are often used to create utility functions or to hold data that is shared across all instances of the class. Let's create our `Shape` and `Rectangle` class from the previous example and add a static method called `getClassName`.

// A static method is created the same way as a regular method. The only difference is that we use the `static` keyword.


class Shape {
  constructor(name) {
    this.name = name;
  }

  logName() {
    console.log(this.name);
  }

  static getClassName() {
    return 'Shape';
  }
}



class Rectangle extends Shape {
  constructor(name, height, width) {
    super(name);
    this.height = height;
    this.width = width;
  }

  area() {
    return this.height * this.width;
  }

  static getClassName() {
    return 'Rectangle';
  }
}


// Let's try to create an instance of a `Rectangle` and call the `getClassName` method.


const rect = new Rectangle('Rectangle', 10, 20);

rect.getClassName(); // TypeError: rect.getClassName is not a function


// This does not work, because the `getClassName` method is not available on the instance of the `Rectangle` class. It is only available on the class itself.


console.log(Shape.getClassName());
console.log(Rectangle.getClassName());

// So if you have a method where you don't need to access the instance of the class, you can make it a static method. This way you can call it directly on the class.


// ***bind() & Defining this***

// So we've talked about the `this` keyword is dynamic. You know that when we create either a constructor function or a class, `this` refers to the current instance. However, if we use it in a regular function or the global scope, it refers to the `window` object. If we use it on an event handler or a constructor function or a class, it refers to the element that the event was triggered on. So the `this` keyword is very dynamic and it changes depending on how we use it. 

// That's why we have certain methods that allow us to set the `this` value manually. Those methods are `call()`, `apply()`, and `bind()`. We already looked at `call()` back in the prototypical inheritance lesson. We'll look at `apply()` later. Right now I'm going to show you how to use `bind()`. We'll need to know this for our project that's coming up as well.

// So `bind()` is used to set the `this` value manually. It returns a new function where the `this` value is bound to the value we pass in. One very common use case for `bind()` is when we want to use a callback function.

// Let's create a class called `App` and add a property of `serverName` and add an event listener in the constructor to listen for a button click and when that happens, we want to call a class method and use the `this` value from the `App` class.



class App {

constructor(){
  // property serverName 
  this.serverName = 'localhost'

  // common place to put you event listeners when using class is in the constructor becuase that runs automatically
  
  document
  .querySelector('button')
  .addEventListener('click', this.getServerName.bind(this)); 
  //we are passing it in we are not invoking it (). This is in a callback function which is a regular function and gives an output of undefined. 
  
  // To fix this issue we use bind() whatever you pass in here is going to be what 'this' is going to be in the method getServerName() and you want it to be the current instance bind(this). If you do not put bind() here you will get an output of <button>Click</button>. You only do this if you use 'this'. If you do not use 'this' you do not have to do it.
}


getServerName(){
console.log(this) //object App {serverName: 'localhost'}
console.log(this.serverName) //localhost
}
}

// instantiate App
const app = new App()


// app.getServerName()





// ***Getters & Setters with Classes***

// Getters and setters are methods that are used to get or set property values for objects. 

// We can use them with classes, constructors, and object literals. I'm going to show you all three, but I'm going to start with classes, because it's the most common way to use them and the easier syntax.

// There are a few reasons to use getters and setters instead of accessing the property directly. You may want to do something to the value before it is returned. They allow you to control how a property is accessed. This is useful when you want to perform an action before returning the value of a property. For example, you may want to ensure that a property is always capitalized before getting or setting it.

// They also allow you to keep the same syntax whether it's a regular property or a method.

// They are also used with private properties. For example, you may have properties that you don't want to be accessed directly. If you want to set a properties with additional functionality you can do that as well.  Instead you'll have getters and setters for them. I'll get more into that soon.

// I'm going to start off with a different example than our shapes classes. We're going to create a person class.

// 1.
class Person{
constructor(firstName, lastName){
  // _underscore typically used to signify it is a private property should not access it
  this._firstName = firstName
  this._lastName = lastName
}

// 4.
// getter firstName
get firstName(){
return this.capitaliseFirst(this._firstName)
}

// 5.
// setters firstName
// setters always take in a single value 
 // setters lastName
 set firstName(value){
  this._firstName = this.capitaliseFirst(value)
  }



// 8.
// getter lastName
get lastName(){
  return this.capitaliseFirst(this._lastName)
  }

// 9. 
setter lastName
set lastName(value){
this._lastName = this.capitaliseFirst(value)
}

// 12.
// getter fullName
  get fullName(){
    return `${this.firstName} ${this.lastName}`
  }


// 7.
capitaliseFirst(value){
return value.charAt(0).toUpperCase() + value.slice(1) 
}
}


// 2.
const person1 = new Person('osman', 'ijaz');
console.log(person1)

// 3.
console.log(person1.firstName)

// 10.
console.log(person1.lastName)

// 6. 
person1.firstName = 'bradley'

// 11.
person1.lastName = 'smith'

// 13.
console.log(person1.fullName)




// ***Getters & Setters With defineProperty()***

// In the last lesson, I showed you how to create getters and setters with the `get` and `set` keywords inside of a class. But there's another way that we can do this that is common with `constructor functions` and that is using the `Object.defineProperty()` method.

// It takes three arguments. 
// 1. The first is the object that we want to add the property to (this). 
// 2. The second is the name of the property that we want to add. 
// 3. Third is an object that contains the getter and setter functions. 

// Let's add a getter and setter for the `firstName` and `lastName` property



// getters and setters inside of a constructor function 

// 1.
// Constructor Function
function Person(firstName, lastName){

this._firstName = firstName;
this._lastName = lastName;


// to create a getter and a setter we have to use the defineProperty() on the object constructor 

// takes in 3 things:
// Object.defineProperty(1. the object itself, 2. the property that we want to add a getter or a setter for, 3. takes in an object with a getter and setter function)

// 2.
// getter and setter for firstName
Object.defineProperty(this, 'firstName', {
  get: function(){
    // 8.
    return this.capitaliseFirst(this._firstName)


    // return this._firstName; //returning the property inside of the getter 
  },
  set: function(value){
    // setter always takes in a single value 
    this._firstName = value
  }
});


// 3. 
// getter and setter for lastName
Object.defineProperty(this, 'lastName', {
get: function(){

  // 7. 
  return this.capitaliseFirst(this._lastName)


  // return this._lastName; //returning the property inside of the getter 
},
set: function(value){
  // setter always takes in a single value 
  this._lastName = value
}
});


// 9. 
// getter for fullName
Object.defineProperty(this, 'fullName', {
get: function(){

  // 10.
  // You don't have to use capitaliseFirst for the fullName because you can use the other getters from this getter by using firstName without the _underscore as by using the firstName you are accessing the getter of firstName which is already using capitaliseFirst in the previous getters. Also lastName has the capitaliseFirst.    
  
  return this.firstName + ' ' + this.lastName; 
}
});

}

// 6.
// capitalise first function to the person prototype

Person.prototype.capitaliseFirst = function(value){
return value.charAt(0).toUpperCase() + value.slice(1)
}


// 12. with an object literal 
// one single object it is not like a constructor function which is a blue print where we can create many objects.
const PersonObj = {
_firstName: 'jane',
_lastName: 'ijaz',


// 13. 
// get and set first name for object literal 
get firstName(){
return Person.prototype.capitaliseFirst(this._firstName)
},

// set first name for object literal 
set firstName(value){
this._firstName = value 

},


// 14. 
// get and set last name for object literals
get lastName(){
return Person.prototype.capitaliseFirst(this._lastName)
},

// set first name for object literal 
set lastName(value){
this._lastName = value 
},


// 16. 
// get and set full name with object literal

get fullName(){
return this.firstName + ' ' + this.lastName;
}, 
};


// 4.
// instantiate a new person object 
const person1 = new Person('john', 'doe');


// 5.
// no _underscore _firstName aswe want to access it from the getter
console.log(person1.firstName)
console.log(person1.lastName)

// 11.
console.log(person1.fullName)


// .15
const person2 = Object.create(PersonObj)
console.log(person2.firstName)
console.log(person2.lastName)

// 17.
console.log(person2.fullName)










// ***Private Property Underscore Convention***


// 1.
class Wallet {
constructor(){
this._balance = 0;

// 11.
this._transactions = []
}


// 2.
// methods to change balance 
deposit(amount){
this._balance += amount;

// 15.
this._processDeposit(amount)
} 


// 3.
withdraw(amount){
this._balance -= amount;


// 10.
if(amount > this._balance){
console.log('Not Enough Funds')
return
}


// 17. 
this._processWithdraw(amount)
}

// 14.
// process deposit 
_processDeposit(amount){
console.log(`Depositing ${amount}`)

this._transactions.push({
type: 'deposit',
amount 
})
}

// 16.
// process withdraw 
_processWithdraw(amount){
  console.log(`Withdrawing ${amount}`)
  
  this._transactions.push({
  type: 'withdraw',
  amount 
  })
  }


// 6.
// getBalance(){
// return this._balance
// }

// 8.
get balance(){
return this._balance
}

// 12.
// getter for transactions 

get transactions(){
return this._transactions
}
}

// 4.
const wallet = new Wallet()
wallet.deposit(300)
wallet.withdraw(50)

// 5.
// console.log(wallet._balance)

// 7.
// console.log(wallet.getBalance())

// 9.
console.log(wallet.balance)

// 13.
console.log(wallet.transactions)



// Private Property Underscore Convention
// - Convention For Private Properties -

// Now we are going to get a bit deeper into encapsulation, which often includes the process of hiding data or hiding specific properties and methods of a class.

// In many OOP languages that use classes, you can use specific keywords to indicate which properties and methods are accessible from outside the class. For example, in Java, you can use the `private` keyword to indicate that a property or method is only accessible from within the class. 

// In JavaScript, we don't have those keywords, but there is a convention that is commonly used to indicate that a property or method is private. We use an underscore `_` before the property or method name.

// There is also a new feature in ES2022 that allows us to use the `#` symbol to create private fields. 

// You'll probably run into the underscore convention more often than the `#` symbol. There are a few other ways to implement this as well including using `Symbols` and the `WeakMap` object. The underscore convention is definitely the most common at this point in time.

// Let's create a new class called `Wallet` and add a constructor that has a `balance` and a `transactions` property. The `balance` will be 0 and `transactions` will be an empty array.

class Wallet {
  constructor() {
    this.balance = 0;
    this.transactions = [];
  }
}


// Now let's add a `deposit` method that takes an amount and adds it to the `balance` and adds a new transaction to the `transactions` array. We'll also add a `withdraw` method that takes an amount and subtracts it from the `balance` and adds a new transaction to the `transactions` array.


class Wallet {
  constructor() {
    this.balance = 0;
    this.transactions = [];
  }

  deposit(amount) {
    this.balance += amount;
  }

  withdraw(amount) {
    this.balance -= amount;
  }
}

// Now let's create a new instance of the `Wallet` class and call the `deposit` method with an amount of 300. Then withdraw an amount of 50. Then we'll log the `balance` property to the console.


const wallet = new Wallet();
wallet.deposit(300);
wallet.withdraw(50);
console.log(wallet.balance); // 250

// It works as expected. However, we don't want to expose the `balance` property to the outside world. We want to make it private. We want to make it so that the only way to access the `balance` property is through the `deposit` and `withdraw` methods. This is part of encapsulation.

// Now, like I said, JavaScript does not have a `private` keyword, but we can use the underscore convention to indicate that a property or method is private. So let's add an underscore to the `balance` property.

class Wallet {
  constructor() {
    this._balance = 0;
    this.transactions = [];
  }

  deposit(amount) {
    this._balance += amount;
  }

  withdraw(amount) {
    if (amount > this._balance) {
      console.log(`No enough funds`);
      return;
    }
    this._balance -= amount;
  }
}


// This convention tells the developer that the `balance` property is private and should not be accessed directly. We do want to be able to get the balance. We just don't want to be able to set it directly. So let's add a `getBalance` method that returns the `balance` property.


class Wallet {
  constructor() {
    this._balance = 0;
    this.transactions = [];
  }

  deposit(amount) {
    this._balance += amount;
  }

  withdraw(amount) {
    if (amount > this._balance) {
      console.log(`No enough funds`);
      return;
    }
    this._balance -= amount;
  }

  getBalance() {
    return this._balance;
  }
}


// Now we can call the `getBalance` method to get the balance. We can't access the `balance` property directly.

const wallet = new Wallet();
wallet.deposit(300);
wallet.withdraw(50);
console.log(wallet.getBalance()); // 250


// - Using a Getter

// We could use a function, but I would prefer to use a getter to get the balance. Let's remove the function and add a getter.


class Wallet {
  constructor() {
    this._balance = 0;
    this.transactions = [];
  }

  deposit(amount) {
    this._balance += amount;
  }

  withdraw(amount) {
    if (amount > this._balance) {
      console.log(`No enough funds`);
      return;
    }
    this._balance -= amount;
  }

  get balance() {
    return this._balance;
  }
}


// Now, we can access the `balance` through the getter


const wallet = new Wallet();
wallet.deposit(300);
wallet.withdraw(50);
console.log(wallet.balance); // 250


// The `transactions` property should also be private, so let's add an underscore to that property and create another getter for that. Let's also create 2 new private methods called `_processDeposit` and `_processWithdrawal`. These methods will add a new transaction to the `transactions` array.


class Wallet {
  constructor() {
    this._balance = 0;
    this._transactions = [];
  }

  get balance() {
    return this._balance;
  }

  get transactions() {
    return this._transactions;
  }

  deposit(amount) {
    this._processDeposit(amount);
    this._balance += amount;
  }

  withdraw(amount) {
    this._processWithdraw(amount);
    if (amount > this._balance) {
      console.log(`No enough funds`);
      return;
    }
    this._balance -= amount;
  }

  _processDeposit(amount) {
    console.log(`Depositing ${amount}`);

    this._transactions.push({
      type: 'deposit',
      amount,
    });
  }

  _processWithdraw(amount) {
    console.log(`Withdrawing ${amount}`);

    this._transactions.push({
      type: 'withdraw',
      amount,
    });
  }
}


// We made the 2 new methods private because there is absolutely no reason for the outside world to call these methods. They are only used internally by the `deposit` and `withdraw` methods. When we create documentation for this interface, we would not include these methods. there is no reason to. Hopefully, encapsulation makes sense to you now.

// Now, we can call the `deposit` and `withdraw` methods and we can access the `balance` and `transactions` properties through the getters.


const wallet = new Wallet();
wallet.deposit(300);
wallet.withdraw(50);
console.log(wallet.balance); // 250
console.log(wallet.transactions); // [{type: 'deposit', amount: 300}, {type: 'withdraw', amount: 50}]



// ***ES2022 Private Class Fields***

// Private Fields In ES2022

// Up until recently, JavaScript did not have a way to create private entities in classes. We used the underscore convention for a long time. However, in ES2022, we now have a way to create private class fields by using the `#` symbol. This is a new feature that isn't yet supported in all browsers. Right now, in the beginning of 2023, you'll probably run into the underscore convention more often than the `#` symbol. But this seems to be the future of private fields in JavaScript.

// Let's use our `Wallet` example from the last video and go through and see what we need to change.

// First, there is now a concept of `fields` and `properties`. 
// A `field` is a variable that is declared inside of a class. 
// A `property` is a variable that is declared inside of an object. 

// So, in the last video, we had a `balance` property and a `transactions` property. Now, we're going to have a `#balance` field and a `#transactions` field defined directly in the class as opposed to in the constructor.

// We now have full encapsulation and real private fields and methods in JavaScript. This is a huge step forward for JavaScript.

// There are some things you can do with Symbol() and weakMap but now in ES2022 there is a feature called class field or private field and instead of an _underscore we can use a # number sign. We do not need to put it in the constructor but we can add it right in the class. 



// 1.
class Wallet {

// #1. ES2022
#balance = 0;
#transactions = [];

// constructor(){
// this._balance = 0;

// // 11.
// this._transactions = []
// }


// 2.
// methods to change balance 
deposit(amount){
// #5. ES2022
this.#balance += amount;

// 15.
// #6. ES2022
this.#processDeposit(amount)
} 

// 3.
withdraw(amount){
// #7. ES2022
this.#balance -= amount;


// 10.
// #8. ES2022
if(amount > this.#balance){
console.log('Not Enough Funds')
return
}


// 17.
// #9. ES2022
this.#processWithdraw(amount)
}

// 14.
// process deposit
// #10. ES2022 
#processDeposit(amount){
console.log(`Depositing ${amount}`)

// #11. ES2022
this.#transactions.push({
type: 'deposit',
amount 
})
}

// 16.
// process withdraw 
// #12. ES2022
#processWithdraw(amount){
 console.log(`Withdrawing ${amount}`)
 
 // #13. ES2022 
 this.#transactions.push({
 type: 'withdraw',
 amount 
 })
 }


// 6.
// getBalance(){
// return this._balance
// }

// 8.
// #3. ES2022
get balance(){
return this.#balance
}

// 12.
// getter for transactions 

// #4. ES2022
get transactions(){
return this.#transactions
}
}



// 4.
const wallet = new Wallet()
// wallet.deposit(300)
// wallet.withdraw(50)

// 5.
// console.log(wallet._balance)

// 7.
// console.log(wallet.getBalance())

// 9.
// console.log(wallet.balance)

// 13.
// console.log(wallet.transactions)

// #2. ES2022
//  console.log(wallet.#balance) //Uncaught SyntaxError: Private field '#balance' must be declared in an enclosing class 
// console.log(wallet.balance) //undefined

// #14. ES2022
wallet.deposit(500)
wallet.withdraw(100)
console.log(wallet.balance)

// #15. ES2022
//  wallet.#processWithdraw(200) //Uncaught SyntaxError: Private field '#processWithdraw' must be declared in an enclosing class


// - ES2022 Private Class Fields - 
// code without notes 



class Wallet {
  #balance = 0;
  #transactions = [];

  deposit(amount) {
    this.#processDeposit(amount);
    this.#balance += amount;
  }

  withdraw(amount) {
    if (amount > this.#balance) {
      console.log('Not enough funds');
      return;
    }

    this.#processWithdraw(amount);
    this.#balance -= amount;
  }

  #processDeposit(amount) {
    console.log(`Depositing ${amount}`);

    this.#transactions.push({
      type: 'deposit',
      amount,
    });
  }

  #processWithdraw(amount) {
    console.log(`Withdrawing ${amount}`);

    this.#transactions.push({
      type: 'withdraw',
      amount,
    });
  }

  get balance() {
    return this.#balance;
  }

  get transactions() {
    return this.#transactions;
  }
}

const wallet = new Wallet();
wallet.deposit(500);
wallet.withdraw(100);
console.log(wallet.balance);





// ***Property Flags & Descriptors***

// So properties in objects basically have these permissions that we can set. Property flags are internal attributes of a property. They are not accessible directly, but we can use `Object.getOwnPropertyDescriptor`. The following is a list of available property flags they are set to true by default:


// - `[[Configurable]]` - if `true`, the property can be deleted and these attributes can be modified, otherwise if configurable is false then we can't modify or delete that specific property e.g. if we have a person object and we set the name property and we set configurable  to false then we can't modify it.  

// - `[[Enumerable]]` - if `true`, the property will be returned in a `for...in` loop, otherwise not

// - `[[Writable]]` - if `true`, the value of the property can be changed, otherwise not

// - `[[Value]]` - the value of the property


// The way we can view the flags is something called the descriptor and we can get a descriptor with a certain method called:

// `getOwnPropertyDescriptor` Method

// When we create a new object, wether it is an object literal or an instance from a constructor or a class, the flags for all properties are set to `true` by default. The `getOwnPropertyDescriptor()` method returns an object with property flags. This object is called a property descriptor.


// Now before we even get to that I just want to show an example of an object where some of these are locked or set to false. Let's check the flags for the `Math.PI` object.




// Math.PI is 3.14 (can't be changed)

Math.PI = 4 // will still remain 3.14 because of the flags
console.log(Math.PI) //3.14

// to check the flags also have 

// getOwnPropertyDescriptors (plural with an s at the end to check multiple properties here just checking the one PI property)

let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');
console.log(descriptor)

// everything is false (don't want to be able to change the value)
// {value: 3.141592653589793, writable: false, enumerable: false, configurable: false}
// configurable:false
// enumerable:false
// value:3.14
// writable:false
// [[Prototype]]:Object


// create our own object  
const rectObj = {
name: 'Rectangle 1',
width: 10,
height: 10,
}

// descriptor = Object.getOwnPropertyDescriptor(rectObj, 'name');
// console.log(descriptor)

// everything is true (default is true)

// {value: 'Rectangle 1', writable: true, enumerable: true, configurable: true}
// configurable:true
// enumerable:true
// value:"Rectangle 1"
// writable:true
// [[Prototype]]:Object



// change to false, change the permission by using the define property method that we used to create getters and setters. 

// remember defineProperty() takes in three arguments: 

// defineProperty (1. object, 2. property want to change the flags, 3. object with those flags{})

Object.defineProperty(rectObj, 'name', {
  writable:false,
  configurable:false, //if you set configurable to false you can not even change these back if I do another Object.defineProperty() on name I won't be able to change these becuase I have configurable set to false. 
  enumerable:false,


})

// check the flags again 



descriptor = Object.getOwnPropertyDescriptor(rectObj, 'name');
console.log(descriptor)

// {value: 'Rectangle 1', writable: false, enumerable: false, configurable: false}
// configurable:false
// enumerable:false
// value:"Rectangle 1"
// writable:false
// [[Prototype]]:Object


// let's go ahead and try to change the name 

rectObj.name = 'new name';
console.log(rectObj) //still Rectangle 1

// try to delete 
delete rectObj.name // not deleted still Rectangle 1

// delete rectObj.width // deletes the width just left with height just not the name because of those flags


// for the enumerable:false try to loop here

for(let [key, value] of Object.entries(rectObj)){
console.log(`${key}:${value}`)

// width:10
// height:10

// does not show the name because of the  writable:false, configurable:false, enumerable:false. 

// If I set enumerable:true it will show the name

}

// if you wan to get the descriptors for all properties then you can use the get own property descriptors method (plural with a 's' at the end)

console.log(Object.getOwnPropertyDescriptors(rectObj)) //gives us the width height and name with all of the flags, height set to true, name set all to false because of what we did with defined property and width set to true by default





// ***Sealing & Freezing Objects***

// Sealing - Prevents properties from being added or removed. Can still be changed on the existing property.
// Freezing - Prevents properties from being added, removed or changed lock down all the properties in the object.



const rectObj = {
name: 'rectangle 1',
width: 10,
height: 10,
}

// lets get all of the flags value all of the descriptors


// now I want to seal it 
Object.seal(rectObj) //configurable is now set to false on all the properties


let descriptors = Object.getOwnPropertyDescriptors(rectObj);

// console.log(descriptors) // by default true
// configurable:true
// enumerable:true
// writable:true
// for all three: height, width, name


// lets try to add a new property 

rectObj.color = 'red' //not added not allowed configurable is false because of seal
delete rectObj.name // did not delete cannot add or remove but can change to existing height, width, name

rectObj.width = 20 //this was changed as was exisitng and was using seal

// console.log(rectObj)

// lets do freezing now 

const circleObj = {
name: 'Circle 1',
radius: 30
};

Object.freeze(circleObj);


descriptors = Object.getOwnPropertyDescriptors(circleObj);

// try to add (will not work because using freeze) 

circleObj.color = 'blue' //not added
delete circleObj.name // did not delete
circleObj.name = 'New Name' //still same Circle 1


console.log(descriptors)
// configurable:false 
// writable:false (becuase we are using freeze can not change)
 

// there is a method called Object.isSealed() and Object.isFrozen()

console.log('rectObj is sealed', Object.isSealed(rectObj)) //rectObj is sealed true

console.log('rectObj is frozen', Object.isFrozen(rectObj)) // rectObj is frozen false

//if we freeze an object it is also sealed
console.log('circleObj is sealed', Object.isSealed(circleObj)) //circleObj is sealed true

console.log('circleObj is frozen', Object.isFrozen(circleObj)) //circleObj is frozen true






// ***Tracalorie App (OOP Project)***

// 1. Base Tracker, Meal & Workout Class
class CalorieTracker{
constructor(){
// this._calorieLimit = 2000

// 80.
this._calorieLimit = Storage.getCalorieLimit()
// this._totalCalories = 0


// 82. Persist Total Calories To Local Storage
this._totalCalories = Storage.getTotalCalories(0)


// 92. Save Meals To Local Storage
// this._meals = []
this._meals = Storage.getMeals()

// 99.
// this._workouts = []
this._workouts = Storage.getWorkouts()
 

// 16. (Display Tracker Stats)
this._displayCaloriesLimit()


// 10. (Display Tracker Stats)
this._displayCaloriesTotal()

// 20. (Display Tracker Stats)
this._displayCaloriesConsumed()

// 23. (Display Tracker Stats)
this._displayCaloriesBurned()

// 26. (Display Tracker Stats)
this._displayCaloriesRemaining()

// 30. (Progress Bar & Calorie Alert)
this._displayCaloriesProgress()

// 107. Clear Storage Items
document.getElementById('limit').value = this._calorieLimit

}



// Public Methods/API //

// 2. Base Tracker, Meal & Workout Class
addMeal(meal) {
this._meals.push(meal)
this._totalCalories += meal.calories

// 85.
Storage.updateTotalCalories(this._totalCalories) 


// 91. Save Meals To Local Storage
Storage.saveMeal(meal)

// 12. (Display Tracker Stats)
this._render()


// 55. 
this._displayNewMeal(meal)
}

// 3. Base Tracker, Meal & Workout Class
addWorkout(workout) {
  this._workouts.push(workout)
  this._totalCalories -= workout.calories

// 86.
Storage.updateTotalCalories(this._totalCalories)


// 100.
Storage.saveWorkout(workout)

  // 13. Display Tracker Stats
  this._render()

// 57. 
this._displayNewWorkout(workout)

  }


  // 61. 
removeMeal(id){

// want to find the index of the meal want to remove using find index method, the array is _meals, the findIndex() takes in a calback function. If it doen not match it will be negative -1 otherwise it will be the actual index.  
const index = this._meals.findIndex((meal) => meal.id === id) 

if(index !== -1){
  const meal = this._meals[index]
  // take away the calories for that meal
  this._totalCalories -= meal.calories
  // want to take the meal out of the array completely, _meals is an array 
  this._meals.splice(index, 1)

// 87.
Storage.updateTotalCalories(this._totalCalories)

  // 105. set to local storage
  Storage.removeMeal(id)

  // then we want to render 
  this._render()
}
}


  // 62. 
  removeWorkout(id){

    // want to find the index of the workout want to remove using find index method, the array is _workouts, the findIndex() takes in a calback function. If it doen not match it will be negative -1 otherwise it will be the actual index.  
    const index = this._workouts.findIndex((workout) => workout.id === id) 
    
    if(index !== -1){
      const workout = this._workouts[index]
      // take away the calories for that meal
      this._totalCalories += workout.calories

// 88.
Storage.updateTotalCalories(this._totalCalories)


  // 106. set to local storage
  Storage.removeWorkout(id)


      // want to add the workout in the array, _workouts is an array 
      this._workouts.splice(index, 1)
      // then we want to render 
      this._render()
    }
    }

    // 71.
    reset(){
      this._totalCalories = 0
      this._meals = [];
      this._workouts = [];

      // 108. Clear Storage Items
      Storage.clearAll()

      this._render()
      }

      // 77. 
      setLimit(calorieLimit){
        this._calorieLimit = calorieLimit

        // 81. 
        Storage.setCalorieLimit(calorieLimit)
        this._displayCaloriesLimit()
        this._render()
      }


// 93. Save Meals To Local Storage
loadItems(){
this._meals.forEach(meal => this._displayNewMeal(meal))

// 101.
this._workouts.forEach(workout => this._displayNewWorkout(workout))
}


// Private Methods //

// 9. Display Tracker Stats
_displayCaloriesTotal(){
const totalCaloriesEl = document.getElementById('calories-total')
 totalCaloriesEl.innerHTML = this._totalCalories
}


// 15. display the limit (max 2000)
_displayCaloriesLimit(){
  const calorieLimitEl = document.getElementById('calories-limit')
  calorieLimitEl.innerHTML = this._calorieLimit
  }


// 17. (Display Tracker Stats) consumed and burned little calculation only have total calories what came or did we burn from the workout and what did we consume from meals. We can use the reduce() high order array method

_displayCaloriesConsumed(){
const caloriesConsumedEl = document.getElementById('calories-consumed')

// 18. (Display Tracker Stats) taking all of the calories in the meals array and adding them together using reduce() high order array method which takes in a callback function and takes two arguments the accumulator and the other whatever we want to call each meal
const consumed = this._meals.reduce((total, meal)=> total + meal.calories, 0) //total begins or is set at 0. It will loop through all the meals and add the first meal calories then loop again and add the second meal calories

// 19. output Display Tracker Stats
caloriesConsumedEl.innerHTML = consumed;
}



// 22. burned workout array calories (Display Tracker Stats)
_displayCaloriesBurned(){
  const caloriesBurnedEl = document.getElementById('calories-burned')
  const burned = this._workouts.reduce((total, workout) => total + workout.calories, 0) 

  caloriesBurnedEl.innerHTML = burned
}


// 25. Display Tracker Stats
_displayCaloriesRemaining(){

// 35. (Progress Bar & Calorie Alert)
const progressEl = document.getElementById('calorie-progress')  
const caloriesRemainingEl = document.getElementById('calories-remaining')
  
// calorie limit -total calories
const remaining = this._calorieLimit - this._totalCalories

caloriesRemainingEl.innerHTML = remaining 


// 32. change calories remaing element to red negative (Progress Bar & Calorie Alert)

if(remaining <= 0){

  caloriesRemainingEl.parentElement.parentElement.classList.remove('bg-light')
  caloriesRemainingEl.parentElement.parentElement.classList.add('bg-danger')

// 33. change color of progress bar (Progress Bar & Calorie Alert)
progressEl.classList.remove('bg-success')
progressEl.classList.add('bg-danger')


}else{
  caloriesRemainingEl.parentElement.parentElement.classList.remove('bg-danger')
  caloriesRemainingEl.parentElement.parentElement.classList.add('bg-light')

  // 34. change color of progress bar (Progress Bar & Calorie Alert)
progressEl.classList.remove('bg-danger')
progressEl.classList.add('bg-success')
}
}


// 28. (Progress Bar & Calorie Alert)
_displayCaloriesProgress(){

  const progressEl = document.getElementById('calorie-progress')
  const percentage = (this._totalCalories / this._calorieLimit) * 100
  const width = Math.min(percentage, 100)
  progressEl.style.width = `${width}%`
  }


// 56. Display New Meal & Workout
_displayNewMeal(meal){
  const mealsEl = document.getElementById('meal-items');

  const mealEl = document.createElement('div')
  mealEl.classList.add('card', 'my-2')
  mealEl.setAttribute('data-id', meal.id)
  mealEl.innerHTML = `
  <div class="card-body">
  <div class="d-flex align-items-center justify-content-between">
    <h4 class="mx-1">${meal.name}</h4>
    <div
      class="fs-1 bg-primary text-white text-center rounded-2 px-2 px-sm-5"
    >
    ${meal.calories}
    </div>
    <button class="delete btn btn-danger btn-sm mx-2">
      <i class="fa-solid fa-xmark"></i>
    </button>
  </div>
</div>
  `;

  mealsEl.appendChild(mealEl)

}


// 58. 
_displayNewWorkout(workout){
  const workoutsEl = document.getElementById('workout-items');

  const workoutEl = document.createElement('div')
  workoutEl.classList.add('card', 'my-2')
  workoutEl.setAttribute('data-id', workout.id)
  workoutEl.innerHTML = `
  <div class="card-body">
  <div class="d-flex align-items-center justify-content-between">
    <h4 class="mx-1">${workout.name}</h4>
    <div
      class="fs-1 bg-secondary text-white text-center rounded-2 px-2 px-sm-5"
    >
    ${workout.calories}
    </div>
    <button class="delete btn btn-danger btn-sm mx-2">
      <i class="fa-solid fa-xmark"></i>
    </button>
  </div>
</div>
  `;

  workoutsEl.appendChild(workoutEl)

}


// 11. Display Tracker Stats
// need to render it for output not a framework this is vanilla js and can call it where you need it.
_render(){
this._displayCaloriesTotal()

// 21. Display Tracker Stats
this._displayCaloriesConsumed()

// 24. Display Tracker Stats
this._displayCaloriesBurned()

// 27. Display Tracker Stats
this._displayCaloriesRemaining()

// 29. (Progress Bar & Calorie Alert)
this._displayCaloriesProgress()
}

  }


// 4. Base Tracker, Meal & Workout Class

class Meal {
constructor(name, calories){
this.id = Math.random().toString(16).slice(2) //hexadecimal 16 base number to create unique id. A hexadecinal start's with 0 so to get rid of the 0. can add on .slice(2)

this.name = name
this.calories = calories
}
}

// 5. Base Tracker, Meal & Workout Class
class Workout {
  constructor(name, calories){
  this.id = Math.random().toString(16).slice(2) 
  this.name = name
  this.calories = calories
  }
  }
  

// 36. App Class, New Meal & Workout
// ---delete start here---
// // 6. Base Tracker, Meal & Workout Class
// // instantiate or initialise tracker  
// const tracker = new CalorieTracker();


// // 7. Base Tracker, Meal & Workout Class
// // add a meal 
// // const breakfast = new Meal('name', 'calories')
// const breakfast = new Meal('Breakfast', 400)
// tracker.addMeal(breakfast)

// // 14. add another meal & 31. (Progress Bar & Calorie Alert)
// const lunch = new Meal('Lunch', 350)
// tracker.addMeal(lunch)

// // 8. Base Tracker, Meal & Workout Class
// // add a workout 
// const run = new Workout('Morning Run', 320)
// tracker.addWorkout(run)

// console.log(tracker._meals)
// console.log(tracker._workouts)
// console.log(tracker._totalCalories)
// ---delete end here---


// 78.Storage Class & Calorie Limit Persist

// all of these methods will be static we don't need multiple instances of storage it is local storage only one entity don't need to instantiate a storage class just want to call storage dot whatever method 
class Storage{

  static getCalorieLimit(defaultLimit = 2000){
    let calorieLimit;

    // check in local storage already
    if(localStorage.getItem('calorieLimit') === null){
      calorieLimit = defaultLimit
    }else{
      calorieLimit = +localStorage.getItem('calorieLimit')
    }
    return calorieLimit
  }

// 79.
static setCalorieLimit(calorieLimit){
localStorage.setItem('calorieLimit', calorieLimit)
}

// 83. 
static getTotalCalories(defaultCalories = 0){
  let totalCalories;

  // check in local storage already
  if(localStorage.getItem('totalCalories') === null){
    totalCalories = defaultCalories
  }else{
    totalCalories = +localStorage.getItem('totalCalories')
  }
  return totalCalories
}

// 84.
static updateTotalCalories(calories){
  localStorage.setItem('totalCalories', calories)
}

// 89. Save Meals To Local Storage
static getMeals(){
  let meals;

  // check in local storage already
  if(localStorage.getItem('meals') === null){
    meals = []
  }else{
    meals = JSON.parse(localStorage.getItem('meals'))
  }
  return meals
}

// 90. Save Meals To Local Storage
static saveMeal(meal){
const meals = Storage.getMeals();
meals.push(meal)
localStorage.setItem('meals', JSON.stringify(meals))
}

// 102. Remove Meals & Workouts From LocalStorage
static removeMeal(id){
const meals = Storage.getMeals()
meals.forEach((meal, index)=>{
  if(meal.id === id){
    meals.splice(index, 1) //takeaway 1
  }
})

// 103.
localStorage.setItem('meals', JSON.stringify(meals));
}

// 97.
// workouts 
static getWorkouts(){
  let workouts;

  // check in local storage already
  if(localStorage.getItem('workouts') === null){
    workouts = []
  }else{
    workouts = JSON.parse(localStorage.getItem('workouts'))
  }
  return workouts
}

// 98.
static saveWorkout(workout){
const workouts = Storage.getWorkouts();
workouts.push(workout)
localStorage.setItem('workouts', JSON.stringify(workouts))
}

// 103. Remove Meals & Workouts From LocalStorage
static removeWorkout(id){
  const workouts = Storage.getWorkouts() //get from local storage
  workouts.forEach((workout, index)=>{ //loop through
    if(workout.id === id){
      workouts.splice(index, 1) //check id that is passed in take it out by splice, splice it at that index and take out 1
    }
  })
  
  // 104. set to local storage
  localStorage.setItem('workouts', JSON.stringify(workouts));
  }
  

   // 109. Clear Storage Items
static clearAll(){
  // clears all
  // localStorage.clear()

  // individually
  localStorage.removeItem('totalCalories')
  localStorage.removeItem('meals')
  localStorage.removeItem('workouts')
}
}

// 37. App Class New Meal & Workout
class App{
constructor(){
this._tracker = new CalorieTracker()

// 95. add a function to put all event listeners in their own method
this._loadEventListeners()

// 94. Save Meals To Local Storage
this._tracker.loadItems()
}


// 96. add a function to put all event listeners in their own method
// ---start---
_loadEventListeners(){
// 48.
document.getElementById('meal-form').addEventListener('submit', this._newItem.bind(this, 'meal'));

// 38.
// document.getElementById('meal-form').addEventListener('submit', this._newMeal.bind(this));
// when we call a method inside of a callback it is called as a regular function that the this keyword is going to be the window object. 

// In this situation if it is on an event listener this is going to be the element the event is on, e.g. <form id="meal-form">…</form> if it in a regular function then it is the window object. 

// We want this console.log(this) to pertain link to the new app we initialised const app = new App() so we can use bind() as when we have our callback in the event listener we can add .bind(this) and pass in this, then this will pertain to the our app in console: App {_tracker: CalorieTracker}
 
// 45. 
// document.getElementById('workout-form').addEventListener('submit', this._newWorkout.bind(this));

// 49.
document.getElementById('workout-form').addEventListener('submit', this._newItem.bind(this, 'workout'));

// 59. 
// multiple deletes so will use event delegation traget the items parent div then target the button

document.getElementById('meal-items').addEventListener('click', this._removeItem.bind(this, 'meal'))
// we want the this keyword to be the actual object rather than the element we click so use .bind(this), also passing in the type

// 63.
document.getElementById('workout-items').addEventListener('click', this._removeItem.bind(this, 'workout'));

// 64. Meals Filter and Reset
document.getElementById('filter-meals').addEventListener('keyup', this._filterItems.bind(this, 'meal'))

// 65. Workouts Filter and Reset
document.getElementById('filter-workouts').addEventListener('keyup', this._filterItems.bind(this, 'workout'))

// 69. reset
document.getElementById('reset').addEventListener('click', this._reset.bind(this))

// 72. Set Calorie Limit
document.getElementById('limit-form').addEventListener('submit', this._setLimit.bind(this))

}
// ---end 96.---


// 39. and 51.
_newItem(type, e){ //pass in event
  e.preventDefault() //since this is a submit event
  // console.log(this) 

  // 41.
  // we could set these variables to .value at the end as this is how we get an input value. I like to have the variables just to the element iteself and just add on .value as and when you need it.

  // 52. 
const name = document.getElementById(`${type}-name`)
const calories = document.getElementById(`${type}-calories`)

// const name = document.getElementById('meal-name')
// const calories = document.getElementById('meal-calories')

// 42. validate inputs
if(name.value === '' || calories.value === ''){
alert('Please fill in all fields')
return
}

// 53.
if(type === 'meal'){
  const meal = new Meal(name.value, +calories.value)
  this._tracker.addMeal(meal)
}else{
  const workout = new Workout(name.value, +calories.value)
  this._tracker.addWorkout(workout)
}

// 43. and 54.
// const meal = new Meal(name.value, +calories.value)
// this._tracker.addMeal(meal)
name.value = ''
calories.value = ''


// 46. collapse the meal bootstrap dropdown
const collapseItem = document.getElementById(`collapse-${type}`)

// we have access because we are including the bootstrap javascript file.
const bsCollapse = new bootstrap.Collapse(collapseItem, {
toggle: true
})
}



// 60. 
_removeItem(type, e){
if(e.target.classList.contains('delete') || e.target.classList.contains('fa-xmark')){

  if(confirm('Are you sure?')){
    // console.log('delete')
    const id = e.target.closest('.card').getAttribute('data-id')
    // console.log(id)

    type === 'meal'
    ? this._tracker.removeMeal(id)
    : this._tracker.removeWorkout(id);

  e.target.closest('.card').remove()
  }
}
}

// 66. 
_filterItems(type, e){
const text = e.target.value.toLowerCase() 
// console.log(text)

// loop through the items want to get the id for the meals and wokouts `#${type}-items` and the class of .card targeting the card item and then loop through

// 67. 
document.querySelectorAll(`#${type}-items .card`).forEach((item)=> {
  // the item in the forEach is the card we want to get the chilc of the child and then the text content which is the name because that is what we want to filter

  // firstChild pertains to all nodes if it an element, comment or text we want we just want to deal with elements firstChildElement  

// 68. 
const name = item.firstElementChild.firstElementChild.textContent

if(name.toLowerCase().indexOf(text) !== -1){
// indexOf if it does not match the result is negative -1 if it is a match want it to show

item.style.display = 'block'
}else{
item.style.display = 'none'
}
})
}

// 70. reset
_reset(){

// the tracker is to do with calories, two arrays, meals and workouts     
this._tracker.reset()

// clear up any meals workout items anything to do with the dom 
document.getElementById('meal-items').innerHTML = ''
document.getElementById('workout-items').innerHTML = ''

// input so use value 
document.getElementById('filter-meals').value = ''
document.getElementById('filter-workouts').value = ''
} 

// 73.
// e event object
_setLimit(e){
  // since it is a form preventDefault
  e.preventDefault()

  // get limit 2000 
  const limit = document.getElementById('limit')


//  74.  
if(limit.value === 0){
  alert('Please add a limit')
  return
}

// since the calorie limit is in the tracker call a method in the tracker add a + as a number as it is passed as a string  

// 75.
this._tracker.setLimit(+limit.value)
limit.value = ''

// 76. 
// close the bootstrap popup
const modalEl = document.getElementById('limit-modal')
const modal = bootstrap.Modal.getInstance(modalEl)
modal.hide()
}

// 50. delete _newWorkout(e) edit 39. _newMeal() renamed to newItem()
// ---44. Start---
// _newWorkout(e){ //pass in event
//   e.preventDefault() //since this is a submit event
//   // console.log(this) 

//   // we could set these variables to .value at the end as this is how we get an input value. I like to have the variables just to the element iteself and just add on .value as and when you need it.
// const name = document.getElementById('workout-name')
// const calories = document.getElementById('workout-calories')

// if(name.value === '' || calories.value === ''){
// alert('Please fill in all fields')
// return
// }

// const workout = new Workout(name.value, +calories.value)
// this._tracker.addWorkout(workout)
// name.value = ''
// calories.value = ''
// // ---44. End---



// // 47. collapse the workout bootstrap dropdown
// const collapseWorkout = document.getElementById('collapse-workout')
// // we have access because we are including the bootstrap javascript file.
// const bsCollapse = new bootstrap.Collapse(collapseWorkout, {
// toggle: true

// })
// }


}

// 40.
const app = new App() //we have to initialise our app only thing we have to do to kick off our entire application which will run the constructor and then everything basically happens from there..  




// ***Tracalorie App (OOP Project) Teacher Code***


class CalorieTracker {
  constructor() {
    this._calorieLimit = Storage.getCalorieLimit();
    this._totalCalories = Storage.getTotalCalories(0);
    this._meals = Storage.getMeals();
    this._workouts = Storage.getWorkouts();

    this._displayCaloriesLimit();
    this._displayCaloriesTotal();
    this._displayCaloriesConsumed();
    this._displayCaloriesBurned();
    this._displayCaloriesRemaining();
    this._displayCaloriesProgress();

    document.getElementById('limit').value = this._calorieLimit;
  }

  // Public Methods/API //

  addMeal(meal) {
    this._meals.push(meal);
    this._totalCalories += meal.calories;
    Storage.updateTotalCalories(this._totalCalories);
    Storage.saveMeal(meal);
    this._displayNewMeal(meal);
    this._render();
  }

  addWorkout(workout) {
    this._workouts.push(workout);
    this._totalCalories -= workout.calories;
    Storage.updateTotalCalories(this._totalCalories);
    Storage.saveWorkout(workout);
    this._displayNewWorkout(workout);
    this._render();
  }

  removeMeal(id) {
    const index = this._meals.findIndex((meal) => meal.id === id);

    if (index !== -1) {
      const meal = this._meals[index];
      this._totalCalories -= meal.calories;
      Storage.updateTotalCalories(this._totalCalories);
      this._meals.splice(index, 1);
      Storage.removeMeal(id);
      this._render();
    }
  }

  removeWorkout(id) {
    const index = this._workouts.findIndex((workout) => workout.id === id);

    if (index !== -1) {
      const workout = this._workouts[index];
      this._totalCalories += workout.calories;
      Storage.updateTotalCalories(this._totalCalories);
      this._workouts.splice(index, 1);
      Storage.removeWorkout(id);
      this._render();
    }
  }

  reset() {
    this._totalCalories = 0;
    this._meals = [];
    this._workouts = [];
    Storage.clearAll();
    this._render();
  }

  setLimit(calorieLimit) {
    this._calorieLimit = calorieLimit;
    Storage.setCalorieLimit(calorieLimit);
    this._displayCaloriesLimit();
    this._render();
  }

  loadItems() {
    this._meals.forEach((meal) => this._displayNewMeal(meal));
    this._workouts.forEach((workout) => this._displayNewWorkout(workout));
  }

  // Private Methods //

  _displayCaloriesTotal() {
    const totalCaloriesEl = document.getElementById('calories-total');
    totalCaloriesEl.innerHTML = this._totalCalories;
  }

  _displayCaloriesLimit() {
    const calorieLimitEl = document.getElementById('calories-limit');
    calorieLimitEl.innerHTML = this._calorieLimit;
  }

  _displayCaloriesConsumed() {
    const caloriesConsumedEl = document.getElementById('calories-consumed');

    const consumed = this._meals.reduce(
      (total, meal) => total + meal.calories,
      0
    );

    caloriesConsumedEl.innerHTML = consumed;
  }

  _displayCaloriesBurned() {
    const caloriesBurnedEl = document.getElementById('calories-burned');

    const burned = this._workouts.reduce(
      (total, workout) => total + workout.calories,
      0
    );

    caloriesBurnedEl.innerHTML = burned;
  }

  _displayCaloriesRemaining() {
    const caloriesRemainingEl = document.getElementById('calories-remaining');
    const progressEl = document.getElementById('calorie-progress');

    const remaining = this._calorieLimit - this._totalCalories;

    caloriesRemainingEl.innerHTML = remaining;

    if (remaining <= 0) {
      caloriesRemainingEl.parentElement.parentElement.classList.remove(
        'bg-light'
      );
      caloriesRemainingEl.parentElement.parentElement.classList.add(
        'bg-danger'
      );
      progressEl.classList.remove('bg-success');
      progressEl.classList.add('bg-danger');
    } else {
      caloriesRemainingEl.parentElement.parentElement.classList.remove(
        'bg-danger'
      );
      caloriesRemainingEl.parentElement.parentElement.classList.add('bg-light');
      progressEl.classList.remove('bg-danger');
      progressEl.classList.add('bg-success');
    }
  }

  _displayCaloriesProgress() {
    const progressEl = document.getElementById('calorie-progress');
    const percentage = (this._totalCalories / this._calorieLimit) * 100;
    const width = Math.min(percentage, 100);
    progressEl.style.width = `${width}%`;
  }

  _displayNewMeal(meal) {
    const mealsEl = document.getElementById('meal-items');
    const mealEl = document.createElement('div');
    mealEl.classList.add('card', 'my-2');
    mealEl.setAttribute('data-id', meal.id);
    mealEl.innerHTML = `
    <div class="card-body">
    <div class="d-flex align-items-center justify-content-between">
      <h4 class="mx-1">${meal.name}</h4>
      <div
        class="fs-1 bg-primary text-white text-center rounded-2 px-2 px-sm-5"
      >
        ${meal.calories}
      </div>
      <button class="delete btn btn-danger btn-sm mx-2">
        <i class="fa-solid fa-xmark"></i>
      </button>
    </div>
  </div>
    `;

    mealsEl.appendChild(mealEl);
  }

  _displayNewWorkout(workout) {
    const workoutsEl = document.getElementById('workout-items');
    const workoutEl = document.createElement('div');
    workoutEl.classList.add('card', 'my-2');
    workoutEl.setAttribute('data-id', workout.id);
    workoutEl.innerHTML = `
    <div class="card-body">
    <div class="d-flex align-items-center justify-content-between">
      <h4 class="mx-1">${workout.name}</h4>
      <div
        class="fs-1 bg-secondary text-white text-center rounded-2 px-2 px-sm-5"
      >
        ${workout.calories}
      </div>
      <button class="delete btn btn-danger btn-sm mx-2">
        <i class="fa-solid fa-xmark"></i>
      </button>
    </div>
  </div>
    `;

    workoutsEl.appendChild(workoutEl);
  }

  _render() {
    this._displayCaloriesTotal();
    this._displayCaloriesConsumed();
    this._displayCaloriesBurned();
    this._displayCaloriesRemaining();
    this._displayCaloriesProgress();
  }
}

class Meal {
  constructor(name, calories) {
    this.id = Math.random().toString(16).slice(2);
    this.name = name;
    this.calories = calories;
  }
}

class Workout {
  constructor(name, calories) {
    this.id = Math.random().toString(16).slice(2);
    this.name = name;
    this.calories = calories;
  }
}

class Storage {
  static getCalorieLimit(defaultLimit = 2000) {
    let calorieLimit;
    if (localStorage.getItem('calorieLimit') === null) {
      calorieLimit = defaultLimit;
    } else {
      calorieLimit = +localStorage.getItem('calorieLimit');
    }
    return calorieLimit;
  }

  static setCalorieLimit(calorieLimit) {
    localStorage.setItem('calorieLimit', calorieLimit);
  }

  static getTotalCalories(defaultCalories = 0) {
    let totalCalories;
    if (localStorage.getItem('totalCalories') === null) {
      totalCalories = defaultCalories;
    } else {
      totalCalories = +localStorage.getItem('totalCalories');
    }
    return totalCalories;
  }

  static updateTotalCalories(calories) {
    localStorage.setItem('totalCalories', calories);
  }

  static getMeals() {
    let meals;
    if (localStorage.getItem('meals') === null) {
      meals = [];
    } else {
      meals = JSON.parse(localStorage.getItem('meals'));
    }
    return meals;
  }

  static saveMeal(meal) {
    const meals = Storage.getMeals();
    meals.push(meal);
    localStorage.setItem('meals', JSON.stringify(meals));
  }

  static removeMeal(id) {
    const meals = Storage.getMeals();
    meals.forEach((meal, index) => {
      if (meal.id === id) {
        meals.splice(index, 1);
      }
    });

    localStorage.setItem('meals', JSON.stringify(meals));
  }

  static getWorkouts() {
    let workouts;
    if (localStorage.getItem('workouts') === null) {
      workouts = [];
    } else {
      workouts = JSON.parse(localStorage.getItem('workouts'));
    }
    return workouts;
  }

  static saveWorkout(workout) {
    const workouts = Storage.getWorkouts();
    workouts.push(workout);
    localStorage.setItem('workouts', JSON.stringify(workouts));
  }

  static removeWorkout(id) {
    const workouts = Storage.getWorkouts();
    workouts.forEach((workout, index) => {
      if (workout.id === id) {
        workouts.splice(index, 1);
      }
    });

    localStorage.setItem('workouts', JSON.stringify(workouts));
  }

  static clearAll() {
    localStorage.removeItem('totalCalories');
    localStorage.removeItem('meals');
    localStorage.removeItem('workouts');

    // If you want to clear the limit
    // localStorage.clear();
  }
}

class App {
  constructor() {
    this._tracker = new CalorieTracker();
    this._loadEventListeners();
    this._tracker.loadItems();
  }

  _loadEventListeners() {
    document
      .getElementById('meal-form')
      .addEventListener('submit', this._newItem.bind(this, 'meal'));

    document
      .getElementById('workout-form')
      .addEventListener('submit', this._newItem.bind(this, 'workout'));

    document
      .getElementById('meal-items')
      .addEventListener('click', this._removeItem.bind(this, 'meal'));

    document
      .getElementById('workout-items')
      .addEventListener('click', this._removeItem.bind(this, 'workout'));

    document
      .getElementById('filter-meals')
      .addEventListener('keyup', this._filterItems.bind(this, 'meal'));

    document
      .getElementById('filter-workouts')
      .addEventListener('keyup', this._filterItems.bind(this, 'workout'));

    document
      .getElementById('reset')
      .addEventListener('click', this._reset.bind(this));

    document
      .getElementById('limit-form')
      .addEventListener('submit', this._setLimit.bind(this));
  }

  _newItem(type, e) {
    e.preventDefault();

    const name = document.getElementById(`${type}-name`);
    const calories = document.getElementById(`${type}-calories`);

    // Validate inputs
    if (name.value === '' || calories.value === '') {
      alert('Please fill in all fields');
      return;
    }

    if (type === 'meal') {
      const meal = new Meal(name.value, +calories.value);
      this._tracker.addMeal(meal);
    } else {
      const workout = new Workout(name.value, +calories.value);
      this._tracker.addWorkout(workout);
    }

    name.value = '';
    calories.value = '';

    const collapseItem = document.getElementById(`collapse-${type}`);
    const bsCollapse = new bootstrap.Collapse(collapseItem, {
      toggle: true,
    });
  }

  _removeItem(type, e) {
    if (
      e.target.classList.contains('delete') ||
      e.target.classList.contains('fa-xmark')
    ) {
      if (confirm('Are you sure?')) {
        const id = e.target.closest('.card').getAttribute('data-id');

        type === 'meal'
          ? this._tracker.removeMeal(id)
          : this._tracker.removeWorkout(id);

        e.target.closest('.card').remove();
      }
    }
  }

  _filterItems(type, e) {
    const text = e.target.value.toLowerCase();
    document.querySelectorAll(`#${type}-items .card`).forEach((item) => {
      const name = item.firstElementChild.firstElementChild.textContent;

      if (name.toLowerCase().indexOf(text) !== -1) {
        item.style.display = 'block';
      } else {
        item.style.display = 'none';
      }
    });
  }

  _reset() {
    this._tracker.reset();
    document.getElementById('meal-items').innerHTML = '';
    document.getElementById('workout-items').innerHTML = '';
    document.getElementById('filter-meals').value = '';
    document.getElementById('filter-meals').value = '';
  }

  _setLimit(e) {
    e.preventDefault();

    const limit = document.getElementById('limit');

    if (limit.value === '') {
      alert('Please add a limit');
      return;
    }

    this._tracker.setLimit(+limit.value);
    limit.value = '';

    const modalEl = document.getElementById('limit-modal');
    const modal = bootstrap.Modal.getInstance(modalEl);
    modal.hide();
  }
}

const app = new App();





// ***Modules & Tooling***

// - What Are Modules -
// Modules are JavaScript files that we can import into other JavaScript files. We can then use the code that is in the module in the file that we import it into. We need to export what we want from the file. This could be a function, a class or even just a variable value or an object. 

// Modules can be our own files and code or they can be part of a package that we install using `NPM` or the `Node Package Manager`. If you want to use NPM modules in the front-end, you need to use a module bundler like Webpack. 

// For now, let's just focus on how to create our own modules using our own files. Modules allow us to break our code up into different files making our code more organized and easier to maintain. Using our **Tracalorie** app as an example, we had a single app.js file with 5 different classes. It would be more organized to put each class into it's own module. We can then import the modules into the app.js file, keeping our code organized and maintainable. 

// Modules are obviously **modular**, so we can reuse them where we want. You may have a module with some utility classes to add commas to a number or something. Where ever you want to use that, you can import it and use it.

// Using a module bundler also means that we can use NPM packages. So you have access to over a million 3rd-party modules to enhance your application. You can't use NPM with the way that we've been doing things.

// Also, when you use something like Webpack or Parcel, you have access to tools to optimize your project. Whether it's minifying your code or using Sass or a custom dev server, you can create a very customized environment.


// - Types Of Modules -

// The two main types are `CommonJS Modules` and `ES Modules` or `ES6 Modules`. 

// `CommonJS Modules` are the modules that are usually used in Node.js. 

// `ES Modules` when you use a front-end framework like React, Angular or Vue, you'll be using `ES Modules`. I'm going to show you both types.

// ES Modules (React) and CommonJS (Node.js) modules have a different syntax, but the idea is the same. We export what we want from a specific module/file and import it into another. We can export variables, functions, classes, etc.

// - Modules & The Browser -

// Modules in the browser, there is support for `ESM` or `ES Modules` in newer browsers. If they're not supported in older browsers will usually use a module bundler like `Webpack` or `Parcel` to bundle our modules into a single file that can be used in the browser. Can use ES Modules directly in the browser, but it is recommended using a module bundler.


// There is a visual example of tracalorie project.

// We could separate out classes into their own files. 
// tracker
// storage
// meal 
// workout 
// export the whole class, we use whatever methods we needed from that class 

// Since we use the tracker, the meal and the workout class in the main App class, we would import it into app.js. 
// The Storage class is used in the tracker, so we would import that into `Tracker.js`. 

// The syntax we're looking at here is the `ES6 Module` syntax (React). 
// CommonJS (Node.js) is a bit different. 

// I added other files and folders as an example we want to import. 
// config folder 
// utility folder 

// We could also install 3rd-party modules/packages using `NPM`. 
// For instance, if we installed the `axios` package, which is an HTTP client, we could import it where we needed it.

// - Install Node.js -
// In order to teach you about the `CommonJS` modules as well as `NPM` modules, we need to talk about and install Node.js. 





// ***Installing & Using Node.js***

// As a front-end developer, you'll be working with `NPM` and to use NPM, you need to install Node.js.


// Node.js is a runtime environment. Up to this point, we've been executing our JavaScript code in the browser. Node.js is simply another environment to execute JavaScript code. It allows us to write server-side code with JavaScript.  Server-side code is code that can interact with databases and the filesystem, etc.


// Node is built on Chrome's V8 JavaScript engine. It uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. The way Node works is very similar to how the browser works. It uses an event loop, callbacks, promises, async/await, etc. 


// It's essentially the browser environment minus the window object. Node does have a global object, it's just not called `window`,it's called `global`.


// In Node, we don't have a document object model. So it's not used for creating interfaces like we do in the browser. It's used for creating back-end applications and APIs. It's also used for creating command line tools among other things.


// - Installing Node.js -


// Installing Node is extremely easy. Just go to https://nodejs.org/en/ and download the latest version.

// Once it's installed, you can check the version by opening up your terminal/command line and typing `node -v`. This should return the version number. You can also check the version of `npm` by typing `npm -v`. This should also return the version number.

// Let's create a folder to work in and an app.js file

// Git Bash type:

// mkdir node-playground //make directory
// cd node-playground //change directory
// touch app.js //create file
// code . 


// Running a .js file

// Add `console.log('Hello World');` to the app.js file.

// There is no browser in this environment, so `console.log()` will output to the terminal.

// Let's run this file in the terminal. We can do this by typing `node app.js`. We can also leave off the `.js` extension and just do `node app`. You should see `Hello World` logged to the terminal.

// Instead of just doing a hello world, let's fetch some data.

// The fetch API actually was not part of Node.js up until recently. We had to use an NPM package like `node-fetch` or `axios` if we wanted to make requests.

async function getUser(){
const response = await fetch('https://api.github.com/users/bradtraversy');
const data = await response.json();
console.log(data)
}

getUser()

// Now let's run this file in the terminal with `node app.js`.

// You should see the data logged in the terminal. It is using the node.js runtime.




// ***CommonJS Modules (Node.js)***

// CommonJS Modules default to Node.js 
// CommonJS syntax is an older syntax that is used in Node.
// You won't use this much on the front-end, but if you plan on being a full-stack or back-end developer, you'll need to know it.


// Let's create an `app.js` file and a `utils.js` file. Let's say that the app file is the main entry point and utils is just some extra utility functions that we want to be able to use in multiple files.

// In `utils.js`, I am going to create a function that will capitalize the first letter of every word.

// utils.js 
const message = {
id:1, 
text: 'Hello World'
};

// access message object from App.js so we have to export it from this file.
module.exports = message 


// App.js 

// import from utils.js using the require() function. You use your require() whether it is your own module, file or npm package. Add the path to file we want to bring in e.g. './utils'
const message = require('./utils')

console.log(message) //{ id: 1, text: 'Hello World' }
// console message and in the terminal type node app

// console just the text in the terminal type node app
console.log(message.text) //Hello World 



// The other way, although the first way is best, but you can export files is that instead of putting it in a variable you can directly call the function module.exports:

// utils.js 
module.exports = {
id:1, 
text: 'Hello World'
};



// New Project Practice
// - capitalize every first letter and every word in a sentance -

// utils.js 

function capitalizeWords(str){
return str
.toLowerCase()
.split(' ') //split turns it into an array gap in the ' ' will split by each word 
.map((word)=>word[0].toUpperCase() + word.substring(1))
.join(' ') //turn from array back into string join by the space
}

module.exports = capitalizeWords // do not add () as this will execute it


// app.js 

const capitalizeWords = require('./utils')

console.log(capitalizeWords('hello world'))
// run in terminal node app Hello World



// - we have been exporting a single function what if we have many -


// utils.js 

function capitalizeWords(str) {
  return str
    .toLowerCase()
    .split(' ')
    .map((word) => word[0].toUpperCase() + word.substr(1))
    .join(' ');
}


function makeMoney(amount){
  return `$${amount}`
}


// if you have multiple functions that you want to export you put it in an object:
module.exports = {
  capitalizeWords,
  makeMoney,
}


// app.js 

// destructure using curly braces { capitalizeWords }
const { capitalizeWords, makeMoney } = require('./utils')

console.log(capitalizeWords('hello world'))
console.log(makeMoney(100))

capitalizeWords

// Hello World
// $100


// - importing a class -
// create another file Person.js with a capital Person as that is the convention when using class.

// Person.js 

class Person{
constructor (name, age){
  this.name = name
  this.age = age
}

greet(){
console.log(`Hello my name is ${this.name} I am ${this.age}`)
}

}

module.exports = Person



// app.js 

// destructure using curly braces { capitalizeWords }
const { capitalizeWords, makeMoney } = require('./utils')

const Person = require('./Person')

console.log(capitalizeWords('hello world'))
console.log(makeMoney(100))

const person1 = new Person('Osman', 30)
person1.greet()
// terminal node app
// Hello my name is Osman I am 30




// ***NPM Packages/Modules***

// NPM Modules

// `NPM` stands for `Node Package Manager`. It's a package manager for JavaScript. It's used to install 3rd-party packages and modules that we can use in our projects. There are over a million packages that you can install in a single command. Packages are hosted at: 
npmjs.com

// Let's create another `app.js` file. I'm going to install and use `Axios`, which is a 3rd-party HTTP client that is similar to the Fetch API, but even more powerful.

// When you create a Node.js app, the first thing that you usually do is run: 

npm init

// This will create a `package.json` file.

// will ask questions:
// package name: 
// version:
// description:
// entry point:
// test command:
// git repository:
// keywords:
// author:
// license: 
// Is this OK? (yes)

// package.json file is used to keep track of your dependacies meaning packages, whatever you install, if we run npm install..whatever that whatever will be put into packages.json   

// - Store information about your project. 
// - It's also used to store information about the packages that you install. It's kind of like a manifest file. 
// - It's also used to store scripts that you can run from the command line. 

// let's just run `npm init` and accept all of the defaults.

// bash 
npm init

// You can also run: 
npm init -y 
// It accept's all of the defaults without having to answer any questions.

// In this file, you will see some standard information about the project. 

// You will also see: dependencies object 

// This is where the information about the packages that we install will be stored. 

// Let's install `axios`.
// bash
npm install axios

// Now, if you look at your file of: 

package.json  

// You will see: 
axios

// "dependencies": {
//  "axios": "^1.4.0"
//  }

// Also listed in your: projects dependencies 
// You will also see a new folder called package-lock.json you do not need to do anything with it just keeps track on the version and locks that file version.

// It also creates a new folder called: 

node_modules

// This is where the packages that we install will be stored. If you look in it you will see a bunch of folders because our dependencies/packages use other dependencies. 

// So this file gets VERY large. It is important that you do not commit this folder to version control, meaning you do not want to push to github or push to some platform to host your application. You do not want to push this node module. The only place it should be is on your local machine. The reason we don't need this is because if someone downloads your project without the ode modules folder they simply just have to run NPM install or NPM i without anything else, it'll then install whatever you have in the dependacies object and it will create the node modules folder so there is no need to include it.  

// The way you can stop it from being pushed to GitHub or wherever you are pushing to it create a file called:

.gitignore 

// Let's do that now.
// In that file whatever you put, whether it is a file or folder so lets say node_modules will not get pushed to GitHub.

// Standard setup for every project using Node JS project.


// bash
echo "node_modules" >> .gitignore

// Now, when we commit our code, the `node_modules` folder will not be included.




// OK now I want to show you how we can use Axios go to our `app.js` and import axios

const axios = require('axios');
// import axios from 'axios';

// Now we can use it to fetch some data from an API. Let's use the `JSON Placeholder` API to fetch a single post.


const axios = require('axios');
async function getPost(){
const res = await axios.get('https://jsonplaceholder.typicode.com/posts/1')
console.log(res.data)
}

getPost()

// type node app in terminal app is name of file

// We are able to use `axios` because we installed and imported it. You can see we get an object with ID, title, body, user ID. So we are fetching data using axios. If we did not install axios we would not be able to use it. 

// Let's install one more package called:

Lodash 

// This is a utility library that has a lot of useful methods. Let's install it. We can use:

i //shorthand for install


// Global Packages

// You can also use the: 
-g
// An option to install packages globally. This means it's not installed in your local project in the `node_modules` folder. It's installed globally on your system and you can use it where ever you want. 

// An example would be: 
 npm i -g axios 
//   this will not be installed in your local files it gets installed on your system and you can use it globally. Not alot of reasons or times you will need to do that and example will be:

create-react-app 

// This will generate a whole react application it is a utility that you can run to generate a new React boilerplate. You could install this globally, that is something you might install locally that you can just run it anywhere and it will generate a React application.

// bash
npm install -g create-react-app
// You could then run it from anywhere.



// - Dev Dependecies -
// Sometimes, you may use packages that are strictly for your development environment. It is a package that will constantly watch your application so when you update it you do not have to run it again it'll just monitors it.  An example would be: 
nodemon
// Which monitors your application so you don't have to keep running it. 

// Nodemon would not be needed in your production environment, it is no reason to include it when you push to your production server, it is a development dependancy. So you could install it as a dev dependency with the `-D` option

// bash
npm install -D nodemon

// Then, in your package.json file, it would be put in a `devDependencies` object.

// "devDependencies": {
// "nodemon": "^2.0.22"
// }

// axios is not something you want to install as a devDependencies because you are using it in your application to make requests, but nodemon is just for your local environment.

// - NPM Scripts -

// scripts inside packege.json

// "scripts": {
//     "test": "echo \"Error: no test specified\" && exit 1"
//   }


// There is a dummy text script but usually I delete this because this has to do with unit testing so you can change it to start and typically have it run the command to start your application which in this case is node app.js. 

// "scripts": {
//   "start": "node app.js"
//   }

// So if you then come down to the terminal and run it will just run the app: 

npm start

// Let's say that we want to run our `app.js` file. We could run `node app.js`, but that's kind of long. 

// We can create a script in our `package.json` file to make this easier. Let's add a `start` script.

// package.json

{
  "name": "npm-modules",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^0.21.1",
    "lodash": "^4.17.21",
    "uuid": "^8.3.2"
  }
}

// Now we can run: 
npm start // to run our `app.js` file.

// Note that if you use something other than `start` or `test` or `help`, you will have to use the run keyword: 
npm run <script name> 

//  So `dev` is a common one in packages.json:

// "scripts": {
//     "start": "node app.js",
//     "dev": "nodemon app.js"
//   }

// What we will have dev do is actually use nodemon app.js which will constantly monitor your file. So down here if we want to run it in the terminal we do not do: npm dev

// We do:

npm run dev
// It will run our file and nodemon runs aswell. It will continue to run if you want to get out you will have to do ctrl c


// Let's change start to `dev`. Let's add a: 
dev // script that will run our app with 
Nodemon

json
{
  "name": "npm-modules",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^0.21.1",
    "lodash": "^4.17.21",
    "uuid": "^8.3.2"
  }
}

// To run Nodemon, we would do the following

// bash
npm run dev

// So those are the basics of NPM. You'll be using it quite a bit as a JavaScript developer.






// ***ES or ES 6 Modules***

// When it comes to the front-end and the browser, you're not going to be using CommonJS (Node JS) modules in the browser. You technically can if you use a module bundler, but ES Modules (React) are much more popular and more modern. You can use ES modules with Node in your backend code there are extra steps you have to take. 

// What I want to show you how we can use ES modules in the front end. So we are going to go back to the browser rather than running our JS with node.


// Modern browsers support ES Modules, however older browsers do not.

// This is why it is suggested that you use a module bundler like Webpack to bundle our modules into a single file that can be used in the browser. 

// Using something like Webpack or Parcel has other benefits as well: 
// - You can install and use `NPM` modules.
// - You can install plugins to do all kinds of things to optimize your code. 
// - They typically have some kind of local web server as well. Although, that's not really a big deal, because we have `Live Server` installed in VS Code.

// In this lesson, we are not going to use any module bundlers. We're just going to use ES Modules in Chrome. The import/export syntax is the same wether you use a module bundler or not.





// - The `type="module"` Module Attribute -

// Create an `index.html` file and an `app.js` file to start with. Since we are going to be using modules in the browser, when you add the `<script>` tag to the HTML file, you need to add the `type="module"` attribute. This tells the browser that this is an ES Module. You can also add the `defer` attribute, which will make sure that the script is loaded after the HTML is loaded. This is just a good practice to get into.

<script src="app.js" type="module" defer></script>

// index.html 

// <!DOCTYPE html>
// <html lang="en">
// <head>
// <meta charset="UTF-8">
// <meta http-equiv="X-UA-Compatible" content="IE=edge" />
// <meta name="viewport" content="width=device-width, initial-scale=1.0">
// <script src="app.js" type="module" defer></script>
// <title>ES Module</title>
// </head>
// <body>
// <h1>ES Modules</h1>
// </body>
// </html>


// app.js 
console.log(123)
// in the console opened with with live server should see output 123 because of type="module" in index.html


// Creating Modules
// Let's do the same thing that we did in the `CommonJS` lesson. Although, ths time I'm going to create a folder called `modules` and put my files in there. Let's start with our modules folder and utils.js file.


// utils.js 
// (with common js module.exports = name of file)

// With ES Modules we use export if we have one thing we use default
// export default name

function capitalizeWords(str) {
  return str
    .toLowerCase()
    .split(' ')
    .map((word) => word[0].toUpperCase() + word.substr(1))
    .join(' ');
}


export default capitalizeWords

// app.js 

import capitalizeWords from "./modules/utils.js"; //add the .js file extension
console.log(capitalizeWords('hello world'))



// - example if there is more than one function -

// utils.js
function capitalizeWords(str) {
  return str
    .toLowerCase()
    .split(' ')
    .map((word) => word[0].toUpperCase() + word.substr(1))
    .join(' ');
}

function makeMoney(amount) {
  return `$${amount}`;
}


// do not need to use the word default in export we just use default and put it in an object.
export { capitalizeWords, makeMoney }


// As you can see, to export, we use the `export` keyword. We can export multiple things by separating them with a comma. So remember, with `CommonJS`, we use `module.exports = {}`, with ES Modules, we use `export {}`.

// Now, let's use it in the `app.js` file.


// app.js 

// destructure { }
import { capitalizeWords, makeMoney } from "./modules/utils.js";

console.log(capitalizeWords('hello world'))
console.log(makeMoney(100))


// So instead of using `require()` like we did with `CommonJS`, we use the `import` keyword. Since we are exporting and importing multiple things, we use curly braces and commas. When we do not use a bundler, we need to include the file extension on the import.

// Now, let's create a `Person.js` file and export a single class.

// - example if we use class ES Modules -

// new file in modules folder Person.js

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age}`);
  }
}

export default Person;

// Notice we used `export default` instead of `export`. This is because we are only exporting one thing. We can only use `export default` once per file. If we try to use it more than once, we will get an error. You can use as many `export` statements as you want.

// Let's import `Person`

// app.js 

import Person from "./modules/Person.js";

const Person1 = new Person('John', 40)
Person1.greet()
// Hello, my name is John and I am 40

// Notice we didn't use curly braces. That's because we exported as default.

// So that is the `ES Module syntax`. It's a bit nicer than `CommonJS`. You can also use `Node.js` with ES Modules, there is just a little bit of setup that goes into it. 





// ***Module Bundlers***

// A module bundler is a tool that takes all of your source code which is multiple files and bundles them together into one or more files often times into a single build file that can be used in the browser.


// There are a few popular module bundlers out there, but we'll be focusing on `Webpack`. There are some others such as `Vite`, `Parcel` and `Snowpack`.

// How It Works

// The way that we've been doing things is pretty simple. We create our JavaScript code and run it in the browser.

// When you get into more advance JavaScript and start building bigger applications, you're probably going to use some kind of build tool such as Webpack. 

// A framework like React, also uses module Bundlers under the hood. The thing is with  front-end frameworks like React you do not need to deal with them, you do not configure them. It is all done for you. It is good to know what is actually going on it makes thing easier to understand your code and debug your code.

// So How It Works:

// We have our src or app.js file the code that we write. It might have components.js, utils.js and npm modules, we install that it will be in our src file with css or sass files.

// We run it through webpack and we end up with a single bundle.js or main.js file normally in a folder called dist or build file and that is what is included in the HTML and loaded in the browser. It includes all of our code, all of our modules and NPM modules, everything it is all bundled together becuase of webpack.

// webpack 

// We are going to have a config file which is called:

webpack.config.js 

// It is here where you can specify your input javascript which in this case is app.js our output bundle.js. You can change those names. You can load plugins and loaders. You can set the mode whether you are in development mode or production mode.

// webpack has loaders

// loaders are used to process different types of files and convert them into modules that can be used by our application e.g. if you want to import a CSS file directly into your javascript you can do that with a CSS loader. If you want to be able to import an asset like an image there is an image loader. 

// There is Babel. It is a loader that will transpile newer modern javascript syntax to older syntax that older browsers can understand which will make your application more compatible with older browsers 


// webpack has plugins

// plugins are used to extend the functionality of webpack. If you want to minify your javascritpt you can use a minification plugin. 

// There is a plugin called HTML web pack which will automatically generate our HTML production files. 

// There is also going to be using a plugin called webpack dev server which is a plugin that will give us a nice dev server that will auto reload whenever we save and so on like VS Code live server.










// ***Webpack Basic Setup***

// New Folder Shift Cntrl N (open with VS Code)

// Webpack Setup

// Alright, now we are going to setup Webpack. Like I said, your configuration and what your tooling does can be as simple or advanced as you want. This is the boilerplate that I use. I will include the finished project in this lesson. I have a very similar project at https://github.com/bradtraversy/webpack-starter. It does have a few extra bells and whistles, but it is very similar and used in the same way.

// Let's start off by creating a folder called `webpack-starter`. Open it with your text editor and run `npm init` to create a package.json file.

// Create folders

// We are going to create a few folders. Create a `src` folder and a `dist` folder. The `src` folder is where we are going to put our source code. The `dist` folder is where we are going to put our bundled code. We are going to use the `dist` folder for production.

// Create an `index.html` file in the `dist` folder. We'll put some boilerplate HTML in there for now. We are going to create a `script` tag and point it to a file called `main.js`. This file does not exist yet. This is the output file that Webpack is going to create for us.

// Now, create a file called `index.js` in the `src` folder. This will be the entry point for our application. Let's also create a file called `message.js` in the `src` folder. This is going to be a module that we are going to import into the `index.js` file.

// In the `message.js` file, let's export an object with an id and a text field. You could also export functions, classes, etc.

// js
export default {
  id: 1,
  text: 'Hello World',
};

// We could also give it a variable name and export the variable

// js
const message = {
  id: 1,
  text: 'Hello World',
};

export default message;


// Bring it into the `index.js` file and log the text message.

// js
import message from './message.js';
console.log(message);


// Now, this is not code that would work on it's own in the browser. We need to bundle it with Webpack. We are going to use Webpack to bundle our code into a single file.

// Install Webpack

// Now we are going to install Webpack. Run `npm install -D webpack webpack-cli`. We use the `-D` to save as a `development dependency`. Meaning this is a dev tool and it won't be used in production. This will get put in the `devDependencies` section in the package.json file.

.gitignore

// Let's create a `.gitignore` file in src folder. We don't want to commit the `node_modules` folder to GitHub. We also don't want to commit the `dist` folder. We are going to create that folder when we build our application. We are going to add the `dist` folder to the `.gitignore` file.

// txt
node_modules
dist


// Create Build Script

// Let's open up the `package.json` file and create a build script. What I mean is a command that we can run to take our source code and bundle it into our production files. We don't have a config file yet, so I am just going to add the mode flag and set it to production.

// json

"scripts": {
  "build": "webpack --mode production"
}


// Now, let's run `npm run build`. This will run the build script. We should see a `main.js` file show up in the `dist` folder. If we open up the `index.html` file in the browser, we should see `Hello World` in the console. I'll just use `live-server` for now, but I will show you a webpack dev server that we can use in a bit.

// Create webpack.config.js

// Now we are going to create a `webpack.config.js` file. In your route not in src folder or dist folder. 

// This is where we are going to put our Webpack configuration. It is an object that we are going to export. We use the `CommonJS` module syntax in this particular file.  

// I'm going to change the output file from `main.js` to `bundle.js`. We will also put the `mode` in here and take it out of the `package.json` file. 

// In package.json we set the mode to production 
  
// "scripts": {
//  "build":  "webpack --mode production"
// }

// now delete production in package.json leaving it to run webpack

// "scripts": {
//  "build":  "webpack"
// }


// We will also set it to `development` for now. Also add the entry point it is from src and the index.html if you want to set it to something else you can. entry: './src/index.js',

// js
const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
  },
};


// We used the `path` module to get us the absolute path. It's a built-in module in Node. We are going to use the `__dirname` variable to get us the current directory using double underscore then point to the dist folder. We are going to use the `resolve` method to resolve the path. It allows us to use absolute file paths.

// Now let's change the file name in our HTML from `main.js` to `bundle.js`. 

// Now, let's run `npm run build`. We should see a `bundle.js` file show up in the `dist` folder. If we open up the `index.html` file in the browser, we should see `Hello World` in the console. You can delete the `main.js` file now.


// In the dist folder delete main.js folder.

// In index.html change main.js to bundle.js 
// <script src="bundle.js" defer></script>



// NPM Modules

// We are now able to build much more advanced applications just being able to import files. We can also use `NPM` modules for our frontend apps.

// Let's install a package called `UUID`, which will generate unique IDs for us. Run `npm install uuid`. Now, let's import it into the `message.js` file and use it for the id.

// message.js
import { v4 as uuidv4 } from 'uuid';

// message.js
export default {
  id: uuidv4(),
  text: 'Hello World',
};


// Now, build again with `npm run build`. You should see a `bundle.js` file in the `dist` folder. If you open up the `index.html` file in the browser, you should see a different ID in the console everytime you refresh the page. We are now using the UUID package in our frontend app.

// I'm going to remove `UUID`, because I don't want it in the boilerplate. I just wanted to show you we can use NPM modules.

npm remove uuid

// message.js
const message = {
  id: 1,
  text: 'Hello World',
};

export default message;


// Make sure that you run `npm run build` again after you remove the package. Right now, you have to do this for every single change, but I will show you how to set up a dev server that will watch your files soon.

// So, now that you know how to import files and use NPM modules, then build your production files with Webpack, let's move on to the next lesson and talk about `loaders`, specifically the `css` and `style` loaders.



// ***CSS & Style Loaders***

// In webpack, `loaders` are modules that transform the source code of an application as it's being bundled it pre-process files as you include them in your application, and provide a means to transform code written in one language (such as TypeScript or CSS) into JavaScript that the browser can understand. You can also use loaders to use frameworks like React or Vue in your application.

// We are going to use a loader to transform our CSS files and let us import them directly into our JavaScript. 
// import css files into our Javascript. Need to install two things the CSS loader and style loader.

// Go to the terminal.
// Let's install the `style-loader` and the `css-loader`. 
// dev dependacies for the development environment
// npm i -D style-loader css-loader 

// when you install a loader you have to configure it. This happens in the webpack config file.

// In webpack.config.js under output there is an object we need to create called module. Also there is an array called rules that we need to create and this is where our loaders go. Each loader will have an object where we want to creat our rules which can have multiple loaders in this case we are going to have the style loader and CSS loader.

// When you configure them in the config file. Loaders are specified in the `module.rules` field of the config file. Each rule consists of a regular expression that determines which files the loader should be applied to, and an array of loaders to use.

// There is two properties we need to add here 'test' which is basically a regular expression where do you want this loader to apply so for this instance any file that ends with .css. We use a regular expression are put in front of two forward slashes and then backslash .css and then a money sign to say it should end with .css. Whatever we put in the next property or next value 'use' will be used in any file that matches the regular expression which is anything that ends with .css file. So 'use' we want an array of 'style-loader' and then 'css-loader' in strings. We are looking for any file that ends with CSS and we want to apply the style loader in CSS loader.  

// webpack.config.js
const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
  },
  module:{
    rules:[
      {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'],
    },
    ],
  },
};



// Here, we are saying that any file that ends with `.css` should be processed by the `style-loader` and the `css-loader`. The `style-loader` will add the CSS to the DOM by injecting a `<style>` tag, and the css-loader will interpret `@import` and `url()` like `import/require()` and will resolve them.

// Now let's create a folder in `src/css/style.css` and make the background of the page purple.


// src/css/style.css
// body{
// background-color: purple;
// color: white;
// }

// Now, we should be able to simply import the CSS file into our JavaScript file in index.js. Let's import it into the `index.js` file

// index.js
import './css/style.css';


//Lets build again with npm run build 


//You should see in the production file `bundle.js` file in the dist folder to find purple with cntrl f you will see purple. This is because the `style-loader` injected the CSS into the DOM by injecting a `<style>` tag.


// If you open up the `index.html` file in the browser, you should see a purple background. We are now using the CSS loader to import our CSS file into our JavaScript file. We do not need to add or include it into the index.html and we dont have to add any style sheets in our dist folder because it is all bundled. Webpack will take images, SAAS files, CSS files, typscript, files, jsx. You can set up all these different languages and technologies and you can have it all bundled into your javascript. So your production files is very clean what you are actually uploading to the server.


// ***HTML Webpack Plugin***


// So, the way that we have things right now, it's ok, but it's a very basic setup. We created the `index.html` file and we added a script tag to it. The issue with this is that we have this static HTML file, so if I were to share this code, I have to include the `dist` folder. 

// So, what we're going to do is we're going to use the `HTMLWebpackPlugin` to generate the `index.html` file for us in the dist folder. This means that we don't have to worry about creating the `dist` folder. So, let's go ahead and install it.

// terminal install as dev dependancy
npm i -D html-webpack-plugin


// Then, we're going to import it into our `webpack.config.js` file.

// webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');


// Then we are going to add it to the plugins array.

// webpack.config.js
plugins: [
  new HtmlWebpackPlugin({
    title: 'Webpack App'
    filename: 'index.html'
  })
]


// full code in location for info on webpack: https://webpack.js.org/

const path = require('path');


const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
  },
  module:{
    rules:[
      {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'],
    },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'Webpack App',
      filename: 'index.html',
      template: './src/index.html',
    })
  ]
};


// Now, we should be able to delete the whole dist folder. It will be regenerated on build.

// terminal 
npm run build
// It should be regenerated with a new index.html file and including automatically adding in the html boiler plate a <script defer src="bundle.js"></script>


// Now the dist folder will be created with both the `bundle.js` and `index.html` files. If we open up the `index.html` file in the browser, we should see `Hello World` in the console. We are now using the `HTMLWebpackPlugin` to generate the `index.html` file for us.

// The issue that we have now is if I add anything to the html file, such as a <h1>, it will go away when we build again. We fix this by adding a template. We add the template or index file to the `src` folder and then we add the template property to the `HTMLWebpackPlugin` and set it to the template file.

// webpack.config.js 
plugins: [
  new HtmlWebpackPlugin({
    title: 'Webpack App'
    filename: 'index.html'
    template: './src/index.html'
  })
]


// Inside the src folder create using `index.html` as the name, but you could call it anything that you want (eg. template.html). Whatever we put in `src/index.html` will be in the `dist/index.html` file. We delete the <script defer src="bundle.js"></script>

// So, let's go ahead and add some basic HTML and add an `<h1>` tag to the `src/index.html` file. We can also use values from the `webpack.config.js` file in the index.html or template.html. So, let's go ahead and add the title to the `<title`> tag and the `<h1>` tag.
  
// <%= htmlWebpackPlugin.options.title %>
// option taken from webpack.config.js 
// title: 'Webpack App'

// In the src/index.html 
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <title><%= htmlWebpackPlugin.options.title %></title>

  </head>
  <body>
    
    <h1><%= htmlWebpackPlugin.options.title %></h1>
    <p>Hello World</p>
  
    </body>
</html>

// terminal 
npm run build


// Now, take a look at `dist/index.html`. You should see the title and the `<h1>` and <p> tag that we added to the `src/index.html` file. So now, we do not have to create a `dist` folder to share our code. We simply run `npm run build` and it creates the `dist` folder.

// You  are never going to touch anything in the dist folder. All the code is in src. So when you push your app to GitHub there is no need to have the dist folder. You can just create a README that says to run npm and run build and then you have your production files. If you upload to a server then you simply upload two files bundle.js and index.html from the dist folder. 

// We can use npm packages, import css files etc and we simply deploy these two files bundle.js and index.html.



// ***Webpack DevServer Plugin***

// It get's quite annoying to have to run `npm run build` after every little change. There is a plugin that we can use that will watch our files and rebuild them for us. Let's install it.

// terminal
npm install -D webpack-dev-server
// check package.json it should be added
// "webpack-dev-server": "^4.15.1"

// We now want to create a new NPM script to run the server. Let's open up the `package.json` file and add a new script.

// package.json add another script
"scripts": {
  "build": "webpack",
  "start": "webpack serve"
}

// Add we do need to configure it in the config

// Before we run it, I just want to add some values to the config file. Right above the `modules` object, add the following:

// webpack.config.js 
 devServer: {
    static: {
      directory: path.resolve(__dirname, 'dist'),
    },
    port: 3000,
    open: true,
    hot: true,
    compress: true,
    historyApiFallback: true,
  },
  module: {
    //..
  }


// So here, we are telling the dev server to serve the files from the `dist` folder. We are also telling it to open the browser on start and to use hot module replacement. We are also telling it to compress the files and to fallback to the `index.html` file if it can't find the file.

// Now, let's run `npm run dev` and it should open up on `http://localhost:3000`. If we make a change to the `index.js` file, it should rebuild the application and refresh the browser for us.

// If I make a change, like change the message to 'Hello World from Webpack', in src/index.html it should rebuild the application and you press refresh in the browser for us, you do not have to run build.


// ***Babel Setup***

// Babel Loader

// The last thing that I want to do is setup `Babel`, which is a JavaScript transpiler that will take any modern newer JavaScript that we write and transpile it into older code that older browsers can understand. These days, I guess it is not completely mandatory, but it's still a good idea to make our code more backwards compatible.

// We can install Babel and the Babel loader with the following command:

`npm install -D babel-loader @babel/core @babel/preset-env`

// If you check pacage.json in devDependencies you should see Bable installed:
    // "@babel/core": "^7.22.5",
    // "@babel/preset-env": "^7.22.5",
    // "babel-loader": "^9.1.2",

// Then in the Webpack config, we need to add a rule to the module object. We are going to add `.js`. We also want to exclude anything in the `node_modules` folder. We also want to add the preset-env to the options object.

// webpack.config.js 
module: {
  rules: [
    //..
     {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
          },
        },
      },
  ],
},

// /regular expression/
// use can be an array or an object

// Now, we can run `npm run dev` or `npm run build` and it should work as expected.

// If you want to test it out, you can use an arrow function in your source code, and you will see it will be a regular function in your build file bundle.js.


// ***CSS Minify Extract Plugin***

// https://webpack.js.org/plugins/mini-css-extract-plugin/#root

// terminal
npm install --save-dev mini-css-extract-plugin

// webpack.config.js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");


// add - new MiniCssExtractPlugin() - to plugins array 


plugins: [
    new HtmlWebpackPlugin({
      title: 'Webpack App',
      filename: 'index.html',
      template: './src/index.html',
   }),
   new MiniCssExtractPlugin()
  ],


  // webpack.config.js
  // [MiniCssExtractPlugin.loader, 'css-loader']

  // module:{
  //   rules:[
  //     {
  //     test: /\.css$/,
  //     use: [MiniCssExtractPlugin.loader, 'css-loader'],
  //   }

  //terminal
  npm run build 

  //terminal dev environment
  npm run dev 
  // web browser http://localhost:3000/

// Now we have a seperate main.css file in our dist production. We still import our css files from index.js 



// ***Tracalorie Refactor To Use Webpack***

// So we have a modern front-end dev environment setup. We have Webpack, Babel, and DevServer all setup and working. We can now start to refactor the Tracalorie app using this `webpack-starter` project.

// - Tracalorie Webpack Refactor - 

// Now we are going to take the Tracalorie project, which is just a bunch of classes in a single file, and refactor it to use Webpack. We're going to use the `webpack-starter` boilerplate. I will include it in this lesson, if you don't have it already. You will also need the `tracalorie` project so we can copy the files and code over to the webpack project. I will include that as well.

// - Set Up Files -

// Copy the `webpack-starter` boilerplate and rename it to `tracalorie-webpack`. Open the `package.json` and change the name to `tracalorie-webpack`. You can also change the description and change `main` from `index.js` to `app.js`. This is optional, but it is a convention that I like. Especially, where this is where the `App` class is going to be.

// Change the `entry` field in the `webpack.config.js` from `./src/index.js` to `./src/app.js`.

// Delete the `message.js` file if it's there. That was just created to show you how modules work. You can remove everything in the `app.js` file as well.

// - Bring Over Assets & HTML -

// In the `src` folder, create a `css` folder. Bring over the following stylesheets from the Tracalorie project:

- style.css
- bootstrap.css

// We will be installing `bootstrap` and `fontawesome` using NPM, so we don't need to bring over the `fontawesome.css` file. We do want the `bootstrap.css` because it is a customized theme.

// Bring over the `webfonts` folder into the `src` folder as well.

// Copy everything from the `index.html` file and paste it into the `index.html` file in the `src` folder. We need to make some changes here though.

// Delete all of these lines from the `<head>`:

// html
// <link rel="stylesheet" href="css/fontawesome.css" />
// <link rel="stylesheet" href="css/bootstrap.css" />
// <link rel="stylesheet" href="css/style.css" />
// <script src="js/bootstrap.bundle.min.js" defer></script>
// <script src="js/app.js" defer></script>


// We don't need to include the app.js because now that we are using Webpack along with the HTMLWebpackPlugin, it will automatically include the `app.js` file for us. We don't need the stylesheet links because we will be importing our styles. Since we are going to install Bootstrap, we do not need the `bootstrap.bundle.min.js` file either.

// Paste the everything in from the `<body>`. Make sure there are no hardcoded dummy meals or workouts in the HTML.

// - Install Bootstrap & Fontawesome -

// Now we need to install Bootstrap and Fontawesome. We will be using the `bootstrap` and `@fortawesome/fontawesome-free` packages. Install them using NPM:

// bash
npm install bootstrap @fortawesome/fontawesome-free


// Now open your `app.js` file and add the following imports:

// js
import '@fortawesome/fontawesome-free/js/all.js';
import { Modal, Collapse } from 'bootstrap';
import './css/bootstrap.css';
import './css/style.css';


// We need to bring in the `Modal` and `Collapse` classes from Bootstrap in order to use them in our JavaScript.

// Create The CalorieTracker class

// Create a file named `CalorieTracker.js` in the `src` folder. Copy the `CalorieTracker` class from the Tracalorie project and paste it into the `CalorieTracker.js` file.

// At the end of the file, export the class with the following line:

// js
export default CalorieTracker;


// Create The Meal & Workout Classes

// Since the Meal and Workout classes are so simple, let's put it in a single file. Create a file called Items.js in the `src` folder. Copy the `Meal` and `Workout` classes from the Tracalorie project and paste them into the `Items.js` file and export them like this:

// js
export { Meal, Workout };

// Create The Storage Class

// Create a file called `Storage.js` in the `src` folder. Copy the `Storage` class from the Tracalorie project and paste it into the `Storage.js` file. Export the class like this:

// js
export default Storage;


// Import Storage Into CalorieTracker

// The Storage class is only used in the tracker, so import it at the top of `CalorieTracker.js` like this:

// js
import Storage from './Storage';


// Import CalorieTracker & Items Into App

// In the `src/app.js` folder, import the `CalorieTracker` and `Items` classes like this:

// js
import CalorieTracker from './CalorieTracker';
import { Meal, Workout } from './Items';


// Create The App Class

// Now copy the entire App class to the `src/app.js` file. Also, instantiate the App class:

// js
const app = new App();


// Run The Server

// Now we should be all set to run the Webpack dev server. Run the following command:

// bash
npm run dev


// Use The UUID Package

// Instead of using hex values for the item IDs, let's use the `uuid` package. Install it using NPM:

// bash
npm install uuid


// Now, in the `Items.js` file, import the `uuid` package like this:

// js
import { v4 as uuidv4 } from 'uuid';


// Then, in the `Meal` and `Workout` classes, replace the `id` property with the following:

// js
this.id = uuidv4();

// This is a great example of how you can use packages to add functionality to your projects.

// That's it, now you have a modern, modularized project using Webpack. This makes our app more scalable and easier to maintain.




// ***Iterators, Generators & Data Structures***





// ***Symbols***

const sym = Symbol()
const sym1 = Symbol('foo')
const sym2 = Symbol('bar')


console.log(sym, sym1, sym2) //Symbol() Symbol(foo) Symbol(bar)

console.log(typeof sym) //symbol
//it gives me a type of symbol it doesn't give me an object because it is not a referance type it is a primitive data type, if you want to just get the identifier e.g. foo or bar you can use the description property

console.log(sym.description) //undefined
console.log(sym1.description) //foo

// these are just identifier these are not values it doesn't really matter other than just identify

// Symbols are unique
console.log(Symbol('sym') === Symbol('sym')) //false because they are unique

// useful is if there was an object 
// unique id identifier
const user = {
// instead of doing this id: 1
[Symbol('id')]:1, // use a Symbol if you are going to use a variable for a key in an object property you have to use brackets []. It has an identifier of 1
name: 'John Doe',
email: 'john@gmail.com'
}



console.log(user)

//shows me the id which has a Symbol for a key which is completely unique

// {name: 'John Doe', email: 'john@gmail.com', Symbol(id): 1}
// email:"john@gmail.com"
// name:"John Doe"
// Symbol(id):1 
// [[Prototype]]:Object

// can not change the id by saying: 
// user.id = 2

// Symbol(id):1 stays the same and it just adds in addition the id:2 

// {name: 'John Doe', email: 'john@gmail.com', Symbol(id): 1}
// email:"john@gmail.com"
// id:2
// name:"John Doe"
// Symbol(id):1 
// [[Prototype]]:Object

console.log(user['name']) //John Doe


console.log(user[Symbol('id')]) //undefined
// This is because console.log(user[Symbol('id')]) is not the same as [Symbol('id')]:1 in the const user = {} object

// Symbols are NOT enumerable I can't do a for in loop and loop through it and get the Symbol value or key


console.log(Object.keys(user))
// (2) ['name', 'email']
// we do not get the Symbol as it is not enumbrable 1


console.log(Object.values(user))
// (2) ['John Doe', 'john@gmail.com']
// we only get the name and email as [Symbol('id')]:1 is a number enumbrable


for(let key in user){
  console.log(key)
}
//only get the name and email not getting the Symbol


// There is method called getOwnPropertySymbols() - returns an array of symbols that are in an object

// getOwnPropertySymbols()
console.log(Object.getOwnPropertySymbols(user))
// [Symbol(id)]

// There are well known Symbols that are used by Javascript these are used to create special objects that have special properties e.g.

// Symbol.iterator 
// Symbol that is used to create objects that are iterable.

// There is another way to create Symbols that is by using:

Symbol.for() //This is a function that takes a string as it's perameters it will search for existing Symbols that have that same string as it's description and if it finds one it will return that Symbol if it doesn't find one it will create a new Symbol with that string as it's desciption    

// It is stored in the Global Symbol Registry. It first checks the registry before creating it. It works a little different becuase it doen't have the uniqueness as if we were to create a straight Symbol.

// const sym3 = Symbol('foo')
// const sym4 = Symbol('foo')

// console.log(sym3 === sym4) //false


// if we use 'for' it uses that Global Symbol Registry. It registers a Symbol with the description of foo and if I try to access it again or create a new one with sym4 foo it returns that same one.
const sym3 = Symbol.for('foo')
const sym4 = Symbol.for('foo')

console.log(sym3 === sym4) //true


// get a key for the Symbol 
console.log(Symbol.keyFor(sym3)) //foo


console.log(sym1.toString()) //Symbol(foo)
console.log(sym3.toString()) //Symbol(foo)
console.log(sym.toString()) //Symbol()


console.log(sym1.valueOf()) //Symbol(foo)
console.log(sym3.valueOf()) //Symbol(foo)
console.log(sym.valueOf()) //Symbol()


// There are built in or well know Symbols if you want to see a list of those you can:
console.log(Object.getOwnPropertyNames(Symbol))




// ***Iterators***

// objects that define a sequence and potentially returns a value on completion, these are objects that implement the iterator protocol by having a next() method and that next() method returns an object with two specific properties a {value:1, done:bolean false or true}

// two different ways one with the Symbol.iterator as there are some built in Symbols in javascript and one without as if we do not use the Symbol.iterator our iterator is actually not iterable.


// const app = {
// nextIndex: 0, //set as an object property 
// teams: ['Red Sox', 'Yankees', 'Astros', 'Dodgers'],
// next(){
// if(this.nextIndex >= this.teams.length){
// return {done: true}
// }

// const returnValue = {value: this.teams[this.nextIndex], done:false}
// this.nextIndex++
// return returnValue
// }
// }

// console.log(app.next()); //{value: 'Red Sox', done: false}
// console.log(app.next()); //{value: 'Yankees', done: false}
// console.log(app.next()); //{value: 'Astros', done: false}
// console.log(app.next()); //{value: 'Dodgers', done: false}
// console.log(app.next()); //{done: true}


// even though this is an iterator it is not iterable, you can test that by doing a for of loop which a for of loop will loop through an array like object, now arrays and maps these built in data structures in javascript are iterable so you can use for of with them.     

// for(const team of app){
//   console.log(team) //Uncaught TypeError: app is not iterable
// }

// So what we can do is we can implement Symbol.iterator which is a special built in or also called the well known iterator 



const app = {
  teams: ['Red Sox', 'Yankees', 'Astros', 'Dodgers'],
  [Symbol.iterator]: function () {
    let nextIndex = 0;
    return {
      next: () => {
        return nextIndex < this.teams.length
          ? { value: this.teams[nextIndex++], done: false }
          : { done: true };
      },
    };
  },
};

const iterator = app[Symbol.iterator]();
console.log(iterator.next()); //{value: 'Red Sox', done: false}
// console.log(iterator.next().value); //Yankees
// console.log(iterator.next().value); //Astros
// console.log(iterator.next().value); //Dodgers
// console.log(iterator.next().value); //undefined


// it is now looping through outputting them just as you would with an array or an object
for(const team of app){
  console.log(team) 
}
// Red Sox
// Yankees
// Astros
// Dodgers

// Just know there is a difference between an iterator and an iterable as they are both above iterators however the first one is not iterable  


// ***Generators***


// It is to create generate an iterator. It is an easier syntax and easier to maintain.

// generators are functions that can be paused and resumed. There is a keyword we can use called yield that will actually pause the function and we can use it just we used iterators we would call .next() and it will show the first value and call .next() and show the second next value that is where would use the yield.


// the astrix * next to the function lets javascript know that it is a generator  

function* createTeamIterator(teams) {

for (let i=0; i<teams.length; i++){
  yield teams[i]
}
}

const teams = ['Red Sox', 'Yankees', 'Astros', 'Dodgers'];


const iterator = createTeamIterator(teams)

console.log(iterator.next())
// Object
// done: false
// value: "Red Sox"
// [[Prototype]]: Object

// console.log(iterator.next())
// console.log(iterator.next())
// console.log(iterator.next())
// console.log(iterator.next())
// console.log(iterator.next())


// they are iterable 
// for(const team of createTeamIterator(teams)){
//   console.log(team)
// }

// Red Sox
// Yankees
// Astros
// Dodgers


console.log([...createTeamIterator(teams)])

// creates an array of all the teams 
// (4) ['Red Sox', 'Yankees', 'Astros', 'Dodgers']
// 0:"Red Sox"
// 1:"Yankees"
// 2:"Astros"
// 3:"Dodgers"
// length:4
// [[Prototype]]:Array(0)

// we can use destructuring 

const [first, second, third] = createTeamIterator(teams)

// you get the first three teams 
console.log(first, second, third)
// Red Sox Yankees Astros


// ***Profile Scroller Project***


const people = [
  {
    name: 'Jamie Williams',
    age: 26,
    gender: 'female',
    location: 'Los Angeles, CA',
    imageURL: 'https://randomuser.me/api/portraits/women/1.jpg',
    looking: 'Female looking for male',
  },
  {
    name: 'John Smith',
    age: 35,
    gender: 'male',
    location: 'New York, NY',
    imageURL: 'https://randomuser.me/api/portraits/men/1.jpg',
    looking: 'Male looking for female',
  },
  {
    name: 'Bob Johnson',
    age: 42,
    gender: 'male',
    location: 'Chicago, IL',
    imageURL: 'https://randomuser.me/api/portraits/men/2.jpg',
    looking: 'Male looking for male',
  },
  {
    name: 'Shannon Jackson',
    age: 29,
    gender: 'female',
    location: 'Los Angeles, CA',
    imageURL: 'https://randomuser.me/api/portraits/women/2.jpg',
    looking: 'Female looking for female',
  },
];


const container = document.querySelector('.container')
const img = document.querySelector('img')
const profileInfo = document.querySelector('.profile-info')
const nextBtn = document.querySelector('#next')


function* createPeopleIterator(){

let index = 0;
while(true){
yield people[index++ % people.length];
} 
}

const iterator = createPeopleIterator()


nextBtn.addEventListener('click', ()=>{
const person = iterator.next().value;

img.src = person.imageURL
profileInfo.querySelector('h3').textContent = person.name
profileInfo.querySelectorAll('p')[0].textContent = `${person.age} Years Old`
profileInfo.querySelectorAll('p')[1].textContent = `From ${person.location}`
profileInfo.querySelectorAll('p')[2].textContent = person.looking
});


nextBtn.click()





// ***Sets***

// Sets are a data structure built into Javascript that allows you to store a collection of unique values. They are unordered and they do not allow duplicates. Sets are useful when you want to store a collection of values that you want to check for membership, but you don't care about the order of the values.


const set = new Set([1, 2, 3, 4]);
// create a variable set and then set it to a new set so we use a 'new' constructor and pass in an array of values

// console.log(set)
// Set(4) {1, 2, 3, 4}

// they have to be a unique value e.g.
// const set = new Set([1, 2, 2, 2, 3, 3, 3, 4]);
// console.log(set) 
//you will still get an output of: 
// Set(4) {1, 2, 3, 4} as you cannot get two of the same values.


// add to a set 
set.add(5)
// console.log(set)
// Set(5) {1, 2, 3, 4, 5}

// check for membership 
console.log(set.has(3)) //true
console.log(set.has(6)) //false

set.delete(5)
console.log(set) //false
console.log(set.has(5))
// Set(4) {1, 2, 3, 4}


// can convert a set to an array 
const setArray = Array.from(set)
console.log(setArray)
// (4) [1, 2, 3, 4]


// iterator over a set 
for(let item of set){
  console.log(item)
}
// 1
// 2
// 3
// 4


const iterator = set.values()
console.log(iterator.next()) //{value: 1, done: false}
console.log(iterator.next()) //{value: 2, done: false}
console.log(iterator.next()) //{value: 3, done: false}
console.log(iterator.next()) //{value: 4, done: false}
console.log(iterator.next()) //{value: undefined, done: true}

set.clear()
console.log(set)
// Set(0) {size: 0}






// ***Maps***

// Maps

// Maps are another data structure that we can use in JavaScript. Maps were introduced in ES6. They are similar to objects where they have key value pairs, but the keys can be ANY type, not just strings, it could be a number, array or object. Maps are iterable, so we can loop through them as well.

// The Map Object

// The Map object is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.



const myMap = new Map()

myMap.set('name', 'John')
myMap.set(1, 'blue')
myMap.set(2, 'red')


// If you want to get the value you can use the get method 

console.log(myMap.get('name')) //John
console.log(myMap.get(1)) //blue
console.log(myMap.get(2)) //red


// want to get the size 
console.log(myMap.size) //3

console.log(myMap.has(1)) //true
console.log(myMap.has(3)) //false


// delete from our map 

myMap.delete(2)
console.log(myMap)
// Map(2) {'name' => 'John', 1 => 'blue'}


// you can use forEach 

const peopleMap = new Map()
peopleMap.set('brad', {Phone: '555-555-555', email: 'brad@gmail.com'})
peopleMap.set('Jack', {Phone: '555-555-555', email: 'jack@gmail.com'})
peopleMap.set('Gill', {Phone: '555-555-555', email: 'gill@gmail.com'})


peopleMap.forEach((person) => console.log(person.email))
// brad@gmail.com
// jack@gmail.com
// gill@gmail.com

// we can also get the keys, values and entries 

console.log(peopleMap.keys()) //MapIterator {'brad', 'Jack', 'Gill'}

console.log(peopleMap.values())
// MapIterator {{…}, {…}, {…}}
// [[Entries]]
// 0:Object
// 1:Object
// 2:Object

console.log(peopleMap.entries())
// MapIterator {'brad' => {…}, 'Jack' => {…}, 'Gill' => {…}}
// [[Entries]]
// 0:{"brad" => Object}
// 1:{"Jack" => Object}
// 2:{"Gill" => Object}


// As these are iterators we can use the next method

const iterator = peopleMap.values()

console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())


// can covert maps to arrays 

const peopleArray = Array.from(peopleMap)
console.log(peopleArray)
// (3) [Array(2), Array(2), Array(2)]







// ***Poll Project***

const poll = new Map()

// poll.set('key', value); 

poll.set('React', 0);
poll.set('Vue', 0);
poll.set('Angular', 0);
poll.set('Svelte', 0);
poll.set('Other', 0);
// 0 represents number of votes and it is 0 to begin with..

function submitForm(e){
e.preventDefault() //form 

const selectedOption = document.querySelector(
  "input[name='poll-option']:checked"
);

if(!selectedOption){
  alert('Please select an option')
  return
}

let voteCount = poll.get(selectedOption.value)
poll.set(selectedOption.value, voteCount + 1)

// console.log(poll) //track of poll answers

// console.log(selectedOption)

displayResults()

//disable form fields after submit
document.getElementById('poll-form')
.querySelectorAll('input, button').forEach((el)=> el.setAttribute('disabled', true));
}

function displayResults(){
const results = document.getElementById('results') 

// initial empty 
results.innerHTML = ''

// loop through map votes it is an iterable
for(let [option, votes] of poll){

  // create a div 
  const optionElement = document.createElement('div')
  optionElement.classList.add(
    // bootstrap classes 
    'border-bottom',
    'p-2',
    'd-flex',
    'justify-content-between'
  );

  optionElement.innerHTML = `<strong>${option}</strong> ${votes} votes`

  results.appendChild(optionElement)

}

}


document.getElementById('poll-form').addEventListener('submit', submitForm)



// ***Stacks***

// So we have looked at built-in data structures like arrays, objects, sets and maps, but now I want to cover some custom data structures. 

// custom data structures

// Data structures that are not built into the language of javascript. We'll start with stacks, which if you've been following along, you should already be somewhat familiar with because we talked about the `call stack` earlier in the course.

// Stacks are `LIFO` (Last In First Out) data structures. The last item added to the stack will be the first item removed from the stack. We talked about stacks way back when we were looking at the call stack. The call stack is a stack of functions that are called. The last function called is the first function to be removed from the stack.

// Since stacks are not built in to JavaScript, we will have to create our own.We will create a class called `Stack` that will have the following methods:

// - push() //push on top of the stack
// - pop() //push off out from top of the stack
// - peek() //allow us to look at what is on top of the stack
// - length() //length of the items in the stack
// - isEmpty() //returns true if it is empty, false if it is not
// - clear() clear everything in the stack 


// We will have a constructor where we initialize our data. We will use an array to store our data. We will also have a `count` property that will keep track how many items are in the stack. We will use underscores, because they are all private properties, meaning the should not be accessed outside of the class.



// 1.
class Stack {
  // constructor as we want to have two properties first array of items where our data is going to be stored

  constructor(){
    // underscore convention as not going to be accessing _items property outside of the class

    this._items = [] 
    this._count = 0 //count of the stack
  }

  // push items on to the stack
  // item element a piece of data
  push(item){
    // javascript pre-defined push method 
    // this._items.push() 

    // alternative barebones way to write push method
    this._items[this._count] = item 
    this._count++
  }


// 3.

pop(){
// could use the javascript pop method 
// this._items.pop()

// check first that the count is not 0 becuase we do not want to pop off if there is nothing there called an unstacked underflow

// if(this._count === 0){
// return 'underflow'
// }


// 5.
if(this.isEmpty()){
return 'underflow'
}

// in order to pop this off the last item so in this case if we do stacked up pop for 'stack.push('Item 3')' we want 3 to pop off becuase that was the last in so we want that to be the first out. So to have it gone and not set to undefined or not just return whats to be popped off we have to do a little work and we will use a for loop to do it.

// variable item set it to this._items and for the index [this._count - 1] and minus 1 from that so this is the item that is going to be returned
const item = this._items[this._count - 1]

// now going to decrement the count 
this._count--

// for loop is going to start at the count 
for(let i=this._count; i<this._items.length; i++){
this._items[i] = this._items[i+1] 
}

this._items.length = this._count;
return item
}

// 7.
// to see what is on top of the stack 
peek(){
if(this.isEmpty()){
return 'no items in stack'
}

return this._items[this._count - 1]  
}

// 6.
isEmpty(){
return this._count === 0;
}

// 10.
length(){
return this._count

}


// 11.
clear(){
this._items = [];
this._count = 0
}

}


// 2.
// initalize the peek method and console.log the entire stack

// const stack = new Stack();
// console.log(stack)

// Stack {_items: Array(0), _count: 0}
// _count:0
// _items:[]
// [[Prototype]]:Object

const stack = new Stack();

stack.push('Item 1')
stack.push('Item 2')
stack.push('Item 3')
stack.push('Item 4')
stack.push('Item 5')


// 4.
stack.pop()
stack.pop()

// 11.
stack.clear()

// console.log(stack)

// 8.
console.log('top item', stack.peek())

// 9.
// get the length 
console.log('Stack Length: ', stack.length())


// --- Stacks - Teacher Note's ---

// So we have looked at built-in data structures like arrays, objects, sets and maps, but now I want to cover some custom data structures. We'll start with stacks, which if you've been following along, you should already be somewhat familiar with because we talked about the `call stack` earlier in the course.

// Stacks are `LIFO` (Last In First Out) data structures. The last item added to the stack will be the first item removed from the stack. We talked about stacks way back when we were looking at the call stack. The call stack is a stack of functions that are called. The last function called is the first function to be removed from the stack.

// Since stacks are not built in to JavaScript, we will have to create our own.
// We will create a class called `Stack` that will have the following methods:

// - `push()`
// - `pop()`
// - `peek()`
// - `length()`
// - `isEmpty()`

// We will have a constructor where we initialize our data. We will use an array to store our data. We will also have a `count` property that will keep track how many items are in the stack. We will use underscores, because they are all private properties, meaning the should not be accessed outside of the class.

// js
class Stack {
  constructor() {
    this._items = [];
    this._count = 0;
  }
}



// `push()`
// Now we can add the `push()` method. This method will add an item to the top of the stack. Some people just use the built in `push()` method for arrays, but we are going to do this without any help from pre-defined methods. We will use the count as the index and set the item. Then increment the count by 1,

// js
  push(item) {
    this._items[this._count] = item;
    this._count++;
  }


// `pop()`

// Now we can add the `pop()` method. This method will remove an item from the top of the stack. Again, we could take the easy way out and use the `Array.prototype.pop()` method, but we want this to be barebones.

// First, we check to see if the stack is empty and return "Underflow" if it is. That;s what it's called when you try and pop off an item that is not there. It's the opposite of a stack overflow.

// Then we store the last item of the stack into a variable 'item'. This item is going to be returned at the end of the method.

// It decrements the count property by 1, to reflect that the stack now has one less item.

// It starts a for loop, where the variable `i` is initialized to the value of the count, and the loop continues as long as `i` is less than the length of the items array.

// Inside the for loop, the method assigns the value of this.items[i+1] to this.items[i]. This has the effect of shifting all items in the array to the left by one index. This way it removes the last item of the array by shifting all the items to the left by one index.

// The variable i is incremented by one on each iteration, so the loop can continue processing the next item of the array.

// The loop continues until all the items have been shifted to the left.

// Finally, the method updates the length property of the items array to the value of the count property. This reduces the length of the array, effectively removing the last item.

// The last step is returning the variable 'item' that was stored in the first step. This variable holds the value of the last item of the stack before poping it out.

// js
pop() {
   if (this._count === 0) {
      return 'Underflow';
    }
    const item = this._items[this._count - 1];
    this.count--;
    for (let i = this._count; i < this._items.length; i++) {
      this._items[i] = this._items[i + 1];
    }
    this._items.length = this._count;
    return item;
  }


// `isEmpty()`

// We will need to check if the count is === 0 a couple times, so let's create an `isEmpty()` method

// js
isEmpty() {
  return this._count === 0;
}


// Add the `isEmpty()` to the `pop()` method

// js
 if (this.isEmpty()) {
  return 'Underflow';
}


// Now we can add the `peek()` method. This method will return the item at the top of the stack. We will return the item from the `data` array with an indec that is 1 less than the count.

`peek()`

// js
  peek() {
    if (this.isEmpty()) {
      return 'No items in Stack';
    }
    return this._items[this._count - 1];
  }

// `length()`

// Now we can add the `length()` method. This method will return the length of the stack. We will return the `count` property.

// js
length() {
  return this._count;
}


// `clear()`

// This will clear all items and set the count to 0

// js
  clear() {
    this._items = [];
    this._count = 0;
  }

//Now we can create a new instance of the `Stack` class and add some items to it.

// js
const stack = new Stack();

// At the bottom of the script, let's check the length, top item and if empty

// js
console.log('Top item: ', stack.peek());
console.log('Stack Length: ', stack.length());
console.log(stack.isEmpty() ? 'Stack is empty' : 'Stack is not empty');


// Let's add some items

// js
stack.push('First Item');
stack.push('Second Item');


// We should see a length of `2` and a top item of `Second Item`

// Let's add a couple more items. We will add some strings

// js
stack.push('Third Item');
stack.push('Fourth Item');

// Now we should see a length of `4` and a top item of `Fourth Item`

// Let's remove an item

// js
stack.pop();

// We should see a length of `3` and a top item of `Third Item`

// Let's remove a couple more items

// js
stack.pop();
stack.pop();

// You should be able to call `stack.clear()` at any time and it will clear all items.

// We should see a length of `1` and a top item of `First Item`

// So we have created a stack class that we can use in our applications. We can use this class to create a stack of any type of data.




// ***Queues***

// Queues are another type of data stack structure specifically designed to operate in a FIFO context (first-in first-out), where items are inserted into one end of the container and extracted from the other.


// We saw an example of this when we looked at the JavaScript `Task Queue`. The `Task Queue` is a queue of functions that are waiting to be executed. The first function in the queue is the first function to be executed.

// So for example 1 will be the first one in 'enqueue' and it will be the first one out 'dequeue' followed by 2, 3, 4 etc. So it is first in first out.


// Let's create a class called `Queue` that will have the following methods:

// - `enqueue()` - add on to the queue
// - `dequeue()` - pop off out of the queue
// - `peek()` - will look at the front of the queue (not the top as it is in stacks)
// - `length()` - how many items we have in the queue
// - `isEmpty()` - true or false if it is empty or not

// works similar to the stack class in previous topic


// 1.
class Queue {
  constructor() {
    this._items = [];
    this._count = 0;

    //front represent the index of the item or piece of data that is in the front of the queue
    this._front = 0;
  }

// 2.
  // add on to the queue have a method called enqueue
  enqueue(item) {
    this._items[this._count] = item;
    this._count++;
  }

  // 4.
  // to take item off remember it is first in first out so whatever item is on the front is going to come off using a function called dequeue 
    dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }

    // 5.
    const item = this._items[this._front];
    for (let i = this._front; i < this._count - 1; i++) {
      this._items[i] = this._items[i + 1];
    }
    this._count--;
    this._items.length = this._count;
    return item;
  }

  // 6.
  peek() {
    if (this.isEmpty()) {
      return 'No items in the queue';
    }

    return this._items[this._front];
    }

    // 9.
    length() {
    return this._count - this._front;
    }


// 3.
isEmpty(){
    return this._count === 0;
  }
}


// 7.
const q = new Queue();


// 11.
q.enqueue('Item 1');
q.enqueue('Item 2');
q.enqueue('Item 3');

// 12.
q.dequeue();
q.dequeue();

// 8.
console.log('Front Item: ', q.peek());


// 10.
console.log('Queue Length: ', q.length());




// ***Linked Lists***

// A linked list is a data structure that contains a sequence of nodes, a bunch of nodes. So instead of having single items we have a node which has a value and a pointer to the next node. 

// They are similar to arrays, but the difference is that elements are not stored in a particular memory location or index. 

// Rather, each element is a separate object that contains a pointer or a link to the next object in that list.

// Linked Lists are a common interview question. You probably won't use them in your day to day work, but learning this stuff helps your overall understanding of data structures and programming in general.

// A linked list is made up of `nodes`. Each node contains a `value` and a `pointer` to the next node. The first node is called the `head` and the last node is called the `tail`. The `tail` node will point to `null` since there is nothing after it.

// Let's create a class called `LinkedList` that will have the following methods:

// - `insertFirst()` - insert first node head
// - `insertLast()` - insert last node tail
// - `insertAt()` - with an index insert anywhere we want
// - `getAt()` - get any node we want
// - `removeAt()` - remove any node
// - `printListData()` - whatever the values are we want to print those values
// - `clearListData()`. - clear list



// In addition to having a linked list class we are going to have a node class. I want a node object that we instantiate from the node class to represent each one of these nodes.


// Before, we create our class, I'll just use a cheap way of creating a linked list using just hard coded object literals to represent our nodes.

// - Hard Coded Linked Lists Example -

const node1 = {
value:100
};

const node2 = {
  value:200
  };

  const node3 = {
    value: 300,
  }
  
  node1.next = node2
  node2.next = node3
  node3.next = null
  console.log(node1, node2, node3)


  // - Linked List -

  // We want a class where we can instantiate a linked list and we can have different methods to do different things.

// We also want to have a class of node because everytime we create a new node we are going to instantiate a new node object   



// 1.
class Node {
  constructor(value) {  //value of the node
    this._value = value; //not access value outside of the class set to value that is passed in
    this.next = null; //will call this node next outside of this class set to null be default
  }
}

// 2.
class LinkedList {
  constructor() { //not going to take anything in
    this._head = null; //set head to null by default if no nodes then this .head will be null 
    this._length = 0; //0 to begin with
  }


// notice above that with this linked list we are not holding all of our values inside an array or anything inside the instructor like we did with the stack and the queue, instead they will be inside of a node and each node will point to the next one. So the values will get passed in the value above and set to whatever value of the node..


// 4.
 // Insert first node (Head)

 insertFirst(value) {
  // instantiate a new node 
  const newNode = new Node(value);
  newNode.next = this._head; //point to head
  this._head = newNode;
  this._length++;
};


// 6.
// Insert last node (Tail)
insertLast(value) {
  const newNode = new Node(value);
  let current = this._head;

  while (current.next) {
    current = current.next;
  }

  current.next = newNode;
  this._length++;
}

// 11.
// Insert at index
 
  insertAt(value, index) {
    if (index > this._length) {
      return;
    }

    if (index === 0) {
      this.insertFirst(value);
      return;
    }

    const newNode = new Node(value);
    let current, previous;
    current = this._head;
    let count = 0;

    while (count < index) {
      previous = current;
      current = current.next;
      count++;
    }

    newNode.next = current;
    previous.next = newNode;
    this._length++;
  }

  
  // 13.
  // Get at Index 
  getAt(index) {
        let current = this._head;
        let count = 0;
        while (current) {
          if (count === index) {
            console.log(current._value);
          }
          count++;
          current = current.next;
        }
        return null;
      }


// 14.
 // Remove at index

  removeAt(index) {
    if (index > this._length) {
      return;
    }

    let current = this._head;
    let previous;
    let count = 0;

    if (index === 0) {
      this._head = current.next;
    } else {
      while (count < index) {
        count++;
        previous = current;
        current = current.next;
      }
      previous.next = current.next;
    }

    this._length--;
  }


//  8.
// Print list data
  printListData() {
    let current = this._head;
    let list = '';

    while (current) {
      list += current._value + ' ';
      current = current.next;
    }

    // 9.
    console.log(list);
  }

// 16.
 // Clear list

 clearListData() {
      this._head = null;
      this._length = 0;
    }
}

// 3.
const list = new LinkedList();
console.log(list)

// 5.
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);

// 7.
list.insertLast(50);
list.insertLast(10);

// 12.
list.insertAt(500, 2);
list.insertAt(600, 4);

// 15.
list.removeAt(2);
list.removeAt(0);

// 17.
list.clearListData();

// 10.
list.printListData()

// 14.
list.getAt(2)
list.getAt(0)



// - Linked Lists - Teacher Note

// A linked list is a data structure that contains a sequence of nodes, a bunch of nodes. So instead of having single items we have a node which has a value and a pointer to the next node. 

// They are similar to arrays, but the difference is that elements are not stored in a particular memory location or index. 

// Rather, each element is a separate object that contains a pointer or a link to the next object in that list.

// Linked Lists are a common interview question. You probably won't use them in your day to day work, but learning this stuff helps your overall understanding of data structures and programming in general.

// The first node is a head. The last node in the list is the tail that points to null.

// As you can see a linked list is made up of `nodes`. Each node contains a `value` and a `pointer` to the next node. The first node is called the `head` and the last node is called the `tail`. The `tail` node will point to `null` since there is nothing after it.

// Before, we create our class, I'll just use object literals to represent our nodes.

// js
const node1 = {
  value: 100,
};

const node2 = {
  value: 200,
};


// Here we just have two nodes. We can connect them by setting the `next` property on `node1` to be `node2`.

// js
node1.next = node2;

// Now we have a linked list with two nodes. We can add more nodes by setting the `next` property on `node2` to be another node.

// js
const node3 = {
  value: 300,
};

node2.next = node3;

// That is a very simplistic example of a linked list.

// Now, we will create 2 classes, a `Node` class and a `LinkedList` class. The `Node` class will represent a node in the linked list. It will have a `value` property and a `next` property. The `next` property will point to the next node in the list.

// js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

// We can initialize a node with:

// js
const node1 = new Node(100);
console.log(node1); // Node { value: 100, next: null }

// Don't leave this in your code, it is just to show you how we will be initializing nodes within the `LinkedList` class.

// Let's create a class called `LinkedList` that will have the following methods:

// - `insertFirst()`
// - `insertLast()`
// - `insertAt()`
// - `getAt()`
// - `removeAt()`
// - `printListData()`
// - `clearListData()`

// We will have a constructor where we initialize our data. We will use a `head` property to keep track of the first node in the list and a `tail` property to keep track of the last node in the list. I am also going to add some comments for the methods that we will be creating.

// js
class LinkedList {
  constructor(value) {
    this.head = null;
    this.length = 0;
  }

  // Insert first node (head)
  // Insert last node (tail)
  // Insert at index
  // Get at index
  // Remove at index
  // Print the list data
  // Clear list data
}

// `insertfirst()`

// We pass in the data for this node. Then we initialize a new node using the `Node` class. We set the `next` property on the new node to be the `head` property. Then we set the `head` property to be the new node. Finally, we increment the `length` property by `1`.


  // Insert first node (head)
  insertFirst(data) {
    const newNode = new Node(data);
    newNode.next = this.head;
    this.head = newNode;
    this.length++;
  }

// We can test this method by creating a new instance of the `LinkedList` class and calling the `insertFirst()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
console.log(list); // LinkedList { head: Node { value: 100, next: null }, length: 1 }

// The `head` property is now pointing to the new node, which has a `value` of 100 and a `next` value pointing to `null` because it is the only node in the list. The `length` property is now `1`.

// If we add another node with...

// js
list.insertFirst(200);
console.log(list); // LinkedList { head: Node { value: 200, next: Node { value: 100, next: null } }, length: 2 }

// That node with the value of `200` is now the `head` of the list. The `next` property on that node is pointing to the node with the value of `100`. The `length` property is now `2`.

// `insertLast()`

// Now we want to be able to add a node to the end of the list. We will create a method called `insertLast()`.

// js
  // Insert last node (tail)
  insertLast(data) {
    const newNode = new Node(data);
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
    this.length++;
  }

// We create a new node with the data that is passed in. Then we create a variable called `current` and set it to the `head` property. We use a `while` loop to loop through the list until we get to the `tail` node. The `tail` node will have a `next` property of `null`. We set the `next` property on the `tail` node to be the new node. Finally, we increment the `length` property by `1`.

// We can test this method by creating a new instance of the `LinkedList` class and calling the `insertLast()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);
list.insertLast(400);
console.log(list);

// Now the `tail` node has a `value` of `400` and a `next` property of `null`. The `length` property is now `4`.

// `printListData()`

// Let's jump down to the `printListData()` method. This will help us see the data in the list.

// js
  // Print the list data
  printListData() {
    let current = this.head;
    let list = '';
    while (current) {
      list += current.value + ' ';
      current = current.next;
    }
    console.log(list);
  }

// We create a variable called `current` and set it to the `head` property. We create a variable called `list` and set it to an empty string. We use a `while` loop to loop through the list. We add the `value` property of the current node to the `list` variable. We then set the `current` variable to be the `next` property on the current node. We log the `list` variable to the console.

// We can test this method by creating a new instance of the `LinkedList` class and calling the `printListData()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);
list.insertLast(400);
list.printListData(); // 300 200 100 400

// `insertAt()`

// Now we want to be able to insert a node at a specific index. We will create a method called `insertAt()`.

// js
  // Insert at index
  insertAt(data, index) {
    if (index > 0 && index > this.length) {
      return;
    }

    if (index === 0) {
      this.insertFirst(data);
      return;
    }

    const newNode = new Node(data);
    let current, previous;
    current = this.head;
    let count = 0;

    while (count < index) {
      previous = current;
      count++;
      current = current.next;
    }

    newNode.next = current;
    previous.next = newNode;
    this.length++;
  }

// We check if the index is greater than 0 and greater than the length of the list. If it is, we return. If the index is `0`, we call the `insertFirst()` method. We create a new node with the data that is passed in. Then we create a variable called `current` and set it to the `head` property. We create a variable called `previous` and set it to `null`. We create a variable called `count` and set it to `0`. We use a `while` loop to loop through the list until we get to the index that we want to insert the node at. We set the `previous` variable to be the `current` variable. We increment the `count` variable by `1`. We set the `current` variable to be the `next` property on the `current` variable. We set the `next` property on the `newNode` to be the `current` variable. We set the `next` property on the `previous` variable to be the `newNode` variable. Finally, we increment the `length` property by `1`.

// We can test this method by creating a new instance of the `LinkedList` class and calling the `insertAt()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);
list.insertLast(400);
list.insertAt(500, 2);
list.printListData(); // 300 200 500 100 400

// `getAt()`

// Now we want to be able to get a node at a specific index. We will create a method called `getAt()`.

// js
  // Get at index
  getAt(index) {
    let current = this.head;
    let count = 0;
    while (current) {
      if (count == index) {
        console.log(current.value);
      }
      count++;
      current = current.next;
    }
    return null;
  }

// We create a variable called `current` and set it to the `head` property. We create a variable called `count` and set it to `0`. We use a `while` loop to loop through the list. We check if the `count` variable is equal to the index that we want to get. If it is, we log the `value` property of the current node to the console. We increment the `count` variable by `1`. We set the `current` variable to be the `next` property on the `current` variable. We return `null` if the index is not found.

// We can test this method by creating a new instance of the `LinkedList` class and calling the `getAt()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);
list.insertLast(400);
list.insertAt(500, 2);
list.getAt(2); // 500
list.getAt(3); // 100


// `removeAt()`

// Now we want to be able to remove a node at a specific index. We will create a method called `removeAt()`.

// js
  // Remove at index
  removeAt(index) {
    if (index > 0 && index > this.length) {
      return;
    }

    let current = this.head;
    let previous;
    let count = 0;

    if (index === 0) {
      this.head = current.next;
    } else {
      while (count < index) {
        count++;
        previous = current;
        current = current.next;
      }
      previous.next = current.next;
    }
    this.length--;
  }

// We check if the index is greater than 0 and greater than the length of the list. If it is, we return. We create a variable called `current` and set it to the `head` property. We create a variable called `previous` and set it to `null`. We create a variable called `count` and set it to `0`. If the index is `0`, we set the `head` property to be the `next` property on the `current` variable. Otherwise, we use a `while` loop to loop through the list until we get to the index that we want to remove the node at. We increment the `count` variable by `1`. We set the `previous` variable to be the `current` variable. We set the `current` variable to be the `next` property on the `current` variable. We set the `next` property on the `previous` variable to be the `next` property on the `current` variable. Finally, we decrement the `length` property by `1`.

// We can test this method by creating a new instance of the `LinkedList` class and calling the `removeAt()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);
list.insertLast(400);
list.insertAt(500, 2);
list.printListData(); // 300 200 500 100 400
list.removeAt(2);
list.printListData(); // 300 200 100 400

// As you can see, the value of `500` was removed from the list.

// `clearList()`

// Now we want to be able to clear the list. We will create a method called `clearList()`.

// js
  // Clear list
  clearList() {
    this.head = null;
    this.length = 0;
  }

// We set the `head` property to `null` and set the `length` property to `0`.

// We can test this method by creating a new instance of the `LinkedList` class and calling the `clearList()` method.

// js
const list = new LinkedList();
list.insertFirst(100);
list.insertFirst(200);
list.insertFirst(300);
list.insertLast(400);
list.insertAt(500, 2);
list.printListData(); // 300 200 500 100 400
list.clearList();
list.printListData(); // ""


// That's it, we have now created a linked list data structure in JavaScript.




// ***Intro & What Are Algorithms?***

// We looked at some data-structures, popular in software development job interviews. 

// Algorithms are used in computer programming to solve problems. An algorithm is a set of instructions for accomplishing a task. Usually, you have an input or a set of inputs that you run through an algorithm to get an expected output. 

// An algorith can be as simple as a `getSum(n1, n2)` function. You're passing in input, in the form of function arguments, which are the 2 numbers to be added and you have an expected output. You can also write tests to validate that algorithm, loops, are a very popular algorithm for job interviews. Solving algorithms is a skill that takes time to develop. 


// ***What is Unit Testing?***

// In software development, we often write tests to test our code, especially true for really large projects that teams work on. 

// Some developer's say that you always need to test your code, some say it's a waste of precious time. Of course, there is no right or wrong opinion, like most things, it comes down to the developer and the project. Either way, it's good to at least know the basics.

// There's many different types of testing:

// There's unit testing, end-to-end testing, there's integration testing, etc. For the purposes of this course, we're going to be focusing on unit testing, which is one of, if not the most common type. It's also usually the first type of testing done on a project.

// - Unit Testing -

// Unit testing is a way of testing individual pieces of code, called units. 

// Usually the unit you're testing is a function. 

// It is a method of testing where you write test scripts that check if the code is doing what it's supposed to do. 

// For example, if you have a function that adds two numbers together, you would write a test that calls the function with the numbers 1 and 2 and checks that the output is 3. If the function passes the test, it is working correctly. If it fails, it means there is a problem that needs to be fixed.


// - Jest - 

// There are all kinds of testing libraries and frameworks, not just for JavaScript, but for any language. Many of them are similar, they just have a different syntax. We will be using a very popular framework called Jest. 

// Jest is pretty easy to use, there isn't even any need for configuration. We can install it with NPM and then just start writing tests. Jest is also very popular, so there's a lot of documentation and tutorials out there. 

// Learning basic unit testing as well as problem solving with algorithms. I think it's a good combination.



// ***Getting Started with Jest***

// - Unit Testing With Jest -

// Now, we're going to get setup with **Jest**, so that we can write unit tests.

// Create a new folder to work in. You can call it whatever you want, but I'm going to call it `unit-testing-algorithms`.

// We will be installing Jest using NPM, so we first need to run: npm init
// This is to create a `package.json` file.

npm init -y

// - Install Jest -

// Then, we can install Jest with

// terminal
npm install -D jest

// We are installing it as a dev-dependency, because we only need it for development. If you go to packages.json you will devDependancies jest.

// go to test in packages.json and delete whatever is in it and replace it with jest "test": "jest"

"scripts": {
  "test": "jest"
}


// If we want to test a file called `sum.js`, we would create a file called `sum.test.js`.

// create a file called: 

sum.js

// The way it works, is any file where we want to test e.g. sum.js, we make a file with the same name, but with `.test.js` at the end e.g. 

sum.test.js.
// When testing we want to write your test first so you know what you want your unit or function to do and then you can write your function after that, so add the following code:

const sum = require('./sum'); //bring in sum.js

// write our test 
test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toEqual(3);
});

// We are importing the `sum` function from the `sum.js` file. Then, we are using the `test` function to create a test. The first argument is the name of the test, and the second argument is a function that contains the actual test, which is we expect to get 3 as an output, when we have an input of 1 and 2.

// Now, when we need to run our tests, we just run in terminal: 

npm test

// Let's run the test with `npm test`. You should see a fail message like this

// terminal

// FAIL ./sum.test.js
//   × adds 1 + 2 to equal 3
//   ● adds 1 + 2 to equal 3

//   TypeError: sum is not a function

//       2 |
//       3 | test('adds 1 + 2 to equal 3',          () => {
//     > 4 | expect(sum(1, 2)).toBe(3);
//         |          ^
//       5 | });
//       6 |

//       at Object.sum (sum.test.js:4:10)


// Test Suites: 1 failed, 1 total
// Tests:       1 failed, 1 total
// Snapshots:   0 total
// Time:        0.351 s, estimated 1 s

// Obviously, this will fail because we did not even create a `sum()` function yet.

// It will show how many tests ran, passed and failed and will also give us an error message.

// In your `sum.js` file, add the following code:

function sum(a, b) {
  return a + b;
}

module.exports = sum;

// type again in the terminal: 

npm test

// Now, when you run `npm test`, you should see a success message like this:

// PASS  ./sum.test.js
// √ adds 1 + 2 to equal 3 (1 ms)

// Test Suites: 1 passed, 1 total
// Tests:       1 passed, 1 total
// Snapshots:   0 total
// Time:        0.413 s, estimated 1 s


*** Grouping Tests Together*** 
// With `describe()`

// In the last lesson, we used the `test()` function to create a test. However, we can also use the `describe()` function to group tests together. This is useful when we have a lot of tests for a single function.

// Let's take it a step further and write some tests for the FizzBuzz algorithm. We did this challenge a while back. Basically, it needs to return `Fizz` if the number is divisible by 3, `Buzz` if the number is divisible by 5, `FizzBuzz` if the number is divisible by both 3 and 5, and the number itself if it is not divisible by 3 or 5.

// Create a new folder called fizzbuzz and add the files called `fizzbuzz.test.js` and a `fizzbuzz.js`. 

// Let's create fizzbuzz.test.js and add the following code:

const fizzBuzz = require('./fizzbuzz'); //bring in fizzbuzz.js file

// instead of just writing a bunch of different test functions we are going to use describe, it will basically describe a test suite.

describe('fizzBuzz', () => {

  // inside of these functions we can create a bunch of `it` statements or `it` functions, it takes in a description of what I want this test to do or should do, a common convention is to say should and then what you want, then in expect we are testing it should be a function so we check the typeof 

  it('should be a function', () => {
// Then we use the `expect()` function to test the actual value. The first argument is the actual value, and the second argument is the expected value.
    expect(typeof fizzBuzz).toEqual('function');
  });
  
  // We are first testing if it is a function. Then if it returns a number if passed a number. Then if it returns 1 if passed 1.
  it('should return the number not divisible by 3 or 5', () => {
    expect(fizzBuzz(1)).toEqual(1);

    // So we can add as many cases as we want to test.
    // Instead of only testing for the number 1, let's add a few more cases.
    expect(fizzBuzz(13)).toEqual(13);
    expect(fizzBuzz(17)).toEqual(17);
  });

  // let's test if we get `Fizz` if the number is divisible by 3. Add the following code after the last test:
  it('should return Fizz if divisible by 3', () => {
    expect(fizzBuzz(3)).toEqual('Fizz');
    expect(fizzBuzz(6)).toEqual('Fizz');
    expect(fizzBuzz(12)).toEqual('Fizz');
  });

  // if we get `Buzz` if the number is divisible by 5. Add the following code after the last test:
  it('should return Buzz if divisible by 5', () => {
    expect(fizzBuzz(5)).toEqual('Buzz');
    expect(fizzBuzz(10)).toEqual('Buzz');
    expect(fizzBuzz(20)).toEqual('Buzz');
  });

  // FizzBuzz if the number is divisible by both 3 and 5. Add the following code: 
  it('should return FizzBuzz if divisible by 3 & 5', () => {
    expect(fizzBuzz(15)).toEqual('FizzBuzz');
    expect(fizzBuzz(30)).toEqual('FizzBuzz');
    expect(fizzBuzz(45)).toEqual('FizzBuzz');
  });

});



// In fizzbuzz.js add the following code:



function fizzbuzz(num) {
if(number % 15 === 0){
return 'FizzBuzz'
}else if (num % 3 === 0) {
return 'Fizz';
} else if (num % 5 === 0) {
return 'Buzz';
} else {
return num;
}
}

module.exports = fizzBuzz;

//terminal you can run npm test each step of the way.
npm run test 

// terminal 
// PASS  fizzbuzz/fizzbuzz.test.js
// PASS  sum/sum.test.js

// Test Suites: 2 passed, 2 total
// Tests:       6 passed, 6 total
// Snapshots:   0 total
// Time:        0.523 s, estimated 1 s

// Clean up files

// Let's create a folder for each algorithm and put the main file and test file into those. So you will have a folder called `sum` and a folder called `fizzbuzz`. Then, you will have a `sum.js` file and a `sum.test.js` file inside the `sum` folder, and a `fizzbuzz.js` file and a `fizzbuzz.test.js` file inside the `fizzbuzz` folder.



// ***Reverse String Algorithm***

// create a new folder called reverseString and inside the folder add files reverseString.js and reverseString.test.js

// Instructions

// Create a function called `reverseString` that takes a string as an argument and returns the string reversed.


// In reverseString.test.js:

// It should be a function and return a string. It should also return the string reversed.

// reverseString.test.js
const reverseString = require('./reverseString'); //bring in reverseString.js

describe('Reverse String', () => {
  it('should be a function', () => {
    expect(typeof reverseString).toEqual('function');
  });


  it('should return a string', () => {
    expect(typeof reverseString('hello')).toEqual('string');
  });

  it('should return the string reversed', () => {
    expect(reverseString('hello')).toEqual('olleh');
    expect(reverseString('Howdy')).toEqual('ydwoH');
    expect(reverseString('Greetings from Earth')).toEqual(
      'htraE morf sgniteerG'
    );
  });

});


// Hint

// There is no method to reverse a string, but there is a method to reverse an array and strings can be converted into arrays and vice versa.


// reverseString.js 
// Solution 1

function reverseString(str) {
return str.split('').reverse().join('');
}

module.exports = reverseString;

// terminal npm run test 

// We can use the `split` method to split the string into an array of characters. We can then use the `reverse` method to reverse the array. Finally, we can use the `join` method to join the array back into a string.

// This is probably the most straightforward way to solve this problem. Let's look at another solution.


// reverseString.js 
// Solution 2

function reverseString(str) {
  let reversed = '';
  // for of loop through the string 
  for (let character of str) {
    reversed = character + reversed;
  }
  return reversed;
}

module.exports = reverseString;

// terminal npm run test 

// We can use a `for of` loop to iterate through the string. We can then add each character to the beginning of the `reversed` variable. We can then return the `reversed` variable.

// reverseString.js 
// Solution 3

function reverseString(str) {

  // reduce high order array method takes in a function
  return str.split('').reduce((reversed, character) => character + reversed, '')
};

module.exports = reverseString;

// terminal npm run test 

// We can use the `reduce` method to iterate through the string. We can then add each character to the beginning of the `reversed` variable. We can then return the `reversed` variable.



// ***Palindrome Algorithm***

// Palindrome

// A palindrome is a word that is spelled the same forwards and backwards. For example, `kayak` and `rotator` are both palindromes. 

// Instructions

// Create a new folder called Palindrome and put two files called palindrome.js and palindrome.test.js


// palindrome.test.js


const palindrome = require('./palindrome'); //bring in palindrome.js


// Create a function called `palindrome()` that takes a string as an argument and returns `true` if the string is a palindrome and `false` if it is not.

// We are testing to make sure that `palindrome` is a function and that it returns a boolean. We are also testing to make sure that it returns `true` if the string is a palindrome and `false` if it is not. It should also return `false` if the string includes spaces.

describe('palindrome', () => {
  it('should be a function', () => {
    expect(typeof palindrome).toEqual('function');
  });


  it('should return a boolean', () => {
    expect(typeof palindrome('hello')).toEqual('boolean');
  });

  it('should return true if is a palindrome', () => {
    expect(palindrome('kayak')).toBeTruthy();
    expect(palindrome('rotator')).toBeTruthy();
    expect(palindrome('wow')).toBeTruthy();
  });

  it('should return false if is not a palindrome', () => {
    expect(palindrome('hello')).toBeFalsy();
    expect(palindrome('world')).toBeFalsy();
    expect(palindrome('bye')).toBeFalsy();
  });

  it('should return false if includes spaces', () => {
    expect(palindrome(' wow')).toBeFalsy();
    expect(palindrome('wow ')).toBeFalsy();
  });

});



// Solution 1
// palindrome.js

function palindrome(str) {
  const reversed = str.split('').reverse().join('');
  return str === reversed;
}

module.exports = palindrome;
// terminal npm run test

// This is very similar to one of the solutions for the `reverseString` problem. We can use the `split` method to split the string into an array of characters. We can then use the `reverse` method to reverse the array. Finally, we can use the `join` method to join the array back into a string. Then we simply need to check if the `str` is equal to the `reversed` string.

// Solution 2
// palindrome.js

function palindrome(str) {
  // split turning string into an array then use the every() high order array method which loops through
  return str.split('').every((char, i) => {
    // we will check if the first letter matches the last letter and so on, does the character equal to the string, e.g. char === str and then we can get the index of the string, zero will be first letter, but we want to start at the end so we get the str.length and minus whatever the current index is because we want to start at the end and move back but we also want to minus 1 because an array is zero based
    return char === str[str.length - i - 1];
  });
}

module.exports = palindrome;
// terminal npm run test

// We can use the `every` method to check if every character in the string is equal to the character at the same index in the reversed string. We can use the `str.length - i - 1` to get the index of the character in the reversed string.



// ***Array Algorythms Chunking***
// It is breaking an array down into smaller arrays...

// Create a new folder arrayChunk with files inside of arrayChunk.js and arrayChunk.test.js

// I am going to change it up a bit here and use the built-in Node.js `assert` library along with Jest. We don't have to do this and it will do the same thing, but it's just to show you there are multiple ways to test and you may run into this. You can read more about `assert` (https://nodejs.org/api/assert.html).

// An `assertion` is a statement that is either true or false. If it is false, then the program will throw an error. We can use `assert` to test our code. We can use `assert.equal` to test if two values are equal. We can also use `assert.deepEqual` to test if two objects are equal. We can also use `assert.ok` to test if a value is truthy.

// We can basically replace expects with assert, an assertion is a statement that is either true or false.

// arrayChunk.test.js

const assert = require('assert'); // in the node.js standard library so we do not need to install it.
const chunk = require('./arraychunk'); //bring in the function arrayChunk.js


describe('Array Chunking', () => {
  it('Should create chuncks of a specific size', () => {

    // it takes in a an array and a scond argument e.g. 2 which is basically the number of elements that I want in each chunk which I am going to say 2 after we put a comma and this is what we should get so this is wat it should be equal to or the output should be equal to which is going to be an array that has 2 chunks of 2 so this array [1, 2, 3, 4] is in chunks of two would be this [1, 2],[3, 4], 

    assert.deepEqual(chunk([1, 2, 3, 4], 2), [
      [1, 2],
      [3, 4],
    ]);

    // it has to be chunks of 3 and so 4 is left over in another array
    assert.deepEqual(chunk([1, 2, 3, 4], 3), 
    [[1, 2, 3], [4]]);

    assert.deepEqual(chunk([1, 2, 3, 4], 5), [[1, 2, 3, 4]]);
  });
});

// We are going to use `assert.deepEqual` to test if the returned array is equal to the expected array. We can use `assert.deepEqual` to test if two arrays are equal. We can also use `assert.deepEqual` to test if two objects are equal.



// Solution 1
// arrayChunk.js
// Let's also change our functions up a bit and use arrow functions.

// takes in the array and size of the chunks or sub-arrays
const chunk = (array, size) => {
  // initialise to an empty array ultimately what we are going to return
  const chunked = [];

  // loop through to the given array 
  for (let element of array) {
    
    //get the last element of the chunked array length - 1 will give us the last element of the chunk array
    const last = chunked[chunked.length - 1];

    // check to see as long as it is not last or if last.length is equal to size then we are going to add a new chunk
    if (!last || last.length === size) {
      // push on the chunks 
      chunked.push([element]);
    } else {
      // the chunk that is already there 
      last.push(element);
    }
  }
  return chunked;
};

module.exports = chunk;
// terminal npm run test 

// This is a very common solution. We create an empty array called `chunked`. We then loop through the given array. We then check if the last element in `chunked` is equal to the given size. If it is, we push a new chunk into `chunked` with the current element. If not, we add the current element into the chunk.

// Solution 2
// arrayChunk.js
// terminal npm run test 

const chunk = (array, size) => {
  const chunked = [];

  let index = 0;
  while (index < array.length) {
    chunked.push(array.slice(index, index + size));
    index += size;
  }
  
  return chunked;
};


// This is a very similar solution to the first one. We create an empty array called `chunked`. We then loop through the given array. We then use the `slice` method to get a slice of the given array from the current index to the current index plus the given size. We then push the slice into `chunked`. We then increment the index by the given size.




// ***Anagram Algorithm***

// An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.

// Create a new folder called anagram with files anagram.js and anagram.test.js


// anagram.test.js
// Create a function called `anagram()` that takes two strings as arguments and returns `true` if the strings are anagrams and `false` if they are not.

const anagram = require('./anagram');

describe('Anagram', () => {
  it('should be a function', () => {
    expect(typeof anagram).toEqual('function');
  });

  it('should return a boolean', () => {
    expect(typeof anagram('ram', 'arm')).toEqual('boolean');
  });

  it('should return true if is an anagram', () => {
    expect(anagram('cinema', 'iceman')).toBeTruthy();
    expect(anagram('hello world', 'world hello')).toBeTruthy();
    expect(anagram('god', 'dog')).toBeTruthy();
  });

  it('should return false if is not an anagram', () => {
    expect(anagram('hello', 'fellow')).toBeFalsy();
    expect(anagram('world', 'twirl')).toBeFalsy();
    expect(anagram('lose', 'choose')).toBeFalsy();
  });

});


// We are testing to make sure that `anagram` is a function and that it returns a boolean. We are also testing to make sure that it returns `true` if the string is a anagram and `false` if it is not.



// Solution 
// anagram.js

function anagram(str1, str2) {
  const aCharMap = buildCharMap(str1);
  const bCharMap = buildCharMap(str2);

  if (Object.keys(aCharMap).length !== Object.keys(bCharMap).length) {
    return false;
  }

  for (let char in aCharMap) {
    if (aCharMap[char] !== bCharMap[char]) {
      return false;
    }
  }

  return true;
}

function buildCharMap(str) {
  const charMap = {};

  for (let char of str.replace(/[^\w]/g, '').toLowerCase()) {
    charMap[char] = charMap[char] + 1 || 1;
  }

  return charMap;
}


module.exports = anagram;

// We can use a helper function called `buildCharMap` to build a character map for each string. We can then loop through the character map of the first string and check if the character exists in the second string's character map. If it does, we can check if the character count is the same. If it is not, we can return `false`. If it is, we can continue looping. If we make it through the entire loop, we can return `true`.









// ***Get Elements By Tag - jsdom***

// Get Elements By Tag

// We are going to get a little bit more advanced and realistic with our unit testing. I don't expect anyone to get this without watching, unless you're a very experienced JS developer. We are going to test a function that takes a DOM tree and a tag name and returns an array of all the elements in the tree with that tag name.

// This shows you how you can write code that has to do with the DOM and still test it without having to actually create a DOM tree. We won't have any actual HTML or DOM elements. We will just create some mock elements within our test code.

// Remember, we have no DOM. We are working within Node.js. In order to create mock elements, we need to use the `jsdom` test environment. First off, we need to create a Jest config file and add the following to it:

// Create a new folder GetElementsByTag with files inside called GetElementsByTag.js and GetElementsByTag.test.js 

// With recent versions of jest, we need to install an additional package for this to work. So open your terminal and run the following command:

// terminal
npm install -D jest-environment-jsdom

// go to package.json and you should see: 
// "jest-environment-jsdom": "^29.4.0"

// Also to use npm install -D jest-environment-jsdom you need to add a configuration value. Go to the root file outside of the folders add a new file called:

jest.config.js 

// Now, we should be able to create mock elements in our tests.

const config = {
  testEnvironment: 'jsdom',
};

module.exports = config;


// GetElementsByTag.test.js 

const getElementsByTag = require('./getelementsbytag');

describe('Get Elements By Tag', () => {
  it('should be a function', () => {
    expect(typeof getElementsByTag).toEqual('function');
  });

  it('should return an array', () => {
    expect(Array.isArray(getElementsByTag())).toEqual(true);
  });

  it('should return an empty array if no root element is passed in', () => {
    expect(getElementsByTag()).toEqual([]);
  });

  it('should return only the root element in the array if no tagName is passed in', () => {
    const root = document.createElement('div');
    expect(getElementsByTag(root)).toEqual([root]);
  });

  it('should return the correct elements', () => {
    const root = document.createElement('div');

    // Add some child elements to the root
    const p1 = document.createElement('p');
    const p2 = document.createElement('p');
    const span = document.createElement('span');
    root.appendChild(p1);
    root.appendChild(span);
    span.appendChild(p2);

    // Call the function and save the result
    const result = getElementsByTag(root, 'p');

    // Assert that the result is an array containing the two p elements
    expect(result).toEqual([p1, p2]);
  });
});


// terminal: npm run test 

// The Code

// We want to pass in a `root` element and a `tagName`. We want to return an array of all the elements in the tree that have that tag name. We will use the `tagName` property of the element to check if it matches the tag name we are looking for.

// GetElementsByTag.js 

function getElementsByTag(root, tagName) {
  if (!root) return [];
  if (!tagName) return [root];

  let result = [];

  // Check if the root is the tag we are looking for, if so, add it to the result
  if (root.tagName.toLowerCase() === tagName.toLowerCase()) {
    result.push(root);
  }

  // Check if the root has any children, if so, recursively (running the function in the same function because we want o run it on each one of the children) call getElementsByTagName on each child. This will merge the results of each child into the result array
  if (root.hasChildNodes()) {
    for (let child of root.children) {
      result = result.concat(getElementsByTag(child, tagName));
    }
  }

  return result;
}

module.exports = getElementsByTag;

// terminal: npm run test 

// We start off by checking if the `root` is `null` or `undefined`. If it is, we return an empty array. This is because we don't want to return `null` or `undefined` from our function. We want to return an array.

// if we pass in only the `root` and no `tagName`, we return an array containing only the `root` element.

// Next, we create an empty array called `result`. This is where we will store all the elements that match the tag name we are looking for.

// We then check if the `root` element has the tag name we are looking for. If it does, we add it to the `result` array. We use the `tagName` property of the element to check if it matches the tag name we are looking for. We use `toLowerCase` to make sure we are comparing the tag names in a case-insensitive way.

// Next, we check if the `root` element has any children. If it does, we loop through each child and recursively call `getElementsByTagName` on each child. `Recursive` means that we are calling the same function within the function. We then merge the results of each child into the `result` array.

// Finally, we return the `result` array.



// ***Has Duplicate IDs - jsdom***


// Has Duplicate IDs

// We are going to continue to work with the DOM test environment and test a function that takes a DOM tree and returns `true` if there are any duplicate IDs in the tree and `false` if there are not.


// create a new folder called hasDuplicateIds with files hasDuplicateIds.js and hasDuplicateIds.test.js 

// Tests

const hasDuplicateIds = require('./hasduplicateids');

describe('DOM Tree Has Duplicate IDs', () => {
  it('should be a function', () => {
    expect(typeof hasDuplicateIds).toEqual('function');
  });
  it('should return an boolean', () => {
    expect(typeof hasDuplicateIds()).toEqual('boolean');
  });
  it('should return false if no root element is passed in', () => {
    expect(hasDuplicateIds()).toEqual(false);
  });
  it('should return true if there are duplicate ids', () => {
    // Create a mock element tree
    const root = document.createElement('div');
    const child1 = document.createElement('div');
    const child2 = document.createElement('div');
    root.appendChild(child1);
    root.appendChild(child2);

    // Add duplicate ids to the tree
    root.id = 'root';
    child1.id = 'child';
    child2.id = 'child';

    // Call the function and save the result
    const result = hasDuplicateIds(root);

    // Assert that the result is true
    expect(result).toEqual(true);
  });
  it('should return false if there are no duplicate ids', () => {
    // Create a mock element tree
    const root = document.createElement('div');
    const child1 = document.createElement('div');
    const child2 = document.createElement('div');
    root.appendChild(child1);
    root.appendChild(child2);

    // Add duplicate ids to the tree
    root.id = 'root';
    child1.id = 'child1';
    child2.id = 'child2';

    // Call the function and save the result
    const result = hasDuplicateIds(root);

    // Assert that the result is true
    expect(result).toEqual(false);
  });
});



// Keeping Our Tests DRY By Using `beforeEach` and `afterEach`

// As you can see, we have some repeating code where we are creating our root element, adding children, ids, etc. We can use a `beforeEach` block to set up the mock element tree and then use `afterEach` to clean up the mock element tree.

// What these blocks do is run before and after each test. This allows us to set up the mock element tree before each test and then clean it up after each test.


const hasDuplicateIds = require('./hasduplicateids');

describe('DOM Tree Has Duplicate IDs', () => {
  let root;
  beforeEach(() => {
    root = document.createElement('div');
    const child1 = document.createElement('div');
    const child2 = document.createElement('div');
    root.appendChild(child1);
    root.appendChild(child2);
  });

  afterEach(() => {
    root = null;
  });

  it('should be a function', () => {
    expect(typeof hasDuplicateIds).toEqual('function');
  });

  it('should return an boolean', () => {
    expect(typeof hasDuplicateIds()).toEqual('boolean');
    root.id = 'root';
    root.children[0].id = 'child';
    root.children[1].id = 'child';
    const result = hasDuplicateIds(root);
    expect(typeof result).toEqual('boolean');
  });

  it('should return false if no root element is passed in', () => {
    expect(hasDuplicateIds()).toEqual(false);
  });

  it('should return true if there are duplicate ids', () => {
    root.id = 'root';
    root.children[0].id = 'child';
    root.children[1].id = 'child';
    const result = hasDuplicateIds(root);
    expect(result).toEqual(true);
  });
  
  it('should return false if there are no duplicate ids', () => {
    root.id = 'root';
    root.children[0].id = 'child1';
    root.children[1].id = 'child2';
    const result = hasDuplicateIds(root);
    expect(result).toEqual(false);
  });
});



// The Code

function hasDuplicateIds(root, idSet = new Set()) {
  if (!root) return false;

  // If the root has an id and the idSet already has that id, return true
  if (idSet.has(root.id)) return true;

  // If the root has an id, add it to the idSet
  root.id && idSet.add(root.id);

  // If the root has children, recursively call the function on each child
  if (root.hasChildNodes()) {
    for (let child of root.children) {
      const result = hasDuplicateIds(child, idSet);
      if (result) return true;
    }
  }

  return false;
}

module.exports = hasDuplicateIds;


// We are passing in a root element to the tree and a set of ids. We are using a set because it is a data structure that only allows unique values. If we add a value to the set that already exists, it will not be added.

// Then we are checking if the root has an id and if the idSet already has that id. If it does, we return true. If it does not, we add the id to the idSet.

// Then we are checking if the root has children. If it does, we are recursively calling the function on each child. If any of the children return true, we return true. If none of the children return true, we return false.


// ***Node.js Modules (Bonus Module)*** 
























































































































 








</script>
</body>
</html>